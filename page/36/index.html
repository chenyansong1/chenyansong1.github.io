<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Chen&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个技术渣的自说自话">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen's Blog">
<meta property="og:url" content="http://yoursite.com/page/36/index.html">
<meta property="og:site_name" content="Chen's Blog">
<meta property="og:description" content="一个技术渣的自说自话">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen's Blog">
<meta name="twitter:description" content="一个技术渣的自说自话">
  
    <link rel="alternate" href="/atom.xml" title="Chen&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chen&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个技术渣的自说自话</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-bigdata/zookeeper/zookeeper选举及数据一致性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper选举及数据一致性/" class="article-date">
  <time datetime="2017-04-16T04:47:25.353Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper选举及数据一致性/">zookeeper选举及数据一致性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="zab协议"><a href="#zab协议" class="headerlink" title="zab协议"></a>zab协议</h1><p>ZooKeeper Atomic Broadcast 即ZooKeeper原子消息广播协议，简称为ZAB</p>
<ul>
<li>选举过程需要依赖此协议</li>
<li>数据写入过程也需要此协议</li>
<li>ab的核心是定义了那些会改变zk服务器数据状态的事务请求的处理方式</li>
</ul>
<p>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，而余下的其它服务器则成ОFollower服务器。 Leader服务器负责将一个客户端事务请求转换成一个proposal(提议),并将该Proposal分发给集群中所有的Follower服务器。之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那ТLeader就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交</p>
<ul>
<li>zab协议的三阶段:<ul>
<li>发现ͧDiscovery，即选举Leader过程</li>
<li>同步(Synchronization),选举出新的Leader后,Follwer或者Observer从Leader同步最新数据</li>
<li>广播,同步完成之后,就可以接收客户端新的事物请求,并进行广播,实现数据在集群节点的副本存储</li>
</ul>
</li>
</ul>
<h1 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h1><ul>
<li>Leader<ul>
<li>事物请求的唯一调度和处理者,保证集群事物处理的顺序性</li>
<li>集群内部各服务器的调度者</li>
</ul>
</li>
<li>Follower<ul>
<li>处理客户端非事物请求,转发事物请求给Leader服务器</li>
<li>参与事物请求Proposal的投票</li>
<li>参与Leader选举投票</li>
</ul>
</li>
<li>Observer<ul>
<li>处理客户端非事物请求,转发事物请求给Leader服务器</li>
<li>不参与任何形式的投票,包括选举和事务投票(超过半数确认)</li>
<li>此角色存在通常是为了提高读性能</li>
</ul>
</li>
</ul>
<h1 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h1><ul>
<li>LOOKING<ul>
<li>寻找Leader状态</li>
<li>当服务器处于此状态时,表示当前没有Leader,需要进入选举流程</li>
</ul>
</li>
<li>Following<ul>
<li>跟随者状态,表名当前服务器角色是Follower</li>
</ul>
</li>
<li>Observing<ul>
<li>观察者状态,表明当前服务器角色为Observer</li>
</ul>
</li>
<li>Leading<ul>
<li>Leader状态,表明当前服务器角色为Leader</li>
</ul>
</li>
</ul>
<p>以上四种状态由:org.apache.zookeeper.server.quorum. ServerState类维护</p>
<h1 id="集群通信"><a href="#集群通信" class="headerlink" title="集群通信"></a>集群通信</h1><ul>
<li>基于tcp协议</li>
</ul>
<p>为了避免重复创建两个节点之间的tcp连接,zk按照myid数值方向来建立连接,id大的向小的发起连接，在zk实现中，当发现自己的id比发起连接的id还大时,会关闭此连接</p>
<ul>
<li>多端口</li>
</ul>
<p>配置文件中第一个端口是通信和数据同步端口,默认是2888<br>第二个端口是投票端口,默认是3888</p>
<h1 id="选举触发的时机"><a href="#选举触发的时机" class="headerlink" title="选举触发的时机"></a>选举触发的时机</h1><ul>
<li>集群启动<ul>
<li>寻找Leader状态</li>
<li>当服务器处于此状态时,表示当前没有Leader,需要进入选举流程</li>
</ul>
</li>
</ul>
<ul>
<li>崩溃恢复<ul>
<li>Leader宕机</li>
<li>网络原因导致过半数节点与Leader心跳中断</li>
</ul>
</li>
</ul>
<h1 id="影响成为Leader的因素"><a href="#影响成为Leader的因素" class="headerlink" title="影响成为Leader的因素"></a>影响成为Leader的因素</h1><ul>
<li><p>数据新旧程度</p>
<ul>
<li>只有拥有最新数据的接单才能有机会成为Leader</li>
<li>通过事务id(zxid)的大小来表示数据的新旧,越大代表数据越新</li>
</ul>
</li>
<li><p>myid</p>
<ul>
<li>集群启动时,会在data目录下配置myid文件,里面的数字代表当前zk服务器节点的编号</li>
<li>当zk服务器节点数据一样新时,myid中数字越大的就会选举称为Leader</li>
<li>当集群中已经有Leader时,新加入的节点不会影响原有的集群</li>
</ul>
</li>
<li><p>投票数量</p>
<ul>
<li>只有得到集群中多半的投票,才能称为Leader</li>
<li>多半即:(n/2)+1,其中n为集群中的节点数量</li>
</ul>
</li>
</ul>
<h1 id="zxid-事务id-的构成"><a href="#zxid-事务id-的构成" class="headerlink" title="zxid(事务id)的构成"></a>zxid(事务id)的构成</h1><ul>
<li>主进程周期<ul>
<li>也叫epoch</li>
<li>选举的轮次,每多一次选举,则主进程周期加1</li>
<li>zxid总共64位来表示,其高32位代表主进程周期</li>
<li>比较数据新旧的时候,先比较epoch的大小</li>
</ul>
</li>
<li>事务单调递增的计数器<ul>
<li>zxid的低32位表示,选举完成后,从0开始</li>
</ul>
</li>
</ul>
<h1 id="zk的初次启动时的选举过程"><a href="#zk的初次启动时的选举过程" class="headerlink" title="zk的初次启动时的选举过程"></a>zk的初次启动时的选举过程</h1><ul>
<li>第一步:启动myid为1的节点,此时zxid为0,此时没法选举出主节点</li>
<li>第二步:启动myid为2的节点,他的zxid也为0,此时2这个节点成为主节点</li>
<li>第三步:启动myid为3的节点,因为已经有主节点,则3加入集群,2还是leader</li>
</ul>
<h1 id="zk主节点宕机的选举过程"><a href="#zk主节点宕机的选举过程" class="headerlink" title="zk主节点宕机的选举过程"></a>zk主节点宕机的选举过程</h1><ul>
<li><p>场景说明</p>
<ul>
<li>3台机器,此时server2为主,并且server2宕机</li>
</ul>
</li>
<li><p>选举流程</p>
<ul>
<li>变更状态<ul>
<li>当leader宕机后,其他节点的状态变更为Looking</li>
</ul>
</li>
<li>每个server发出一个投自己的票的投票<ul>
<li>生成投票信息(myid,zxid)</li>
<li>假定:server1为(1,123),server3为(2,122)</li>
<li>server1发给server3,server3发给server1</li>
</ul>
</li>
<li>接收投票</li>
<li>投票处理<ul>
<li>server1收到server3,因为server1的zxid(123)比server3的zxid(122)大,所以server3修改自己的投票为(1,123),然后发送给server1</li>
<li>server1收到server3的投票,因为123大于122,因此不改变自己的投票</li>
</ul>
</li>
<li>投票统计<ul>
<li>server3统计:自己收到投票(包括自己投的)中,(1,123)是两票</li>
<li>server1统计:自己收到的投票(包括自己投的)中,(1,123)是两票</li>
</ul>
</li>
<li>修改服务器状态<ul>
<li>server3,选出的leader是server1,因此自己进入followering,即:follower角色</li>
<li>server1,选出的leader是server1,即自己,因此自己进入leading状态,即:自己是leader角色</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><ul>
<li>同步时机</li>
</ul>
<p>当leader完成选举后,follower需要与新的leader同步数据</p>
<ul>
<li>同步准备–leader<ul>
<li>leader告诉其他follower当前最新数据是什么即zxid<ul>
<li>leader构建一个newleader的包,包括当前最大的zxid,发送给所有的follower或者Observer</li>
</ul>
</li>
<li>leader给每个follower创建一个线程leaderHandler来负责处理每个follower的数据同步请求,同时主线程开始阻塞,只有超过一半的follower同步完成,同步过程才完成,leader才能成为真正的leader</li>
<li>根据同步算法进行操作</li>
</ul>
</li>
<li>同步准备–follower端<ul>
<li>选举完成后,尝试与leader建立同步连接,如果一段时间没有连接上就报错超时,重新回到选举状态</li>
<li>向leader发送followerinfo包,带上follower自己最大的zxid</li>
<li>根据不同同步算法进行操作</li>
</ul>
</li>
<li>初始化<ul>
<li>minCommittedLog:最小的事务日志id,即zxid(没有被快照存储的日志文件的第一条,每次快照存储完,会重新生成一个事务日志文件)</li>
<li>maxCommittedLog:事务日志中最大的事务,即zxid</li>
</ul>
</li>
<li>同步算法<ul>
<li>直接差异化同步(diff同步)</li>
<li>仅回滚同步(trunc),即删除多余的事务日志,比如原来的主宕机后重新加入,可能存在他自己写入提交但是别的节点还没来得及提交</li>
<li>先回滚再差异化同步(trunc+diff同步)</li>
<li>全量同步(snap同步)</li>
</ul>
</li>
</ul>
<h1 id="同步应用的场景"><a href="#同步应用的场景" class="headerlink" title="同步应用的场景"></a>同步应用的场景</h1><h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><ul>
<li>把follower最后的事务zxid称为peerLastZxid</li>
<li>当minCommittedLog&lt;peerLastZxid&lt;maxCommittedLog</li>
</ul>
<p>同步方案:</p>
<ul>
<li>直接差异化同步</li>
<li>leader会给follower服务器发送diff指令,意思是:进入差异化数据同步阶段,leader会把proposal同步给follower</li>
<li>实际同步过程会先发送数据修改proposal,然后再发送commit指令数据包</li>
</ul>
<p>举例说明</p>
<p>某个时刻Leader服务器为proposal队列对应的zxid依次是0x500000001 0x500000002 0x500000003 0x500000004 0x500000005<br>此时follower的peerLastZxid为0x500000003，因此需要把0x500000004 0x500000005同步给follower</p>
<p>差异化同步的消息发送顺序如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">发送顺序</th>
<th style="text-align:center">数据包类型</th>
<th style="text-align:center">对应的zxid</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">proposal</td>
<td style="text-align:center">0x500000004</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">commit</td>
<td style="text-align:center">0x500000004</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">proposal</td>
<td style="text-align:center">0x500000005</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">commit</td>
<td style="text-align:center">0x500000005</td>
</tr>
</tbody>
</table>
<p>执行的流程如下:</p>
<ul>
<li>follower端收到diff指令,然后进入diff同步阶段</li>
<li>follower收到同步的数据和提交命令,并应用到内存数据库中</li>
<li>同步完成后:<ul>
<li>leader会发送一个newLeader指令,通知follower已经将最新的数据都同步给follower了</li>
<li>follower收到newLeader指令后反馈一个ack消息,表名自己已经完成同步</li>
</ul>
</li>
<li>单个follower的同步完成,Leader进入集群的”过半策略”等待状态</li>
<li>当有超过一半的follower都同步完成后,leader会向已经完成同步的follower发送uptodate指令,用于通知follower完成数据同步,可以对外提供服务了</li>
<li>follower收到leader的uptodate指令后,会终止数据同步流程,向leader再次反馈ack消息</li>
</ul>
<h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p>Leader在提交本地完成，还没有把事务Proposal提交给其它节点前，leader宕机了</p>
<p>假设3个节点的集群，分别是A,B,Cͺ没有宕机前，leader是B，已经发送过0X500000001和0X500000002的数据和事务提交proposal，并且发送了0X500000003的数据修改提议，但是在B节点<br>发送事务提交的proposal之前，B宕机了，由于B是本机发送，所以B的本地事务已经提交，即B最新的数据是0X500000003</p>
<p>在A和C进行选举后，C成为主,并且进行过两次数据修改，对应的Proposal是0X600000001 0X600000002</p>
<p>B机器恢复后加入集群(AC), 重新进行数据同步，对于B来说，peerLastZxidО0X500000003,对于当前的主C来说, minCommittedLog= 0X500000001 maxCommittedLog= 0X600000002</p>
<p>同步方案:</p>
<ul>
<li>B恢复后,并且向已有的集群(AC)注册后,向C发起同步连接请求</li>
<li>B向leader(C)发送followerinfo包,带上follower自己最大的zxid</li>
<li>C发现B上没有自己的事务提交记录(0X500000003),则向B发送trunc命令,让B混滚到0X500000002</li>
<li>B完成混滚后,向C发送信息包,确认完成,并说明当前的zxid为0X500000002</li>
<li>C向B发送diff同步命令</li>
<li>B收到Diff命令后进入同步状态,并向C发送ack确认包</li>
<li>C陆续把对应的差异数据和Commit提交proposal发送给B,当数据发送完成后,在发送通知包给B</li>
<li>B应用用于内存的数据结构,当收到C通知已经完成同步后,B给回应ACK,并且结束同步</li>
</ul>
<h2 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h2><p>某个节点宕机时间太长,当恢复并且加入集群后,数据的事务日志文件已经生成多个,此时的minCommittedLog比节点宕机时的最大日志还要大</p>
<p>假设B宕机后,几天后才恢复,此时minCommittedLog为0X6000008731，而peerLastZxid为0X500000003</p>
<p>同步方案</p>
<ul>
<li>采用全量同步(snap)</li>
<li>当leader(C)发现,B的zxid小于minCommittedLog时,向B发送snap指令</li>
<li>B收到指令,进入同步阶段</li>
<li>leader(C)会从内存数据库中获取全量的数据发送给B</li>
<li>B收到数据处理完成后,C还会把最新的proposal(全量同步期间产生)通过增量的方式发送给B</li>
</ul>
<h1 id="广播流程"><a href="#广播流程" class="headerlink" title="广播流程"></a>广播流程</h1><ul>
<li>集群选举完成后,并且完成数据同步后,即可开始对外提供服务,接收读写请求</li>
<li>当leader接收到客户端新的事务请求后,会生成对应的事务proposal,并根据zxid的顺序向所有的follower发送提案,即:proposal</li>
<li>当follower收到leader的事务proposal时,根据接收的先后顺序处理这些proposal,即如果先后收到1,2,3条,则如果处理完了第3条,则代表1,2两条一定已经处理成功</li>
<li>当leader收到follower针对某个事务proposal过半的ack后,则发起事务提交,重新发送一个commit的proposal</li>
<li>follower收到commit的proposal后,记录事务提交,并把数据更新到内存数据库</li>
<li>补充说明:<ul>
<li>由于只有过半的机器给出反馈,则可能存在某时刻某些节点数据不是最新的</li>
<li>业务上如果需要确认读取到的数据是最新的,则可以读取之前,调用sync方法进行数据同步</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper选举及数据一致性/" data-id="cj290scoi01d5ssqqu7ogsags" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/zookeeper运维日常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper运维日常/" class="article-date">
  <time datetime="2017-04-16T04:47:25.352Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper运维日常/">zookeeper运维日常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul>
<li>Zk本身是基于java实现的，因此,调大JVM内存是优化点之一,具体数额需要根据业务情况来定,涉及到的JVM参数为-Xmx-Xms-Xmn</li>
<li>IO优化:把事务日志与快照存储分磁盘存储,提高IOPS,最好事务日志单独磁盘挂载</li>
<li>加大linux系统的文件句柄数和用户线程数,通过linux的命令ulimit可以查看当前的配置</li>
<li>业务并发高时,可以创建多于1个的客户端会话,可以不同的业务模块采用不同的客户端实例</li>
<li>利用zk进行业务开发时,尽量通过良好的设计减少资源消耗,比如watcher的数量</li>
<li>节点数量,在写少,读多应用场景,采用多一点的节点会提升整体的读并发性能</li>
<li>节点数据最好比默认的10M还小</li>
<li>带宽尽量高,可以通过网络监控查看带宽是否已经是瓶颈</li>
</ul>
<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><ul>
<li>停机<br>增加相应的节点即可,比较简单</li>
</ul>
<ul>
<li>不停机<ul>
<li>增加新的节点,id一定要比原来集群的要大</li>
<li>新节点启动后会加入集群,并且同步数据</li>
<li>当用mntr命令查看新的节点数据已经同步成功后做下面的操作</li>
<li>按照之前的id顺序依次再去关闭zk实例,然后修改配置,启动实例</li>
</ul>
</li>
</ul>
<h1 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h1><ul>
<li>单机房的容灾靠zk本身的集群机制就能很好的支撑</li>
<li>多机房的容灾<br>由于多半投票机制,zk不支持双机房的容灾,比如5节点,分为2和3,当3这个机房出现故障    ,2不能选举成功<br>因此,多机房容灾主要是考虑三机房的情况<br>跨机房的网络延时较大,做这个容灾要避免大量写应用场景</li>
</ul>
<p>为了避免服务器的地址变化影响客户端,客户端尽量采用域名的方式</p>
<h1 id="重点监控指标"><a href="#重点监控指标" class="headerlink" title="重点监控指标"></a>重点监控指标</h1><ul>
<li>连接数</li>
<li>注册的watchers数</li>
<li>zk事件通知的延时是否过大</li>
<li>zookeeper事务日志<ul>
<li>磁盘IO</li>
<li>可以开启事务日志自动清理<ul>
<li>autopurge.snapRetainCount</li>
<li>autopurge.purgeInterval=24</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper运维日常/" data-id="cj290scoe01d2ssqqkyfvx4lj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/zookeeper目录文件说明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper目录文件说明/" class="article-date">
  <time datetime="2017-04-16T04:47:25.351Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper目录文件说明/">zookeeper目录文件说明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-bin目录文件"><a href="#1-bin目录文件" class="headerlink" title="1.bin目录文件"></a>1.bin目录文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">.sh为linux的脚本文件</div><div class="line">.cmd为Windows的脚本文件</div><div class="line">*/</div><div class="line">[root@data-1-1 zookeeper0]# cd bin/</div><div class="line">[root@data-1-1 bin]# ll</div><div class="line">total 48</div><div class="line">-rwxr-xr-x 1 1000 1000  238 Feb 20  2014 README.txt</div><div class="line">-rwxr-xr-x 1 1000 1000 1937 Feb 20  2014 zkCleanup.sh</div><div class="line">-rwxr-xr-x 1 1000 1000 1049 Feb 20  2014 zkCli.cmd                        </div><div class="line">-rwxr-xr-x 1 1000 1000 1534 Feb 20  2014 zkCli.sh            #客户端启动脚本</div><div class="line">-rwxr-xr-x 1 1000 1000 1333 Feb 20  2014 zkEnv.cmd</div><div class="line">-rwxr-xr-x 1 1000 1000 2697 Nov  5 16:53 zkEnv.sh            #环境变量启动脚本</div><div class="line">-rwxr-xr-x 1 root root 2696 Nov  5 16:44 zkEnv.sh.bak</div><div class="line">-rwxr-xr-x 1 1000 1000 1084 Feb 20  2014 zkServer.cmd</div><div class="line">-rwxr-xr-x 1 1000 1000 5797 Nov  6 19:35 zkServer.sh            #服务端启动脚本</div><div class="line">-rw-r--r-- 1 root root 5980 Nov  5 16:45 zookeeper.out            #日志文件</div><div class="line">[root@data-1-1 bin]#</div></pre></td></tr></table></figure>
<h1 id="2-conf目录"><a href="#2-conf目录" class="headerlink" title="2.conf目录"></a>2.conf目录</h1><ol>
<li>zoo_sample.cfg为样例配置文件，需要修改为自己的名称，一般为zoo.cfg</li>
<li>Log4j.properties为日志配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@data-1-1 zookeeper0]# cd conf/</div><div class="line">[root@data-1-1 conf]# ll</div><div class="line">total 48</div><div class="line">-rw-rw-r-- 1 1000 1000   535 Feb 20  2014 configuration.xsl</div><div class="line">-rw-rw-r-- 1 1000 1000  2161 Nov  5 16:55 log4j.properties                #log4j日志</div><div class="line">-rw-r--r-- 1 root root  1085 Nov  6 19:20 zoo.cfg            #启动的配置文件</div><div class="line">-rw-r--r-- 1 root root 21487 Nov  6 23:11 zookeeper.out        #日志文件</div><div class="line">-rw-rw-r-- 1 1000 1000   922 Feb 20  2014 zoo_sample.cfg.bak          #启动的配置文件（原）</div><div class="line">[root@data-1-1 conf]#</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="3-contrib目录"><a href="#3-contrib目录" class="headerlink" title="3.contrib目录"></a>3.contrib目录</h1><p>一些用于操作zk的工具包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[root@data-1-1 zookeeper0]# cd contrib/</div><div class="line">[root@data-1-1 contrib]# ll</div><div class="line">total 32</div><div class="line">drwxr-xr-x 4 1000 1000 4096 Feb 20  2014 fatjar</div><div class="line">drwxr-xr-x 3 1000 1000 4096 Feb 20  2014 loggraph</div><div class="line">drwxr-xr-x 2 1000 1000 4096 Feb 20  2014 rest</div><div class="line">drwxr-xr-x 3 1000 1000 4096 Feb 20  2014 zkfuse</div><div class="line">drwxr-xr-x 4 1000 1000 4096 Feb 20  2014 zkperl</div><div class="line">drwxr-xr-x 3 1000 1000 4096 Feb 20  2014 zkpython</div><div class="line">drwxr-xr-x 4 1000 1000 4096 Feb 20  2014 zktreeutil</div><div class="line">drwxr-xr-x 7 1000 1000 4096 Feb 20  2014 ZooInspector</div><div class="line">[root@data-1-1 contrib]#</div></pre></td></tr></table></figure></p>
<h1 id="4-lib目录"><a href="#4-lib目录" class="headerlink" title="4.lib目录"></a>4.lib目录</h1><p>zk依赖的某些jar包</p>
<h1 id="5-recipes"><a href="#5-recipes" class="headerlink" title="5.recipes"></a>5.recipes</h1><p>zk某些用法的代码示例</p>
<h1 id="6-dist-maven-目录"><a href="#6-dist-maven-目录" class="headerlink" title="6.dist-maven 目录"></a>6.dist-maven 目录</h1><p>maven编译后的发布目录</p>
<h1 id="7-dataDir目录"><a href="#7-dataDir目录" class="headerlink" title="7.dataDir目录"></a>7.dataDir目录</h1><p>在zoo.cfg中的dataDir 选项配置中是数据的配置目录<br>如，默认是：/tmp/zookeeper/<br>那么在zk服务启动额时候，在/tmp/zookeeper/zookeeper_server.pid  是server的进程pid<br>如果将服务停止，那么该文件将会被自动删除</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper目录文件说明/" data-id="cj290sco601cwssqqmq93urr9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/zookeeper的配置文件说明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper的配置文件说明/" class="article-date">
  <time datetime="2017-04-16T04:47:25.349Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper的配置文件说明/">zookeeper的配置文件说明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1.基本配置"></a>1.基本配置</h1><p>最低配置要求中必须配置的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">clientPort</div><div class="line">#监听客户端连接的端口。</div><div class="line"></div><div class="line">tickTime</div><div class="line">#基本事件单元，这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，每隔tickTime时间就会发送一个心跳；最小 的session过期时间为2倍tickTime 　　</div><div class="line"></div><div class="line">dataDir</div><div class="line">#存储内存中数据库快照的位置，如果不设置参数，更新事务的日志将被存储到默认位置。</div><div class="line"></div><div class="line">/*</div><div class="line">应该谨慎的选择日志存放的位置，使用专用的日志存储设备能够大大提高系统的性能，如果将日志存储在比较繁忙的存储设备上，那么将会很大程度上影像系统性能</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h1 id="2-高级配置"><a href="#2-高级配置" class="headerlink" title="2.高级配置"></a>2.高级配置</h1><p>高级配置参数中可选配置参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">dataLogdDir</div><div class="line">#这个操作让管理机器把事务日志写入“dataLogDir”所指定的目录中，而不是“dataDir”所指定的目录。这将允许使用一个专用的日志设备，帮助我们避免日志和快照的竞争</div><div class="line"></div><div class="line"></div><div class="line">maxClientCnxns</div><div class="line">/*这个操作将限制连接到Zookeeper的客户端数量，并限制并发连接的数量，通过IP来区分不同的客户端。</div><div class="line">此配置选项可以阻止某些类别的Dos攻击。将他设置为零或忽略不进行设置将会取消对并发连接的限制。</div><div class="line">例如，此时我们将maxClientCnxns的值设为1，如下所示：</div><div class="line">#set maxClientCnxns</div><div class="line">   maxClientCnxns=1</div><div class="line">启动Zookeeper之后，首先用一个客户端连接到Zookeeper服务器上。之后如果有第二个客户端尝试对Zookeeper进行连接，</div><div class="line">或者有某些隐式的对客户端的连接操作，将会触发Zookeeper的上述配置</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">minSessionTimeout和maxSessionTimeout </div><div class="line">#即最小的会话超时和最大的会话超时时间。在默认情况下，minSession=2*tickTime；maxSession=20*tickTime</div></pre></td></tr></table></figure></p>
<h1 id="3-集群配置"><a href="#3-集群配置" class="headerlink" title="3.集群配置"></a>3.集群配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">initLimit=10</div><div class="line">#此配置表示，允许follower(相对于Leaderer言的“客户端”)连接并同步到Leader的初始化连接时间，以tickTime为单位。当初始化连接时间超过该值，则表示连接失败。</div><div class="line"> </div><div class="line">syncLimit=5</div><div class="line">#此配置项表示Leader与Follower之间发送消息时，请求和应答时间长度。如果follower在设置时间内不能与leader通信，那么此follower将会被丢弃。</div><div class="line"> </div><div class="line">server.A=B：C：D</div><div class="line">/*</div><div class="line">#Example</div><div class="line">server.0=hadoop:2288:3388</div><div class="line">server.1=hadoop0:2288:3388</div><div class="line">server.2=hadoop1:2288:3388</div><div class="line"></div><div class="line">A：其中 A 是一个数字，表示这个是服务器的编号；</div><div class="line">B：是这个服务器的 ip 地址；</div><div class="line">C：Leader选举的端口；</div><div class="line">D：Zookeeper服务器之间的通信端口。</div><div class="line">*/</div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line">myid和zoo.cfg</div><div class="line">/* </div><div class="line">除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，</div><div class="line">这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server</div><div class="line">*/</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper的配置文件说明/" data-id="cj290sco201ctssqqyz0l4mie" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/zookeeper的典型应用场景" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper的典型应用场景/" class="article-date">
  <time datetime="2017-04-16T04:47:25.348Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper的典型应用场景/">zookeeper的典型应用场景</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-数据发布-订阅"><a href="#1-数据发布-订阅" class="headerlink" title="1.数据发布/订阅"></a>1.数据发布/订阅</h1><p>数据发布/订阅即所谓的配置中心：发布者将数据发布到zk的一个或者一系列节点上，阅者进行数据订阅，当数据有变化时，可以及时得到数据的变化通知</p>
<p>因为应用B对zk的某一个节点进行了监听（watch） ，所以当应用A向该监听的节点发布数据的时候（即节点的数据发生变化），此时会触发监听，然后就会通知应用B（即订阅的过程）</p>
<h1 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2.负载均衡"></a>2.负载均衡</h1><p>本质是利用zookeeper的配置管理功能，涉及的步骤为：</p>
<ol>
<li>服务提供者把自ٜ的域名及IP 端口的映射注册到zk中</li>
<li>服务消费者通过域名从zk中获取到对应的IP及端口，这个IP及端口有多个，只是获取其中一个</li>
<li>当服务提供者宕机时，对应的域名与IP的对应就会减少一个映射</li>
<li>阿里的dubbo服务框架就是基于zk来实现服务路由和负载</li>
</ol>
<h1 id="3-命令服务"><a href="#3-命令服务" class="headerlink" title="3.命令服务"></a>3.命令服务</h1><p>&emsp;在分布式系统中，服务命令（Name Service）也是很重要的应用场景，通过zk也可以实现类似于J2EE中的JNDI的<br>效果；分布式环境中，命令服务更多的是资源定位，并不是真正的实体资源，其本质是用到zk的其中配置管理和<font color="red">查找</font></p>
<h1 id="4-分布式协调和通知"><a href="#4-分布式协调和通知" class="headerlink" title="4.分布式协调和通知"></a>4.分布式协调和通知</h1><ol>
<li>通过watcher和通知机制实现</li>
<li>分布式锁</li>
<li>分布式事务</li>
</ol>
<h1 id="5-集群管理"><a href="#5-集群管理" class="headerlink" title="5.集群管理"></a>5.集群管理</h1><ol>
<li>当前集群中的机器数量</li>
<li>集群中的机器的运行时状态</li>
<li>集群中节点的上下线操作</li>
<li>集群节点的统一配置</li>
</ol>
<h1 id="6-Master选举"><a href="#6-Master选举" class="headerlink" title="6.Master选举"></a>6.Master选举</h1><ol>
<li>临时节点</li>
<li>顺序节点</li>
</ol>
<h1 id="7-分布式锁"><a href="#7-分布式锁" class="headerlink" title="7.分布式锁"></a>7.分布式锁</h1><ol>
<li>排他锁</li>
<li>共享锁</li>
</ol>
<h1 id="8-分布式队列"><a href="#8-分布式队列" class="headerlink" title="8.分布式队列"></a>8.分布式队列</h1><p>FIFO</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper的典型应用场景/" data-id="cj290scny01cqssqq9rglgl9d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/zookeeper的事务日志" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper的事务日志/" class="article-date">
  <time datetime="2017-04-16T04:47:25.347Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper的事务日志/">zookeeper的事务日志</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="日志文件的存储路径"><a href="#日志文件的存储路径" class="headerlink" title="日志文件的存储路径"></a>日志文件的存储路径</h1><ul>
<li>存储于datalog或者是dataLogDir配置目录</li>
<li>对应目录下的version-2代表的是日志格式版本号</li>
<li>日志文件命名<ul>
<li>文件大小都是64m</li>
<li>后缀都是16进制格式数字,逐渐增大,其本质是本日志文件的第一条zxid号</li>
</ul>
</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/bigdata/zookeeper/log/1.png" alt=""></p>
<h1 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h1><ul>
<li>zk提供了工具类org.apache.zookeeper.server. LogFormatter解析日志的内容</li>
<li>第一行是日志格式信息</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/bigdata/zookeeper/log/2.png" alt=""></p>
<h1 id="日志写入"><a href="#日志写入" class="headerlink" title="日志写入"></a>日志写入</h1><ul>
<li>Zk通过类org.apache.zookeeper.server.persistence. FileTxnLog实现对事务日志的管理<ul>
<li>通过append方法来添加事务日志</li>
</ul>
</li>
<li>写入过程<ul>
<li>确定是否有事务日志文件可写,当第一次创建事务日志文件或者上一个事务日志文件写满后都会关闭这个文件流</li>
<li>确定事务日志是否需要扩容,当文件剩余空间不足4KB时,把文件新增64MB(新增一个日志文件),用0填充剩余的空间</li>
<li>事务序列化</li>
<li>生成checksum</li>
<li>写入事务日志文件流</li>
<li>事务日志刷入磁盘,本质是调用系统的fsync接口</li>
</ul>
</li>
</ul>
<h1 id="数据快照"><a href="#数据快照" class="headerlink" title="数据快照"></a>数据快照</h1><ul>
<li>zk某个时刻的完整数据</li>
<li>快照文件的后缀为服务器最新的zxid</li>
<li>通过工具类SnapshotFormatter可以查看快照文件的文件内容</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/bigdata/zookeeper/log/3.png" alt=""></p>
<h1 id="快照流程"><a href="#快照流程" class="headerlink" title="快照流程"></a>快照流程</h1><ul>
<li>确定是否需要进行数据快照<ul>
<li>snapCount默认是100000,表示达到这个数量的日志才开始进行快照</li>
<li>为了避免集群节点同时进行快照,按照如下公式触发快照:<br>logCount &gt;(snapCount/2+randRoll) //randRoll是为1—snapCount/2之间的随机数</li>
</ul>
</li>
<li>切换事务日志文件<ul>
<li>创建新的事务日志文件</li>
</ul>
</li>
<li>创建数据快照异步线程</li>
<li>获取全量数据和会话信息</li>
<li>生成快照数据文件</li>
<li>把数据刷入快照文件</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper的事务日志/" data-id="cj290sco901czssqqssk0c3hd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/zookeeper的Znode数据模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper的Znode数据模型/" class="article-date">
  <time datetime="2017-04-16T04:47:25.345Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper的Znode数据模型/">zookeeper的Znode数据模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-zkdatabase、datatree、datanode的关系"><a href="#1-zkdatabase、datatree、datanode的关系" class="headerlink" title="1.zkdatabase、datatree、datanode的关系"></a>1.zkdatabase、datatree、datanode的关系</h1><p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/bigdata/zookeeper/znode_structure/1.png" alt=""></p>
<h2 id="1-1-DataTree"><a href="#1-1-DataTree" class="headerlink" title="1.1.DataTree"></a>1.1.DataTree</h2><p>整个zk的数据就靠datatree维护，包括数据、目录、权限, DataTree是<strong>内存数据</strong>存储的核心，是一个树结构，代表了内存中一份完整的数据。DataTree不包含任何与网络、客户端连接及请求处理相关的业务逻辑，是一个独立的组件, 默认初始化三目录</p>
<h2 id="1-2-DataNode"><a href="#1-2-DataNode" class="headerlink" title="1.2.DataNode"></a>1.2.DataNode</h2><p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/bigdata/zookeeper/znode_structure/2.jpg" alt=""></p>
<ol>
<li>树形结构中的每个节点叫做做Znode</li>
<li>使用路径来引用一个节点，节点的路径是绝对的，没有相对路径，如：/app1是一个节点，/app1/p_1是一个节点</li>
<li>DataNode是数据存储的最小单元，其内部除了保存了结点的数据内容、ACL列表、节点状态之外，还记录了父节点的引用和子节点列表两个属性，其也提供了对子节点列表进行操作的接口。</li>
</ol>
<h2 id="1-3-ZKDatabase"><a href="#1-3-ZKDatabase" class="headerlink" title="1.3. ZKDatabase"></a>1.3. ZKDatabase</h2><p>Zookeeper的内存数据库，管理Zookeeper的所有会话、DataTree存储和事务日志。ZKDatabase会定时向磁盘dump快照数据，同时在Zookeeper启动时，会通过磁盘的事务日志和快照文件恢复成一个完整的内存数据库。
　　</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper的Znode数据模型/" data-id="cj290scnu01cnssqqed1l3p8y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/zookeeper的ACL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper的ACL/" class="article-date">
  <time datetime="2017-04-16T04:47:25.344Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper的ACL/">zookeeper的ACL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ACL组成"><a href="#ACL组成" class="headerlink" title="ACL组成"></a>ACL组成</h1><ul>
<li>Scheme:id:permission 比如:world:anyone:crdwa</li>
<li>Scheme:验证过程中使用的检验策略</li>
<li>id:权限被赋予的对象,比如ip或者某个用户</li>
<li>permission为权限,上面的crdwa,表示5个权限组合</li>
<li>通过setAcl命令设置节点的权限</li>
<li>节点的acl不具有继承关系</li>
<li>getAcl可以查看节点的acl权限信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 0] getAcl /student</div><div class="line">&apos;world,&apos;anyone</div><div class="line">: cdrwa</div></pre></td></tr></table></figure>
<h2 id="Scheme类型–world"><a href="#Scheme类型–world" class="headerlink" title="Scheme类型–world"></a>Scheme类型–world</h2><ul>
<li>scheme:id:permission</li>
<li>id为固定值,anyone,表示任何用户</li>
<li>world:anyone:crdwa    表示任何用户都具有crdwa权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] setAcl /student world:anyone:ca</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 2] getAcl /student</div><div class="line">&apos;world,&apos;anyone</div><div class="line">: ca		#没有读权限</div><div class="line">[zk: localhost:2181(CONNECTED) 3] get /student</div><div class="line">Authentication is not valid : /student</div></pre></td></tr></table></figure>
<h2 id="Scheme类型–auth"><a href="#Scheme类型–auth" class="headerlink" title="Scheme类型–auth"></a>Scheme类型–auth</h2><ul>
<li>Scheme:id:permisstion,比如:auth:username:password:crdwa</li>
<li>表示给认证通过的所有用户设置acl权限</li>
<li>同时可以添加多个用户</li>
<li>通过addauth命ј进行认证用户的添加:addauth digest <username>:<password></password></username></li>
<li>auth策略的本质就是digest</li>
<li>如果通过addauth创建多组用户和密码，当使用setAcl修改权限时，所有的用户和密码的权限都会跟着修改</li>
<li>通过addauth新创建的用户和密码组需要重新调用setAcl才会入到权限组中去</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">#创建节点</div><div class="line">[zk: localhost:2181(CONNECTED) 4] create /node2 &quot;node2data&quot;</div><div class="line">Created /node2</div><div class="line"></div><div class="line">#获取默认的acl</div><div class="line">[zk: localhost:2181(CONNECTED) 5] getAcl /node2</div><div class="line">&apos;world,&apos;anyone</div><div class="line">: cdrwa</div><div class="line"></div><div class="line">#设置acl(不能设置,因为node2u:1111这样的用户是不存在的,所以验证不通过,即不能设置)</div><div class="line">[zk: localhost:2181(CONNECTED) 6] setAcl /node2 auth:node2u:1111:crdwa</div><div class="line">Acl is not valid : /node2</div><div class="line"></div><div class="line">#添加用户</div><div class="line">[zk: localhost:2181(CONNECTED) 7] addauth digest node2u:1111</div><div class="line"></div><div class="line">#再次设置acl</div><div class="line">[zk: localhost:2181(CONNECTED) 8] setAcl /node2 auth:node2u:1111:crdwa</div><div class="line">cZxid = 0x2d</div><div class="line">ctime = Thu Feb 23 21:52:48 CST 2017</div><div class="line">mZxid = 0x2d</div><div class="line">mtime = Thu Feb 23 21:52:48 CST 2017</div><div class="line">pZxid = 0x2d</div><div class="line">cversion = 0</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 1</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 11</div><div class="line">numChildren = 0</div><div class="line">[zk: localhost:2181(CONNECTED) 9]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#在另外一个客户端上(因为本地没有验证用户)</div><div class="line">[zk: localhost:2181(CONNECTED) 0] get /node2</div><div class="line">Authentication is not valid : /node2</div><div class="line"></div><div class="line">#添加验证用户</div><div class="line">[zk: localhost:2181(CONNECTED) 3] addauth digest node2u:1111</div><div class="line">[zk: localhost:2181(CONNECTED) 4] get /node2</div><div class="line">&quot;node2data&quot;</div><div class="line">cZxid = 0x2d</div><div class="line">ctime = Thu Feb 23 21:52:48 CST 2017</div><div class="line">mZxid = 0x2d</div><div class="line">mtime = Thu Feb 23 21:52:48 CST 2017</div><div class="line">pZxid = 0x2d</div><div class="line">cversion = 0</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 1</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 11</div><div class="line">numChildren = 0</div><div class="line">[zk: localhost:2181(CONNECTED) 5]</div></pre></td></tr></table></figure>
<h2 id="Scheme类型–digest"><a href="#Scheme类型–digest" class="headerlink" title="Scheme类型–digest"></a>Scheme类型–digest</h2><ul>
<li>scheme:id:permission, 比如: digest:username:password:crdwa</li>
<li>指定某个用户及他的密码可以访问</li>
<li>此处的username:password必须进过SHA-1和BASE64编码<ul>
<li>BASE64(SHA1(username:password))</li>
</ul>
</li>
<li>通过addauth命令进行认证用户的添加<ul>
<li>addauth digest <username>:<password></password></username></li>
</ul>
</li>
</ul>
<h2 id="Scheme类型—IP"><a href="#Scheme类型—IP" class="headerlink" title="Scheme类型—IP"></a>Scheme类型—IP</h2><ul>
<li>Scheme:id:permission ，比如: ip:127.0.0.1:crdwa</li>
<li>指定某个IP地址可以访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 8] create /node5 &quot;node5data&quot;</div><div class="line">Created /node5</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 9] setAcl /node5 ip:127.0.0.1:crdwa</div><div class="line">cZxid = 0x34</div><div class="line">ctime = Thu Feb 23 22:06:30 CST 2017</div><div class="line">mZxid = 0x34</div><div class="line">mtime = Thu Feb 23 22:06:30 CST 2017</div><div class="line">pZxid = 0x34</div><div class="line">cversion = 0</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 1</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 11</div><div class="line">numChildren = 0</div><div class="line">[zk: localhost:2181(CONNECTED) 10] get /node5	##这是为什么?????</div><div class="line">Authentication is not valid : /node5</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 11] setAcl ip:192.168.0.33:crdwa</div><div class="line">[zk: localhost:2181(CONNECTED) 12] get /node5</div><div class="line">Authentication is not valid : /node5</div><div class="line">[zk: localhost:2181(CONNECTED) 13]</div></pre></td></tr></table></figure>
<h2 id="Scheme类型—super"><a href="#Scheme类型—super" class="headerlink" title="Scheme类型—super"></a>Scheme类型—super</h2><ul>
<li>供运维人员维护节点使用</li>
<li>有权限操作任何节点</li>
<li>启动时,在命令参数中配置<ul>
<li>-Dzookeeper.DigestAuthenticationProvider.superDigest=admin:015uTByzA4zSglcmseJsxTo7n3c=</li>
<li>打开zkCli.cmd，在java命令后面增加以上配置</li>
</ul>
</li>
<li>用户名和密码也需要通过sha1和base64编码</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper的ACL/" data-id="cj290scnq01ckssqq1yk4i7z5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/zookeeper开源客户端" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper开源客户端/" class="article-date">
  <time datetime="2017-04-16T04:47:25.343Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper开源客户端/">zookeeper开源客户端</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-原生api的不足"><a href="#1-原生api的不足" class="headerlink" title="1.原生api的不足"></a>1.原生api的不足</h1><ul>
<li>连接的创建是异步的，需要开发人员自行编码实现等待</li>
<li>连接没有自动的超时重连机制</li>
<li>zk本省不提供序列化机制,需要开发人员自行制定,从而实现数据的序列化和反序列化</li>
<li>watcher注册一次只会生效一次,需要不断的重新注册</li>
<li>watcher的使用方式不合符java本身的术语,如果采用监听方式,将更容易理解</li>
<li>不支持递归创建树形节点</li>
</ul>
<h1 id="2-开源客户端–ZkClient介绍"><a href="#2-开源客户端–ZkClient介绍" class="headerlink" title="2.开源客户端–ZkClient介绍"></a>2.开源客户端–ZkClient介绍</h1><p>Github上一个开源的zk客户端，由datameer的工程师Stefan Groschupf和Peter Voss一起开发</p>
<ul>
<li>解决session会话超时重连</li>
<li>watcher反复注册</li>
<li>简化开发API</li>
<li>其他</li>
<li>github地址:<a href="https://github.com/sgroschupf/zkclient" target="_blank" rel="external">https://github.com/sgroschupf/zkclient</a></li>
</ul>
<p>特点:</p>
<ul>
<li>简单</li>
<li>社区不活跃,连API文档都不完善</li>
</ul>
<h1 id="3-开源客户端—Curator介绍"><a href="#3-开源客户端—Curator介绍" class="headerlink" title="3.开源客户端—Curator介绍"></a>3.开源客户端—Curator介绍</h1><p>Apache基金会的顶级项目之一</p>
<ul>
<li>解决session会话超时重连</li>
<li>Watcher反复注册</li>
<li>简化开发api</li>
<li>遵循Fluent风格Api规范</li>
<li>NodeExistsException异常处理</li>
<li>大招:共享锁服务 master选举 分布式计数器等</li>
<li>其他</li>
<li><a href="http://curator.apache.org" target="_blank" rel="external">http://curator.apache.org</a></li>
</ul>
<h1 id="Curator—API"><a href="#Curator—API" class="headerlink" title="Curator—API"></a>Curator—API</h1><h2 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CuratorFrameworkFactory.newClient(connectString, retryPolicy)</div><div class="line">CuratorFrameworkFactory.newClient(connectString, sessionTimeoutMs, connectionTimeoutMs, retryPolicy)</div><div class="line">	</div><div class="line">#启动:start()方法</div><div class="line">CuratorFrameworkFactory.newClient(&quot;localhost:2181,localhost:2182&quot;, retryPolicy).start();</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>connectString</td>
<td>逗՚分开的ip:port对</td>
</tr>
<tr>
<td>retryPolicy</td>
<td>重试策略，默认四种:<br>Exponential BackoffRetry,RetryNTimes,RetryOneTime,RetryUntilElapsed</td>
</tr>
<tr>
<td>sessionTimeoutMs</td>
<td>会话超时时间，单位为毫秒，默认60000ms</td>
</tr>
<tr>
<td>connectionTimeoutMs</td>
<td>连接创建超时时间，单位为毫秒，默认是15000ms</td>
</tr>
</tbody>
</table>
<blockquote>
<p>重试策略</p>
</blockquote>
<ul>
<li>实现接口RetryPolicy可以自定义重试策略<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public abstract interface org.apache.curator.RetryPolicy &#123;  </div><div class="line">  public abstract boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>retryCount</td>
<td>已经重试的次数，如果第一次重试，此值为0</td>
</tr>
<tr>
<td>elapsedTimeMs</td>
<td>重试花费的时间，单位为毫秒</td>
</tr>
<tr>
<td>sleeper</td>
<td>类似于Thread.sleep,用于sleep指定时间</td>
</tr>
<tr>
<td>返回值</td>
<td>如果还会继续重试,则返回Ture</td>
</tr>
</tbody>
</table>
<blockquote>
<p>四种默认重试策略</p>
</blockquote>
<ul>
<li>ExponentialBackoffRetry<ul>
<li>ExponentialBackoffRetry(int baseSleepTimeMs, int maxRetries)</li>
<li>ExponentialBackoffRetry(int baseSleepTimeMs, int maxRetries, int maxSleepMs)</li>
<li>当前应该sleep的时间: baseSleepTimeMs * Math.max(1, random.nextInt(1 &lt;&lt; (retryCount + 1)))</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>baseSleepTimeMs</td>
<td>初始化sleep时间</td>
</tr>
<tr>
<td>maxRetries</td>
<td>最大重试次数</td>
</tr>
<tr>
<td>maxSleepMs</td>
<td>最大重试时间</td>
</tr>
<tr>
<td>返回值</td>
<td>如果还会继续重试,则返回Ture</td>
</tr>
</tbody>
</table>
<ul>
<li>RetryNTimes<ul>
<li>RetryNTimes(int n, int sleepMsBetweenRetries)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>最大重试次数</td>
</tr>
<tr>
<td>sleepMsBetweenRetries</td>
<td>每次重试的时间间隔</td>
</tr>
</tbody>
</table>
<ul>
<li>RetryOneTime<ul>
<li>只重试一次</li>
<li>RetryOneTime(int sleepMsBetweenRetry)        #sleepMsBetweenRetry为重试间隔的时间</li>
</ul>
</li>
</ul>
<ul>
<li>RetryUntilElapsed<ul>
<li>RetryUntilElapsed(int maxElapsedTimeMs, int sleepMsBetweenRetries)</li>
<li>重试的时间超过最大时间后，就不再重试</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>maxElapsedTimeMs</td>
<td>最大重试时间</td>
</tr>
<tr>
<td>sleepMsBetweenRetries</td>
<td>每次间隔重试时间</td>
</tr>
</tbody>
</table>
<h2 id="Fluent风格的API"><a href="#Fluent风格的API" class="headerlink" title="Fluent风格的API"></a>Fluent风格的API</h2><ul>
<li>定义:一种面向对象的开发方式，目的是提高代码的可读性</li>
<li>实现方式:通过方法的级联或者方法链的方式实现</li>
<li>举例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private CuratorFramework client = null;</div><div class="line">RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);</div><div class="line"></div><div class="line">//以方法链的方式</div><div class="line">client = CuratorFrameworkFactory.builder()</div><div class="line">		.connectString(&quot;localhost:2181,localhost:2182&quot;)</div><div class="line">		.sessionTimeoutMs(10000).retryPolicy(retryPolicy)</div><div class="line">		.namespace(&quot;base&quot;).build();</div><div class="line"></div><div class="line">client.start();</div></pre></td></tr></table></figure>
<h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">client.create()	//返回CreateBuilder</div><div class="line">   .creatingParentsIfNeeded()	//递归创建父目录</div><div class="line">   .withMode(CreateMode.PERSISTENT)//设置节点属性，比如:CreateMode.PERSISTENT，如果是递归创建模式为临时节点，则只有ՙ子节点是临时节点，非ՙ子节点都为持久节点</div><div class="line">   .withACL(Ids.OPEN_ACL_UNSAFE)//设置acl</div><div class="line">      .forPath(path, data);//指定路径</div></pre></td></tr></table></figure>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">client.delete()	//返回DeleteBuilder</div><div class="line">		.guaranteed()	//确保节点被删除</div><div class="line">		.deletingChildrenIfNeeded()	//递归删除所有子节点</div><div class="line">		.withVersion(version)	//特定版本՚号</div><div class="line">		.inBackground(new DeleteCallBack())</div><div class="line">		.forPath(path);	//指定路径</div></pre></td></tr></table></figure>
<blockquote>
<p>关于guaranteed：<br>Solves edge cases where an operation may succeed on the server but connection failure occurs before a response can be successfully returned to the client<br>意思是:解决当某个删除操作在服务器端可能成功，但是此时客户端与服务器端的连接中断，而删除的响应没有成功返回到客户端<br>底层的本质:重试</p>
</blockquote>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/bigdata/zookeeper/curator/1.png" alt=""></p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/bigdata/zookeeper/curator/2.png" alt=""></p>
<ul>
<li>关于异步操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">inBackground()</div><div class="line">inBackground(Object context)</div><div class="line">inBackground(BackgroundCallback callback)</div><div class="line">inBackground(BackgroundCallback callback, Object context)</div><div class="line">inBackground(BackgroundCallback callback, Executor executor)</div><div class="line">inBackground(BackgroundCallback callback, Object context, Executor executor)</div><div class="line"></div><div class="line">//从参数看跟zk的原生异࠵api相同，多了一个线程池，用于执行回调</div></pre></td></tr></table></figure>
<ul>
<li>异步操作回调</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">client.delete().guaranteed().deletingChildrenIfNeeded().</div><div class="line">	withVersion(version).inBackground(new DeleteCallBack()).forPath(path);</div><div class="line"></div><div class="line">----------------DeleteCallBack--------------------</div><div class="line"></div><div class="line">public class DeleteCallBack implements BackgroundCallback &#123;</div><div class="line">	public void processResult(CuratorFramework client, CuratorEvent event)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println(event.getPath()+&quot;,data=&quot;+event.getData());</div><div class="line">		System.out.println(&quot;event type=&quot;+event.getType());</div><div class="line">		System.out.println(&quot;event code=&quot;+event.getResultCode());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>异步操作事件状态:event.getType()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public final enum CuratorEventType &#123;</div><div class="line">  </div><div class="line">  CREATE;</div><div class="line">  DELETE;</div><div class="line">  EXISTS;</div><div class="line">  GET_DATA;</div><div class="line">  SET_DATA;</div><div class="line">  CHILDREN;</div><div class="line">  SYNC;</div><div class="line">  GET_ACL;</div><div class="line">  SET_ACL;</div><div class="line">  WATCHED;</div><div class="line">  CLOSING;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>异步操作事件状态码:event.getResultCode()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">/*--------------org.apache.zookeeper.KeeperException.Code ---------*/</div><div class="line"></div><div class="line">public static enum Code implements CodeDeprecated &#123;</div><div class="line">    /** Everything is OK */</div><div class="line">    OK (Ok),</div><div class="line"></div><div class="line">    /** System and server-side errors.</div><div class="line">     * This is never thrown by the server, it shouldn&apos;t be used other than</div><div class="line">     * to indicate a range. Specifically error codes greater than this</div><div class="line">     * value, but lesser than &#123;@link #APIERROR&#125;, are system errors.</div><div class="line">     */</div><div class="line">    SYSTEMERROR (SystemError),</div><div class="line"></div><div class="line">    /** A runtime inconsistency was found */</div><div class="line">    RUNTIMEINCONSISTENCY (RuntimeInconsistency),</div><div class="line">    /** A data inconsistency was found */</div><div class="line">    DATAINCONSISTENCY (DataInconsistency),</div><div class="line">    /** Connection to the server has been lost */</div><div class="line">    CONNECTIONLOSS (ConnectionLoss),</div><div class="line">    /** Error while marshalling or unmarshalling data */</div><div class="line">    MARSHALLINGERROR (MarshallingError),</div><div class="line">    /** Operation is unimplemented */</div><div class="line">    UNIMPLEMENTED (Unimplemented),</div><div class="line">    /** Operation timeout */</div><div class="line">    OPERATIONTIMEOUT (OperationTimeout),</div><div class="line">    /** Invalid arguments */</div><div class="line">    BADARGUMENTS (BadArguments),</div><div class="line">    </div><div class="line">    /** API errors.</div><div class="line">     * This is never thrown by the server, it shouldn&apos;t be used other than</div><div class="line">     * to indicate a range. Specifically error codes greater than this</div><div class="line">     * value are API errors (while values less than this indicate a</div><div class="line">     * &#123;@link #SYSTEMERROR&#125;).</div><div class="line">     */</div><div class="line">    APIERROR (APIError),</div><div class="line"></div><div class="line">    /** Node does not exist */</div><div class="line">    NONODE (NoNode),</div><div class="line">    /** Not authenticated */</div><div class="line">    NOAUTH (NoAuth),</div><div class="line">    /** Version conflict */</div><div class="line">    BADVERSION (BadVersion),</div><div class="line">    /** Ephemeral nodes may not have children */</div><div class="line">    NOCHILDRENFOREPHEMERALS (NoChildrenForEphemerals),</div><div class="line">    /** The node already exists */</div><div class="line">    NODEEXISTS (NodeExists),</div><div class="line">    /** The node has children */</div><div class="line">    NOTEMPTY (NotEmpty),</div><div class="line">    /** The session has been expired by the server */</div><div class="line">    SESSIONEXPIRED (SessionExpired),</div><div class="line">    /** Invalid callback specified */</div><div class="line">    INVALIDCALLBACK (InvalidCallback),</div><div class="line">    /** Invalid ACL specified */</div><div class="line">    INVALIDACL (InvalidACL),</div><div class="line">    /** Client authentication failed */</div><div class="line">    AUTHFAILED (AuthFailed),</div><div class="line">    /** Session moved to another server, so operation is ignored */</div><div class="line">    SESSIONMOVED (-118),</div><div class="line">    /** State-changing request is passed to read-only server */</div><div class="line">    NOTREADONLY (-119);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在回调函数中可以打印错误状态码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class DeleteCallBack implements BackgroundCallback &#123;</div><div class="line"></div><div class="line">	public void processResult(CuratorFramework client, CuratorEvent event)</div><div class="line">			throws Exception &#123;</div><div class="line">		System.out.println(event.getPath()+&quot;,data=&quot;+event.getData());</div><div class="line">		System.out.println(&quot;event type=&quot;+event.getType());</div><div class="line">		System.out.println(&quot;event code=&quot;+event.getResultCode());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//打印结果:</div><div class="line">/,data=null</div><div class="line">event type=DELETE</div><div class="line">event code=-111		//-111表示有子节点，所以删除失败，只有为0(ok)表示删除成功</div></pre></td></tr></table></figure></p>
<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void readNode(String path) throws Exception &#123;</div><div class="line">	Stat stat = new Stat();</div><div class="line">	byte[] data = client.getData().storingStatIn(stat).forPath(path);</div><div class="line">	System.out.println(&quot;读取节点&quot; + path + &quot;的数据:&quot; + new String(data));</div><div class="line">	System.out.println(stat.toString());</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">client.getData() 返回GetDataBuilder</div><div class="line">storingStatIn(org.apache.zookeeper.data.Stat stat) //把服务器端获取的状态数据存储到stat对象</div><div class="line">Byte[] forPathͧString pathͨ//节点路径</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void updateNode(String path, byte[] data, int version) throws Exception &#123;</div><div class="line">	client.setData().withVersion(version).forPath(path, data);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">client.setData() //返回SetDataBuilder</div><div class="line">withVersion(version)	//特定版本号</div><div class="line">forPath(path, data)	//节点路径和data</div><div class="line">forPath(path)	//节点路径</div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="读取子节点"><a href="#读取子节点" class="headerlink" title="读取子节点"></a>读取子节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void getChildren(String path) throws Exception &#123;</div><div class="line">	List&lt;String&gt; children = client.getChildren().usingWatcher(new WatcherTest()).forPath(&quot;/curator&quot;);</div><div class="line">	for (String pth : children) &#123;</div><div class="line">		System.out.println(&quot;child=&quot; + pth);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">client.getChildren()	//返回GetChildrenBuilder</div><div class="line">storingStatIn(org.apache.zookeeper.data.Stat stat) //把服务器端获取的状态数据存储到stat对象</div><div class="line">Byte[] forPathͧString pathͨ//节点路径</div><div class="line">usingWatcher(org.apache.zookeeper.Watcher watcher) //设置watcher，类似于zk本身的api，也只能使用一次</div><div class="line">usingWatcher(CuratorWatcher watcher) //设置watcher ，类似于zk本身的api，也只能使用一次</div><div class="line"></div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="设置watcher"><a href="#设置watcher" class="headerlink" title="设置watcher"></a>设置watcher</h2><ul>
<li>watcher之NodeCache<ul>
<li>监听数据节点的内容变更</li>
<li>监听节点的创建,即如果指定的节点不存在，则节点创建后，会触发这个监听</li>
</ul>
</li>
</ul>
<p>构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">NodeCache(CuratorFramework client, String path)</div><div class="line">NodeCache(CuratorFramework client, String path, boolean dataIsCompressed)</div><div class="line"></div><div class="line">/*</div><div class="line">client 		客户端实例</div><div class="line">path 		数据节点路径</div><div class="line">dataIsCompressed  是否进行数据压缩</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>回调接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public interface NodeCacheListener</div><div class="line">void nodeChanged() //没有参数，怎么获取事件信息以及节点数据？</div></pre></td></tr></table></figure></p>
<p>实例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void addNodeDataWatcher(String path) throws Exception &#123;</div><div class="line">	final NodeCache nodeC = new NodeCache(client, path);</div><div class="line">	nodeC.start(true);</div><div class="line"></div><div class="line">	nodeC.getListenable().addListener(new NodeCacheListener() &#123;//回调接口</div><div class="line">		public void nodeChanged() throws Exception &#123;</div><div class="line">			String data = new String(nodeC.getCurrentData().getData());//直接通过NodeCache获取数据</div><div class="line">			System.out.println(&quot;path=&quot; + nodeC.getCurrentData().getPath()</div><div class="line">					+ &quot;:data=&quot; + data);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>watcher之PathChildrenCache<ul>
<li>监听指定节点的子节点变化情况</li>
<li>包括:新增子节点,子节点数据变更和子节点删除</li>
</ul>
</li>
</ul>
<p>构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">PathChildrenCache(CuratorFramework client, String path, boolean cacheData)</div><div class="line"></div><div class="line">PathChildrenCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, CloseableExecutorService executorService)</div><div class="line"></div><div class="line">PathChildrenCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ExecutorService executorService)</div><div class="line"></div><div class="line">PathChildrenCache(CuratorFramework client, String path, boolean cacheData, boolean dataIsCompressed, ThreadFactory threadFactory)</div><div class="line"></div><div class="line">PathChildrenCache(CuratorFramework client, String path, boolean cacheData, ThreadFactory threadFactory)</div><div class="line"></div><div class="line">/*</div><div class="line"></div><div class="line">*/</div></pre></td></tr></table></figure>
<p>回调接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface PathChildrenCacheListener&#123;</div><div class="line">	void childEvent(CuratorFramework client, PathChildrenCacheEvent event)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造函数参数说明</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>client</td>
<td>客户端实例</td>
</tr>
<tr>
<td>path</td>
<td>数据节点路径</td>
</tr>
<tr>
<td>dataIsCompressed</td>
<td>是否进行数据压缩</td>
</tr>
<tr>
<td>cacheData</td>
<td>用于配置是否把节点内容缓存起来，如果配置为true，那么客户端在接收到节点列表变更的同时，也能够获取到节点的数据内容ͺ如果为false,则无法取到数据内容</td>
</tr>
<tr>
<td>threadFactory</td>
<td>通过଑两个参数构造专门的线程池来处理事件通知</td>
</tr>
<tr>
<td>executorService</td>
</tr>
</tbody>
</table>
<p>实例代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public void addChildWatcher(String path) throws Exception &#123;</div><div class="line">	final PathChildrenCache cache = new PathChildrenCache(this.client, path, true);</div><div class="line">	cache.start(StartMode.POST_INITIALIZED_EVENT);//ppt中需要讲StartMode</div><div class="line">	System.out.println(cache.getCurrentData().size());</div><div class="line">	</div><div class="line">	cache.getListenable().addListener(new PathChildrenCacheListener() &#123;</div><div class="line">		public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception &#123;</div><div class="line">			if(event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED))&#123;</div><div class="line">				System.out.println(&quot;客户端子节点cache初始化数据完成&quot;);</div><div class="line">				System.out.println(&quot;size=&quot;+cache.getCurrentData().size());</div><div class="line">			&#125;else if(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED))&#123;</div><div class="line">				System.out.println(&quot;添加子节点:&quot;+event.getData().getPath());</div><div class="line">				System.out.println(&quot;修改子节点数据:&quot;+new String(event.getData().getData()));</div><div class="line">			&#125;else if(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED))&#123;</div><div class="line">				System.out.println(&quot;删除子节点:&quot;+event.getData().getPath());</div><div class="line">			&#125;else if(event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))&#123;</div><div class="line">				System.out.println(&quot;修改子节点数据:&quot;+event.getData().getPath());</div><div class="line">				System.out.println(&quot;修改子节点数据:&quot;+new String(event.getData().getData()));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">PathChildrenCache.StartMode	有:</div><div class="line">BUILD_INITIAL_CACHE //同࠵初始化客户端的cache，及创建cache后，就从服务器端拉入对应的数据</div><div class="line">NORMAL //异࠵初始化cache</div><div class="line">POST_INITIALIZED_EVENT //异࠵初始化，初始化完成触发事件PathChildrenCacheEvent.Type.INITIALIZED</div><div class="line">*/</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper开源客户端/" data-id="cj290scnl01chssqq52d1k1xr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/zookeeper客户端连接的原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/zookeeper客户端连接的原理/" class="article-date">
  <time datetime="2017-04-16T04:47:25.341Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/zookeeper客户端连接的原理/">zookeeper客户端连接的原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>创建zookeeper连接对象时，如何选择哪个服务器进行连接？</p>
<ul>
<li>客户端的connectstring:localhost:2181, localhost:2182, localhost:2183</li>
<li>通过类:org.apache.zookeeper.client. StaticHostProvider维护地址列表</li>
<li>通过解析connectstring,进行随机排序,形成最终的地址列表</li>
<li>每次从形成地址列表中选择第一个地址进行连接,如果连接不上再选择第一个地址</li>
<li>如果当前节点是列表的最后一个节点,则再重新选择第一个节点,相当于一个环</li>
<li>通过随机排序,每个zk的客户端就会随机的去连接zk服务器,分布相对均匀</li>
</ul>
<p>举例:</p>
<p>connectstring为:192.168.1.2:2181, 192.168.1.3:2181, 192.168.1.4:2181<br>随机打乱后的顺序为:192.168.1.3:2181, 192.168.1.2:2181, 192.168.1.4:2181<br>则第一次连接时选择1.3这个节点,如果连接不上,则重新选择1.2, 然后是1.4,如果1.4连接不上,则开始连接第一个节点1.3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">在StaticHostProvider类中,有如下的两个方法:</div><div class="line">初始化连接地址列表</div><div class="line">*/</div><div class="line"></div><div class="line">public StaticHostProvider(Collection&lt;InetSocketAddress&gt; serverAddresses)</div><div class="line">        throws UnknownHostException &#123;</div><div class="line">    for (InetSocketAddress address : serverAddresses) &#123;</div><div class="line">        InetAddress ia = address.getAddress();</div><div class="line">        InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():</div><div class="line">            address.getHostName());</div><div class="line">        for (InetAddress resolvedAddress : resolvedAddresses) &#123;</div><div class="line">           </div><div class="line">            if (resolvedAddress.toString().startsWith(&quot;/&quot;) </div><div class="line">                    &amp;&amp; resolvedAddress.getAddress() != null) &#123;</div><div class="line">                this.serverAddresses.add(</div><div class="line">                        new InetSocketAddress(InetAddress.getByAddress(</div><div class="line">                                address.getHostName(),</div><div class="line">                                resolvedAddress.getAddress()), </div><div class="line">                                address.getPort()));</div><div class="line">            &#125; else &#123;</div><div class="line">                this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));</div><div class="line">            &#125;  </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (this.serverAddresses.isEmpty()) &#123;</div><div class="line">        throw new IllegalArgumentException(</div><div class="line">                &quot;A HostProvider may not be empty!&quot;);</div><div class="line">    &#125;</div><div class="line">    Collections.shuffle(this.serverAddresses);	//随机排序</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">------选择一个地址返回--------------</div><div class="line"></div><div class="line">public InetSocketAddress next(long spinDelay) &#123;</div><div class="line">    ++currentIndex;</div><div class="line">	//如果已经是最后一个节点,则从第一个节点开始</div><div class="line">    if (currentIndex == serverAddresses.size()) &#123;</div><div class="line">        currentIndex = 0;</div><div class="line">    &#125;</div><div class="line">	//当地址列表只有一个地址时,再次获取之前先sleep一定时间再返回,这算是一个重试时间间隔</div><div class="line">    if (currentIndex == lastIndex &amp;&amp; spinDelay &gt; 0) &#123;</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(spinDelay);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            LOG.warn(&quot;Unexpected exception&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125; else if (lastIndex == -1) &#123;</div><div class="line">        // We don&apos;t want to sleep on the first ever connect attempt.</div><div class="line">        lastIndex = 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return serverAddresses.get(currentIndex);//返回下一个节点的地址</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/zookeeper客户端连接的原理/" data-id="cj290scnc01cassqqfld9fp5o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/35/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="page-number" href="/page/35/">35</a><span class="page-number current">36</span><a class="page-number" href="/page/37/">37</a><a class="page-number" href="/page/38/">38</a><span class="space">&hellip;</span><a class="page-number" href="/page/58/">58</a><a class="extend next" rel="next" href="/page/37/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IDEA/">IDEA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NFS/">NFS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tachyon/">Tachyon</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/azkaban/">azkaban</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/echarts/">echarts</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hbase/">hbase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hive/">hive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/inotify/">inotify</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/logstash/">logstash</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rsync/">rsync</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/socket/">socket</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sqoop/">sqoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storm/">storm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux基础命令/">Linux基础命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux重要配置文件/">Linux重要配置文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NFS/">NFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/azkaban/">azkaban</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echarts/">echarts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hbase/">hbase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inotify/">inotify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logstash/">logstash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mapreduce/">mapreduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcached/">memcached</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rpc/">rpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rsync/">rsync</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala/">scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala函数式编程/">scala函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala编程/">scala编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqoop/">sqoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storm/">storm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Linux基础命令/" style="font-size: 19.52px;">Linux基础命令</a> <a href="/tags/Linux重要配置文件/" style="font-size: 14.76px;">Linux重要配置文件</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/NIO/" style="font-size: 11.43px;">NIO</a> <a href="/tags/azkaban/" style="font-size: 10.48px;">azkaban</a> <a href="/tags/echarts/" style="font-size: 10.95px;">echarts</a> <a href="/tags/flume/" style="font-size: 10.95px;">flume</a> <a href="/tags/hadoop/" style="font-size: 18.57px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 13.33px;">hbase</a> <a href="/tags/hive/" style="font-size: 18.1px;">hive</a> <a href="/tags/inotify/" style="font-size: 10px;">inotify</a> <a href="/tags/java/" style="font-size: 12.38px;">java</a> <a href="/tags/kafka/" style="font-size: 12.86px;">kafka</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/logstash/" style="font-size: 10.48px;">logstash</a> <a href="/tags/mapreduce/" style="font-size: 16.67px;">mapreduce</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/memcached/" style="font-size: 13.81px;">memcached</a> <a href="/tags/mongodb/" style="font-size: 14.76px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 17.14px;">mysql</a> <a href="/tags/netty/" style="font-size: 10.95px;">netty</a> <a href="/tags/nginx/" style="font-size: 14.29px;">nginx</a> <a href="/tags/project/" style="font-size: 10.48px;">project</a> <a href="/tags/python/" style="font-size: 19.05px;">python</a> <a href="/tags/redis/" style="font-size: 17.14px;">redis</a> <a href="/tags/rpc/" style="font-size: 10.48px;">rpc</a> <a href="/tags/rsync/" style="font-size: 10px;">rsync</a> <a href="/tags/scala/" style="font-size: 17.62px;">scala</a> <a href="/tags/scala函数式编程/" style="font-size: 11.9px;">scala函数式编程</a> <a href="/tags/scala编程/" style="font-size: 15.71px;">scala编程</a> <a href="/tags/shell/" style="font-size: 17.62px;">shell</a> <a href="/tags/socket/" style="font-size: 11.9px;">socket</a> <a href="/tags/spark/" style="font-size: 20px;">spark</a> <a href="/tags/sqoop/" style="font-size: 10.95px;">sqoop</a> <a href="/tags/storm/" style="font-size: 15.24px;">storm</a> <a href="/tags/zookeeper/" style="font-size: 16.19px;">zookeeper</a> <a href="/tags/数据仓库/" style="font-size: 11.43px;">数据仓库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/02/bigdata/spark从入门到精通_笔记/Tachyon/">Tachyon</a>
          </li>
        
          <li>
            <a href="/2017/04/30/数据仓库/数据仓库2/">数据仓库</a>
          </li>
        
          <li>
            <a href="/2017/04/29/IDEA/IDEA/">IDEA</a>
          </li>
        
          <li>
            <a href="/2017/04/29/数据仓库/ETL/">ETL</a>
          </li>
        
          <li>
            <a href="/2017/04/28/数据仓库/PowderDesigner/">PowderDesigner的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Mr. Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>