<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Chen&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个技术渣的自说自话">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen's Blog">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="Chen's Blog">
<meta property="og:description" content="一个技术渣的自说自话">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen's Blog">
<meta name="twitter:description" content="一个技术渣的自说自话">
  
    <link rel="alternate" href="/atom.xml" title="Chen&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chen&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个技术渣的自说自话</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-scala编程/Scala简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/Scala简介/" class="article-date">
  <time datetime="2017-04-16T04:47:25.889Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/Scala简介/">第一章 scala简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本书的所有例子能在scala 版本的2.7.2下面编译通过</p>
<h1 id="1-函数式编程"><a href="#1-函数式编程" class="headerlink" title="1.函数式编程"></a>1.函数式编程</h1><p>&emsp;Eric Raymond 把大教堂和集市作为软件开发的两个隐喻,大教堂是几乎近于完美的建筑物,要花很长的时间建设,而一旦建成了就长时间保持不变,相对来说,集市则天天在被工作在其中的人调整和扩展<br>Raymond 的文章中,集市是对于开源软件开发的隐喻, Scala更像是一个集市而不是大教堂,因为他被设计为可以让使用它的人扩展和修改,Scala并没有提供那种”完美齐全”语言中可能需要的所有的东西,而是把制作这些东西的工具放在了你的手中</p>
<p>&emsp;Scala是纯粹的面向对象语言,每个值都是对象,每个操作都是方法,例如:如果使用Scala描述:1+2 ,实际上等于条用定义在Int类里的+方法,方法名可以用像操作符一样的名字定义,以便于API的使用者像使用操作符那样使用方法</p>
<p>&emsp;Scala还是一种成熟的函数式语言,函数式编程有两种指导理念,第一种理念是函数是头等值,在函数式语言中,函数也是值,与整数或字符串处于同一个地位,函数可以被当做参数传递给其他函数,可以当做结果从函数中返回或保存在变量里,可以在函数里定义其他函数,就好像在函数里定义整数一样,还可以定义匿名函数,并随意的插入到代码的任何地方,就好像使用43这样的整数字面量一样<br>函数式编程的第二种理念是程序的操作应该把输入值映射为输出值而不是就地修改数据,在Java和scala里,字符串是一种数学意义上的额字符序列,使用s.replace(‘:’, ‘.’) 这样的表达式替换字符串里的字符会产生一个新的,不同于原字符串s的对象,换句话说就是Java里字符串是不可变的而在一些其他的语言中是可变的,因此单就字符串来说,Java是函数式的语言,不可变数据结构是函数式语言的一块基石,Scala库在Java API之上定义了更多的不可变数据类型,例如:Scala有不可变的列表 , 元组, 映射表, 和集</p>
<p>&emsp;函数式编程第二种理念的另一种解释是,方法不应该有任何的副作用,方法与其所在的环境交流的唯一方式应该是获得参数和返回结果,比如Java里String类的replace方法就是符合这种说法,他的参数包含一个字符串和两个字符串,返回的是一个新的字符串,其中的指定字符串都替换成了另一个,调用replace不会有其他的结果,类似于replace这样的方法被称为  指称透明 , 就是说对于任何输入来讲,都可以用方法的结果替代对他的调用,而不影响程序的语义</p>
<h1 id="2-Why-Scala"><a href="#2-Why-Scala" class="headerlink" title="2.Why Scala?"></a>2.Why Scala?</h1><ol>
<li><p>Scala是兼容的<br>&emsp;scala不需要你脱离Java平台重新学习开发,他可以让你保全现存的代码并添加新东西因为他被设计成可以与Java实施无缝的互操作,Scala程序会被编译成JVM的字节码,其运行时的性能通常与Java程序不分上下,scala代码可以调用Java方法,访问Java字段,继承Java类和实现Java接口,这些都不需要特别的语法,外部接口描述或胶水代码,实际上,程序员们根本都没有意识到,几乎所有Scala代码都大量使用了Java库代码与Java的全交互操作性的另一个方面是Scala大量重用了Java类型,Scala的Int类型代表了Java的原始整数类型Int,Float代表了float等等,Scala不仅重用了Java的类型,而且还把他们打扮得更好看,如Scala的字符串类似于toInt 和toFloat的方法,可以把字符串转换成整数或浮点数,因此可以用str.toInt 代替 Integer.parseInt(str) 方法,不过他在不打破互操作性的基础上是怎么做到这点的呢?Java的String类可没有toInt方法,实际上,Scala有一个通用方案可以解决这种高级库设计和互操作性相对立的问题,Scala允许定义类型失配或者选用不存在的方法时使用隐式转换,在上面的例子里,当在字符串中寻找toInt方法时,Scala编译器会发现String类里没有这种方法,但他会发现Java的String对象转换为Scala的RichString 类实例的隐式转换,而RichString类中定义了这么个方法,于是在执行toInt操作之前,转换被隐式应用了</p>
</li>
<li><p>Scala是简洁的<br>有一种极端的例子是,Scala的代码可以减少到Java的1/10,较为保守的估计大概标准的Scala程序代码行在Java里写的同样程序的一般左右,更少的行数不仅意味着打更少的字,同样意味着更少的对程序的阅读和理解,以及更少出错的机会,如:Java和scala的构造函数的对比就可以看出来了</p>
</li>
</ol>
<ol>
<li><p>scala是高级的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#java 写法</div><div class="line">boolean nameHasUpperCase = false;</div><div class="line">for (int i=0; i&lt;name.length(); i++)&#123;</div><div class="line">    if(Character.isUpperCase(name.charAt(i)))&#123;</div><div class="line">        nameHasUpperCase = true;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#scala写法</div><div class="line">val nameHasUpperCase = name.exists(_.isUpperCase)</div></pre></td></tr></table></figure>
</li>
<li><p>scala是静态类型的<br>&emsp;scala是以Java的内嵌类型系统为基础,允许使用泛型参数化类型,用交集组合类型及抽象类型影藏类型细节,这都为自建类型打下了坚实的基础,从而能够设计出既安全又灵活使用的接口,静态类型检查可以提供一些基础的编码上的检查,从而避免在程序运行时出错而重新排错的可能</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/Scala简介/" data-id="cj290sb93006wssqqgimt2tzu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/Scala入门初探" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/Scala入门初探/" class="article-date">
  <time datetime="2017-04-16T04:47:25.888Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/Scala入门初探/">第二章 scala入门初探</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-变量定义"><a href="#1-变量定义" class="headerlink" title="1.变量定义"></a>1.变量定义</h1><p>先写变量后写类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; val msg: java.lang.String = &quot;hello world!&quot;</div><div class="line">msg: String = hello world!</div><div class="line"></div><div class="line">//或者</div><div class="line">scala&gt; val msg: String = &quot;hello world!&quot;        #先写变量名称,再写变量类型</div><div class="line">msg: String = hello world!    #定义了一个名称为msg的变量,类型为String, 值为 &quot;hello world!&quot;</div><div class="line"></div><div class="line">scala&gt;</div></pre></td></tr></table></figure></p>
        
          <p class="article-more-link">
            <a href="/2017/04/16/scala编程/Scala入门初探/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/Scala入门初探/" data-id="cj290sb91006sssqqnfe84289" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/面向对象编程-属性和方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/python/面向对象编程-属性和方法/" class="article-date">
  <time datetime="2017-04-16T04:47:25.885Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/python/面向对象编程-属性和方法/">面向对象编程-属性和方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="实例化步骤"><a href="#实例化步骤" class="headerlink" title="实例化步骤"></a>实例化步骤</h1><ol>
<li>调用__new__()方法创建实例</li>
<li>__new__()方法自动从object继承</li>
<li>调用<strong>init</strong>()方法对其初始化</li>
<li>__init__()方法在类中定义</li>
</ol>
<h1 id="添加类说明"><a href="#添加类说明" class="headerlink" title="添加类说明"></a>添加类说明</h1><ul>
<li>紧跟类名之后,以三引号包围的字符串</li>
<li>查看类说明<ol>
<li>类名.__doc__</li>
<li>help(类名)</li>
</ol>
</li>
</ul>
<h1 id="新式类与经典类"><a href="#新式类与经典类" class="headerlink" title="新式类与经典类"></a>新式类与经典类</h1><ul>
<li>Python 3.x版本<br>统一为新式类,不用继承object</li>
<li>区别<ol>
<li>经典类继承为深度优先</li>
<li>新式类继承为广度优先</li>
</ol>
</li>
</ul>
<h1 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h1><ul>
<li>类被实例化以后才会具有的属性</li>
<li>一般在__init__方法中创建并初始化</li>
<li>直接使用即定义:self.&lt;属性名&gt;</li>
<li>引用方法:self.&lt;属性名&gt;</li>
<li>self用来代表类的实例的</li>
<li>类外用实例名.属性名方式定义和引用</li>
<li>相同类的不同实例其实例属性是不相关的</li>
<li>一般不建议在__init__()方法之外创建和初始化实例属性</li>
<li>一般不推荐类外定义和修改,修改可以单独定义方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class TestCss:</div><div class="line">	def __init__(self):</div><div class="line">		self.a = 0</div><div class="line">		self.b = 10</div><div class="line"></div><div class="line">	def info(self):</div><div class="line">		print(&quot;a:&quot;, self.a, &quot;  b:&quot;,self.b)</div><div class="line"></div><div class="line"></div><div class="line">if ___name__ == &apos;___name__&apos;:</div><div class="line">	tc = TestCss()</div><div class="line">	tc.info()</div><div class="line">	tc.color = &quot;red&quot;    //实例属性</div><div class="line">	print(tc.color)</div><div class="line"># 可以在类外动态的添加实例属性，如上面的color就是一个动态添加的实例属性</div></pre></td></tr></table></figure>
<h1 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h1><ul>
<li>类定义后就存在,且不需要实例化</li>
<li>类属性使得相同类的不同实例共同持有相同变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class TestCss:</div><div class="line">	cssa = &quot;class-attribute&quot;</div><div class="line">	def __init__(self):</div><div class="line">		self.a = 0</div><div class="line">		self.b = 10</div><div class="line"></div><div class="line">	def info(self):</div><div class="line">		print(&quot;a:&quot;, self.a, &quot;  b:&quot;,self.b, &quot;cssa:&quot;, TestCss.cssa)</div><div class="line"></div><div class="line">	def define_a(self):</div><div class="line">		self.c = 19</div><div class="line"></div><div class="line">if __name__ == &apos;___name__&apos;:</div><div class="line">	tc = TestCss()</div><div class="line">	tc.info()</div><div class="line">	tc.color = &quot;red&quot;</div><div class="line">	print(tc.color)</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h1><ul>
<li>不提供限制属性访问的关键字(无法限制类的各种属性在类外直接访问)</li>
<li>使用__开头的变量名加以标志,只有对象自己能访问</li>
<li>使用_开头的变量名加以标志,应该只有类对象及其子类能访问(非强制性)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">class A:</div><div class="line">	def __init__(self):</div><div class="line">		self.__ab = 0</div><div class="line"></div><div class="line">	def info(self):</div><div class="line">		print(self.__ab)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">	a = A()</div><div class="line">	a.info()</div><div class="line">	a.__ab = 3</div><div class="line">	a.info()</div><div class="line">	print(a.__ab)</div><div class="line"></div><div class="line">#执行结果</div><div class="line">0</div><div class="line">0</div><div class="line">3</div><div class="line">[Finished in 0.2s]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">class A:</div><div class="line">	def __init__(self):</div><div class="line">		self._ab = 0</div><div class="line"></div><div class="line">	def info(self):</div><div class="line">		print(self._ab)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">	a = A()</div><div class="line">	a.info()</div><div class="line">	a._ab = 3</div><div class="line">	a.info()</div><div class="line">	print(a._ab)</div><div class="line"></div><div class="line">#执行结果:</div><div class="line">0</div><div class="line">3</div><div class="line">3</div><div class="line">[Finished in 0.2s]</div><div class="line"></div><div class="line">#单下划线在外部仍然是可以访问的，所以上面说是非强制性的</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h1><ul>
<li>__doc__</li>
<li>__name__</li>
<li>__dict__</li>
<li>__module__</li>
<li><p>__base__</p>
<p>可以使用dir(Student)看student类有哪些特殊属性，注意这些特殊属性是使用两个下划线开头和结束的</p>
</li>
</ul>
<h1 id="同名的类属性与实例属性"><a href="#同名的类属性与实例属性" class="headerlink" title="同名的类属性与实例属性"></a>同名的类属性与实例属性</h1><ul>
<li>以实例名.属性名引用时,优先引用实例属性</li>
<li>以类名.属性名引用时,只能引用类属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class A:</div><div class="line">...     a=0</div><div class="line">...     def __init__(self):</div><div class="line">...             self.a=10</div><div class="line">...             self.b=100</div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">&gt;&gt;&gt; a = A()</div><div class="line">&gt;&gt;&gt; a.a</div><div class="line">10</div><div class="line">&gt;&gt;&gt; A.a</div><div class="line">0</div><div class="line">&gt;&gt;&gt; A.b</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: type object &apos;A&apos; has no attribute &apos;b&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="属性访问的特殊方法-反射"><a href="#属性访问的特殊方法-反射" class="headerlink" title="属性访问的特殊方法(反射)"></a>属性访问的特殊方法(反射)</h1><ul>
<li>提供用字符串来操作类的属性/方法的方式</li>
<li>主要工具函数<ul>
<li>hasattr(obj_name, ‘属性名’)</li>
<li>setattr(obj_name, “属性名”, 值)</li>
<li>getattr(obj_name, “属性名”)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class A:</div><div class="line">...     a=0</div><div class="line">...     def __init__(self):</div><div class="line">...             self.a=10</div><div class="line">...             self.b=100</div><div class="line">...</div><div class="line"></div><div class="line">&gt;&gt;&gt; getattr(a,&quot;a&quot;)</div><div class="line">10</div><div class="line">&gt;&gt;&gt; setattr(a,&quot;a&quot;,30)</div><div class="line">&gt;&gt;&gt; hasattr(a, &quot;b&quot;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; hasattr(a, &quot;cc&quot;)</div><div class="line">False</div></pre></td></tr></table></figure>
<h1 id="属性包装"><a href="#属性包装" class="headerlink" title="属性包装"></a>属性包装</h1><ul>
<li>将方法包装成属性,以隐藏相关实例<ul>
<li>控制属性的类型或范围</li>
<li>虚拟属性(由其他属性处理后得来)</li>
</ul>
</li>
<li>三种属性操作<ul>
<li>可读:@property</li>
<li>可写:@<property-name>.setter</property-name></li>
<li>可删: @<property-name>.deleter</property-name></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Watcher:</div><div class="line">	def __init__(self, water=10,scour=2):</div><div class="line">		self._water = water</div><div class="line">		self.scour = scour</div><div class="line"></div><div class="line">	@property</div><div class="line">	def water(self):</div><div class="line">		return self._water</div><div class="line"></div><div class="line">	def set_water(self, water):</div><div class="line">		self.water = water</div><div class="line"></div><div class="line">	@water.setter</div><div class="line">	def water(self, water):</div><div class="line">		if 0&lt;water&lt;=500:</div><div class="line">			self._water = water</div><div class="line">		else:</div><div class="line">			print(&quot;set failure&quot;)</div><div class="line">#将方法装饰成为属性，在外部看来是访问属性，其实就是访问类的中的方法</div></pre></td></tr></table></figure>
<h1 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h1><ul>
<li>将实现特殊协议方法的类作为另一个类的类属性</li>
<li>用来拦截和控制属性访问并可以重复使用</li>
<li>协议方法<ul>
<li>__get__()</li>
<li>__set__()</li>
<li>__delete__()</li>
</ul>
</li>
<li>分类<ul>
<li>数据描述符(实现全部协议方法)</li>
<li>非数据描述符(实现部分协议方法)</li>
<li>说明:所有类成员函数都是非数据描述符</li>
</ul>
</li>
<li>同名的实例属性和非数据描述符(以方法为例)访问优先级</li>
<li>注意:只能在新式类中使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class NonNeg:</div><div class="line">	def __init__(self, default=0):</div><div class="line">		self.default = default</div><div class="line"></div><div class="line">	def __get__(self, instance, owner):</div><div class="line">		return self.default</div><div class="line"></div><div class="line">	def __set__(self, instance, val):</div><div class="line">		if val &gt; 0:</div><div class="line">			self.default = val</div><div class="line">		else:</div><div class="line">			print(&quot;The value must be NonNegative&quot;)</div><div class="line"></div><div class="line">class Movie:</div><div class="line">	rating = NonNeg()</div><div class="line">	score = NonNeg()</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">	m = Movie()</div><div class="line">	print(&quot;rating: &quot;, m.rating)</div><div class="line">	print(&quot;score: &quot;, m.score)</div><div class="line"></div><div class="line">	m.rating = 80        //在set的时候会将self作为隐藏的参数,传给方法</div><div class="line">	print(&quot;rating:&quot;, m.rating)</div><div class="line"></div><div class="line">	m.score = -3</div><div class="line">	print(&quot;score:&quot;, m.score)</div><div class="line"></div><div class="line">#打印结果:</div><div class="line">rating:  0</div><div class="line">score:  0</div><div class="line">rating: 80</div><div class="line">The value must be NonNegative</div><div class="line">score: 0</div><div class="line">[Finished in 0.3s]</div></pre></td></tr></table></figure>
</li>
</ul>
<p>__call__()让类的实例如函数一样可调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Test:</div><div class="line">...     def __call__(self):</div><div class="line">...             print(&quot;call.....&quot;)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; t = Test()  //相当于将__call__返回返回了</div><div class="line">&gt;&gt;&gt; t()        //调用方法</div><div class="line">call.....</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h1 id="类方法-静态方法"><a href="#类方法-静态方法" class="headerlink" title="类方法,静态方法"></a>类方法,静态方法</h1><ul>
<li>静态方法<ul>
<li>定义方法<ul>
<li>@staticmethod装饰,参数不用self</li>
</ul>
</li>
<li>访问特性<ul>
<li>不能引用或访问实例属性,可以通过了类,类变量访问属性</li>
</ul>
</li>
<li>调用方法<ul>
<li>可以用类,类实例调用</li>
</ul>
</li>
<li>本质<ul>
<li>在类中的一个普通函数而已,使面向对象程序中函数归属于类,易于代码管理</li>
</ul>
</li>
<li>用法<ul>
<li>与类相关,但不依赖或改变类与实例</li>
<li>创建不同的实例</li>
<li>把类相关工具方法放入类中</li>
</ul>
</li>
</ul>
</li>
<li>类方法<ul>
<li>定义方法<ul>
<li>@classmethod,必须提供参数cls<br>*访问特性</li>
<li>不能引用或访问实例属性</li>
</ul>
</li>
<li>调用方法<ul>
<li>可以用类,类实例调用</li>
</ul>
</li>
<li>继承特性<ul>
<li>继承时,传入的类变量cls是子类,而非父类</li>
</ul>
</li>
<li>用途<ul>
<li>与类相关,但不依赖或改变类的实例</li>
<li>工厂方法,创建类实例,完成有关预处理</li>
<li>在类内调用静态方法时不能硬编码类名</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Watcher(object):</div><div class="line">	&quot;&quot;&quot;docstring for Watcher&quot;&quot;&quot;</div><div class="line">	def __init__(self,water=10, scour=2):</div><div class="line">		super(Watcher, self).__init__()</div><div class="line">		self._water = water</div><div class="line">		self.scour = scour</div><div class="line">		self.year = 2010</div><div class="line"></div><div class="line"></div><div class="line">	@staticmethod</div><div class="line">	def spins_ml(spins):</div><div class="line">		print(&quot;company: &quot;, Watcher.company)</div><div class="line">		print(&quot;year: &quot;, self.year)</div><div class="line">		return spins * 0.4</div><div class="line"></div><div class="line">	@classmethod</div><div class="line">	def get_water(cls, watter, scour)://cls 是指代的实例对象</div><div class="line">		return cls(water,cls.spins_ml(scour))</div><div class="line"></div><div class="line">	@property </div><div class="line">	def water():</div><div class="line">		return self._water</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">	print(Watcher.spins_ml(8))</div><div class="line">	w = Watcher()</div><div class="line">	print(w.spins_ml(8))</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/python/面向对象编程-属性和方法/" data-id="cj290sb8z006pssqqx9f7xsb2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/用图片解释：进程（process）和线程（thread）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/python/用图片解释：进程（process）和线程（thread）/" class="article-date">
  <time datetime="2017-04-16T04:47:25.884Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/python/用图片解释：进程（process）和线程（thread）/">用图片解释：进程（process）和线程（thread)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自:<br><a href="http://blog.csdn.net/dbanote/article/details/8857825" target="_blank" rel="external">用图片解释：进程（process）和线程（thread）</a></p>
<p>进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。<br>最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。<br>1.</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/1.png" alt=""></p>
<p>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。<br>2.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/2.png" alt=""></p>
<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br>3.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/3.png" alt=""></p>
<p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。<br>4.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/4.png" alt=""></p>
<p>一个车间里，可以有很多工人。他们协同完成一个任务。<br>5.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/5.png" alt=""></p>
<p>线程就好比车间里的工人。一个进程可以包括多个线程。<br>6.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/6.png" alt=""></p>
<p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>7.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/7.png" alt=""></p>
<p>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>8.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/8.png" alt=""></p>
<p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>9.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/9.png" alt=""></p>
<p>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。<br>10.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/10.png" alt=""></p>
<p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。<br>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。<br>11.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/11.png" alt=""></p>
<p>操作系统的设计，因此可以归结为三点：<br>（1）以多进程形式，允许多个任务同时运行；<br>（2）以多线程形式，允许单个任务分成不同的部分运行；<br>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/python/用图片解释：进程（process）和线程（thread）/" data-id="cj290sb8x006lssqqkqa300m3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/Python面向对象编程指南(转)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/python/Python面向对象编程指南(转)/" class="article-date">
  <time datetime="2017-04-16T04:47:25.883Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/python/Python面向对象编程指南(转)/">Python面向对象编程指南(转)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转自:<br><a href="http://blog.csdn.net/zhoudaxia/article/details/23341261" target="_blank" rel="external">Python面向对象编程指南</a></p>
<p>　抽象是隐藏多余细节的艺术。在面向对象的概念中，抽象的直接表现形式通常为类。虽然Python是解释性语言，但是它是面向对象的，从设计之初就已经是一门面向对象的语言。Python基本上提供了面向对象编程语言的所有元素，如果你已经至少掌握了一门面向对象语言，那么利用Python进行面向对象程序设计将会相当容易。下面就来了解一下如何在Python中进行对象编程。</p>
<h1 id="1-如何定义一个类"><a href="#1-如何定义一个类" class="headerlink" title="1.如何定义一个类"></a>1.如何定义一个类</h1><p>在进行python面向对象编程之前，先来了解几个术语：类，类对象，实例对象，属性，函数和方法。<br>类是对现实世界中一些事物的封装，定义一个类可以采用下面的方式来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class className: </div><div class="line">    block</div></pre></td></tr></table></figure></p>
<p>　　注意类名后面有个冒号，在block块里面就可以定义属性和方法了。当一个类定义完之后，就产生了一个类对象。类对象支持两种操作：引用和实例化。引用操作是通过类对象去调用类中的属性或者方法，而实例化是产生出一个类对象的实例，称作实例对象。比如定义了一个people类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos;       #定义了一个属性 </div><div class="line">    #定义了一个方法 </div><div class="line">    def printName(self): </div><div class="line">        print self.name</div></pre></td></tr></table></figure>
<p> people类定义完成之后就产生了一个全局的类对象，可以通过类对象来访问类中的属性和方法了。当通过people.name（至于为什么可以直接这样访问属性后面再解释，这里只要理解类对象这个概念就行了）来访问时，people.name中的people称为类对象，这点和C++中的有所不同。当然还可以进行实例化操作，p=people( )，这样就产生了一个people的实例对象，此时也可以通过实例对象p来访问属性或者方法了(p.name).<br>　　理解了类、类对象和实例对象的区别之后，我们来了解一下Python中属性、方法和函数的区别。<br>　　在上面代码中注释的很清楚了，name是一个属性，printName( )是一个方法，与某个对象进行绑定的函数称作为方法。一般在类里面定义的函数与类对象或者实例对象绑定了，所以称作为方法；而在类外定义的函数一般没有同对象进行绑定，就称为函数。</p>
<h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h1><p>在类中我们可以定义一些属性，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos; </div><div class="line">    age = 12 </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.name,p.age</div></pre></td></tr></table></figure></p>
<p>　　定义了一个people类，里面定义了name和age属性，默认值分别为’jack’和12。在定义了类之后，就可以用来产生实例化对象了，这句p = people( )实例化了一个对象p，然后就可以通过p来读取属性了。这里的name和age都是公有的，可以直接在类外通过对象名访问，如果想定义成私有的，则需在前面加2个下划线 ‘ __’。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    __name = &apos;jack&apos; </div><div class="line">    __age = 12 </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.__name,p.__age</div></pre></td></tr></table></figure></p>
<p>这段程序运行会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last): </div><div class="line">  File &quot;C:/PycharmProjects/FirstProject/oop.py&quot;, line 6, in &lt;module&gt; </div><div class="line">    print p.__name,p.__age </div><div class="line">AttributeError: people instance has no attribute &apos;__name</div></pre></td></tr></table></figure></p>
<p>　　提示找不到该属性，因为私有属性是不能够在类外通过对象名来进行访问的。在Python中没有像C++中public和private这些关键字来区别公有属性和私有属性，它是以属性命名方式来区分，如果在属性名前面加了2个下划线’__’，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。</p>
<h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h1><p>　　在类中可以根据需要定义一些方法，定义方法采用def关键字，在类中定义的方法至少会有一个参数，，一般以名为’self’的变量作为该参数（用其他名称也可以），而且需要作为第一个参数。下面看个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    __name = &apos;jack&apos; </div><div class="line">    __age = 12 </div><div class="line"> </div><div class="line">    def getName(self): </div><div class="line">        return self.__name </div><div class="line">    def getAge(self): </div><div class="line">        return self.__age </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.getName(),p.getAge()</div></pre></td></tr></table></figure></p>
<p>　　如果对self不好理解的话，可以把它当做C++中类里面的this指针一样理解，就是对象自身的意思，在用某个对象调用该方法时，就将该对象作为第一个参数传递给self。</p>
<h1 id="4-类中内置的方法"><a href="#4-类中内置的方法" class="headerlink" title="4.类中内置的方法"></a>4.类中内置的方法</h1><p>　　在Python中有一些内置的方法，这些方法命名都有比较特殊的地方（其方法名以2个下划线开始然后以2个下划线结束）。类中最常用的就是构造方法和析构方法。<br>　　构造方法<strong>init</strong>(self,….)：在生成对象时调用，可以用来进行一些初始化操作，不需要显示去调用，系统会默认去执行。构造方法支持重载，如果用户自己没有重新定义构造方法，系统就自动执行默认的构造方法。<br>　　析构方法<strong>del</strong>(self)：在释放对象时调用，支持重载，可以在里面进行一些释放资源的操作，不需要显示调用。<br>　　还有其他的一些内置方法，比如 <strong>cmp</strong>( ), <strong>len( )</strong>等。下面是常用的内置方法：</p>
<table>
<thead>
<tr>
<th>内置方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>init</strong>(self,…)</td>
<td>初始化对象，在创建新对象时调用</td>
</tr>
<tr>
<td><strong>del</strong>(self)</td>
<td>释放对象，在对象被删除之前调用</td>
</tr>
<tr>
<td><strong>new</strong>(cls,<em>args,*</em>kwd)</td>
<td>实例的生成操作</td>
</tr>
<tr>
<td><strong>str</strong>(self)</td>
<td>在使用print语句时被调用</td>
</tr>
<tr>
<td><strong>getitem</strong>(self,key)</td>
<td>获取序列的索引key对应的值，等价于seq[key]</td>
</tr>
<tr>
<td><strong>len</strong>(self)</td>
<td>在调用内联函数len()时被调用</td>
</tr>
<tr>
<td><strong>cmp</strong>(stc,dst)</td>
<td>比较两个对象src和dst</td>
</tr>
<tr>
<td><strong>getattr</strong>(s,name)</td>
<td>获取属性的值</td>
</tr>
<tr>
<td><strong>setattr</strong>(s,name,value)</td>
<td>设置属性的值</td>
</tr>
<tr>
<td><strong>delattr</strong>(s,name)</td>
<td>删除name属性</td>
</tr>
<tr>
<td><strong>getattribute</strong>()</td>
<td><strong>getattribute</strong>()功能与<strong>getattr</strong>()类似</td>
</tr>
<tr>
<td><strong>gt</strong>(self,other)</td>
<td>判断self对象是否大于other对象</td>
</tr>
<tr>
<td><strong>lt</strong>(slef,other)</td>
<td>判断self对象是否小于other对象</td>
</tr>
<tr>
<td><strong>ge</strong>(slef,other)</td>
<td>判断self对象是否大于或者等于other对象</td>
</tr>
<tr>
<td><strong>le</strong>(slef,other)</td>
<td>判断self对象是否小于或者等于other对象</td>
</tr>
<tr>
<td><strong>eq</strong>(slef,other)</td>
<td>判断self对象是否等于other对象</td>
</tr>
<tr>
<td><strong>call</strong>(self,*args)</td>
<td>把实例对象作为函数调用</td>
</tr>
</tbody>
</table>
<p>　　<strong>init</strong>():<strong>init</strong>方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的初始化。注意，这个名称的开始和结尾都是双下划线。代码例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Filename: class_init.py </div><div class="line">class Person: </div><div class="line">    def __init__(self, name): </div><div class="line">        self.name = name </div><div class="line">    def sayHi(self): </div><div class="line">        print &apos;Hello, my name is&apos;, self.name </div><div class="line"> </div><div class="line">p = Person(&apos;Swaroop&apos;) </div><div class="line">p.sayHi() </div><div class="line"> </div><div class="line">输出： </div><div class="line">Hello, my name is Swaroop</div></pre></td></tr></table></figure>
<p>　　<strong>new</strong>():<strong>new</strong>()在<strong>init</strong>()之前被调用，用于生成实例对象。利用这个方法和类属性的特性可以实现设计模式中的单例模式。单例模式是指创建唯一对象吗，单例模式设计的类只能实例化一个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Singleton(object): </div><div class="line">    __instance = None                       # 定义实例 </div><div class="line"> </div><div class="line">    def __init__(self): </div><div class="line">        pass </div><div class="line"> </div><div class="line">    def __new__(cls, *args, **kwd):         # 在__init__之前调用 </div><div class="line">        if Singleton.__instance is None:    # 生成唯一实例 </div><div class="line">            Singleton.__instance = object.__new__(cls, *args, **kwd) </div><div class="line">        return Singleton.__instance</div></pre></td></tr></table></figure></p>
<p>　　<strong>getattr</strong>()、<strong>setattr</strong>()和<strong>getattribute</strong>():当读取对象的某个属性时，python会自动调用<strong>getattr</strong>()方法。例如，fruit.color将转换为fruit.<strong>getattr</strong>(color)。当使用赋值语句对属性进行设置时，python会自动调用<strong>setattr</strong>()方法。<strong>getattribute</strong>()的功能与<strong>getattr</strong>()类似，用于获取属性的值。但是<strong>getattribute</strong>()能提供更好的控制，代码更健壮。注意，python中并不存在<strong>setattribute</strong>()方法。代码例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class Fruit(object): </div><div class="line">    def __init__(self, color=&quot;red&quot;, price=0): </div><div class="line">        self.__color = color </div><div class="line">        self.__price = price </div><div class="line"> </div><div class="line">    def __getattribute__(self, item):              # &lt;span style=&quot;font-family:宋体;font-size:12px;&quot;&gt;获取属性的方法&lt;/span&gt; </div><div class="line">        return object.__getattribute__(self, item) </div><div class="line"> </div><div class="line">    def __setattr__(self, key, value): </div><div class="line">        self.__dict__[key] = value </div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;: </div><div class="line">    fruit = Fruit(&quot;blue&quot;, 10) </div><div class="line">    print fruit.__dict__.get(&quot;_Fruit__color&quot;)    # &lt;span style=&quot;font-family:宋体;font-size:12px;&quot;&gt;获取color属性&lt;/span&gt; </div><div class="line">    fruit.__dict__[&quot;_Fruit__price&quot;] = 5 </div><div class="line">    print fruit.__dict__.get(&quot;_Fruit__price&quot;)    # &lt;span style=&quot;font-family:宋体;font-size:12px;&quot;&gt;获取price属性&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p>Python不允许实例化的类访问私有数据，但你可以使用object._className<strong>attrName访问这些私有属性。
　　</strong>getitem<strong>():如果类把某个属性定义为序列，可以使用</strong>getitem<strong>()输出序列属性中的某个元素.假设水果店中销售多钟水果，可以通过</strong>getitem__()方法获取水果店中的没种水果。代码例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class FruitShop: </div><div class="line">     def __getitem__(self, i):      # 获取水果店的水果 </div><div class="line">         return self.fruits[i]       </div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;: </div><div class="line">    shop = FruitShop() </div><div class="line">    shop.fruits = [&quot;apple&quot;, &quot;banana&quot;] </div><div class="line">    print shop[1] </div><div class="line">    for item in shop:               # 输出水果店的水果 </div><div class="line">        print item,</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">banana </div><div class="line">apple banana</div></pre></td></tr></table></figure></p>
<p>　　<strong>str</strong>():<strong>str</strong>()用于表示对象代表的含义，返回一个字符串.实现了<strong>str</strong>()方法后，可以直接使用print语句输出对象，也可以通过函数str()触发<strong>str</strong>()的执行。这样就把对象和字符串关联起来，便于某些程序的实现，可以用这个字符串来表示某个类。代码例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class Fruit:      </div><div class="line">    &apos;&apos;&apos;&apos;&apos;Fruit类&apos;&apos;&apos;               #为Fruit类定义了文档字符串 </div><div class="line">    def __str__(self):          # 定义对象的字符串表示 </div><div class="line">        return self.__doc__ </div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;: </div><div class="line">    fruit = Fruit() </div><div class="line">    print str(fruit)            # 调用内置函数str()触发__str__()方法，输出结果为:Fruit类 </div><div class="line">    print fruit                 #直接输出对象fruit,返回__str__()方法的值，输出结果为:Fruit类</div></pre></td></tr></table></figure></p>
<p>　<strong>call</strong>():在类中实现<strong>call</strong>()方法，可以在对象创建时直接返回<strong>call</strong>()的内容。使用该方法可以模拟静态方法。代码例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class Fruit: </div><div class="line">    class Growth:        # 内部类 </div><div class="line">        def __call__(self): </div><div class="line">            print &quot;grow ...&quot; </div><div class="line"> </div><div class="line">    grow = Growth()      # 调用Growth()，此时将类Growth作为函数返回,即为外部类Fruit定义方法grow(),grow()将执行__call__()内的代码 </div><div class="line">if __name__ == &apos;__main__&apos;: </div><div class="line">    fruit = Fruit() </div><div class="line">    fruit.grow()         # 输出结果：grow ... </div><div class="line">    Fruit.grow()         # 输出结果：grow ...</div></pre></td></tr></table></figure></p>
<h1 id="5-类属性、实例属性、类方法、实例方法以及静态方法"><a href="#5-类属性、实例属性、类方法、实例方法以及静态方法" class="headerlink" title="5.类属性、实例属性、类方法、实例方法以及静态方法"></a>5.类属性、实例属性、类方法、实例方法以及静态方法</h1><p>　　在了解了类基本的东西之后，下面看一下python中这几个概念的区别。<br>　　先来谈一下类属性和实例属性<br>　　在前面的例子中我们接触到的就是类属性，顾名思义，类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。对于公有的类属性，在类外可以通过类对象和实例对象访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos;  #公有的类属性 </div><div class="line">    __age = 12     #私有的类属性 </div><div class="line"> </div><div class="line">p = people() </div><div class="line"> </div><div class="line">print p.name             #正确 </div><div class="line">print people.name        #正确 </div><div class="line">print p.__age            #错误，不能在类外通过实例对象访问私有的类属性 </div><div class="line">print people.__age       #错误，不能在类外通过类对象访问私有的类属性</div></pre></td></tr></table></figure></p>
<p>　实例属性是不需要在类中显示定义的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos; </div><div class="line"> </div><div class="line">p = people() </div><div class="line">p.age =12 </div><div class="line">print p.name    #正确 </div><div class="line">print p.age     #正确 </div><div class="line"> </div><div class="line">print people.name    #正确 </div><div class="line">print people.age     #错误</div></pre></td></tr></table></figure></p>
<p>　　在类外对类对象people进行实例化之后，产生了一个实例对象p，然后p.age = 12这句给p添加了一个实例属性age，赋值为12。这个实例属性是实例对象p所特有的，注意，类对象people并不拥有它（所以不能通过类对象来访问这个age属性）。当然还可以在实例化对象的时候给age赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos; </div><div class="line"> </div><div class="line">    #__init__()是内置的构造方法，在实例化对象时自动调用 </div><div class="line">    def __init__(self,age): </div><div class="line">        self.age = age </div><div class="line"> </div><div class="line">p = people(12) </div><div class="line">print p.name    #正确 </div><div class="line">print p.age     #正确 </div><div class="line"> </div><div class="line">print people.name    #正确 </div><div class="line">print people.age     #错误</div></pre></td></tr></table></figure></p>
<p>　　如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line"> </div><div class="line">print people.country </div><div class="line">p = people() </div><div class="line">print p.country </div><div class="line">p.country = &apos;japan&apos;  </div><div class="line">print p.country      #实例属性会屏蔽掉同名的类属性 </div><div class="line">print people.country </div><div class="line">del p.country    #删除实例属性 </div><div class="line">print p.country</div></pre></td></tr></table></figure>
<p>　　下面来看一下类方法、实例方法和静态方法的区别。<br>　　类方法：是类对象所拥有的方法，需要用修饰器”@classmethod”来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以”cls”作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line">    #类方法，用classmethod来进行修饰 </div><div class="line">    @classmethod </div><div class="line">    def getCountry(cls): </div><div class="line">        return cls.country </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.getCountry()    #可以用过实例对象引用 </div><div class="line">print people.getCountry()    #可以通过类对象引用</div></pre></td></tr></table></figure></p>
<p>类方法还有一个用途就是可以对类属性进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line">    #类方法，用classmethod来进行修饰 </div><div class="line">    @classmethod </div><div class="line">    def getCountry(cls): </div><div class="line">        return cls.country </div><div class="line"> </div><div class="line">    @classmethod </div><div class="line">    def setCountry(cls,country): </div><div class="line">        cls.country = country </div><div class="line"> </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.getCountry()    #可以用过实例对象引用 </div><div class="line">print people.getCountry()    #可以通过类对象引用 </div><div class="line"> </div><div class="line">p.setCountry(&apos;japan&apos;)    </div><div class="line"> </div><div class="line">print p.getCountry()    </div><div class="line">print people.getCountry() </div><div class="line"></div><div class="line">#运行结果：</div><div class="line">china </div><div class="line">china </div><div class="line">japan </div><div class="line">japan</div></pre></td></tr></table></figure></p>
<p>　结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变。<br>　实例方法：在类中最常定义的成员方法，它至少有一个参数并且必须以实例对象作为其第一个参数，一般以名为’self’的变量作为第一个参数（当然可以以其他名称的变量作为第一个参数）。在类外实例方法只能通过实例对象去调用，不能通过其他方式去调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line">    #实例方法 </div><div class="line">    def getCountry(self): </div><div class="line">        return self.country </div><div class="line"> </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.getCountry()         #正确，可以用过实例对象引用 </div><div class="line">print people.getCountry()    #错误，不能通过类对象引用实例方法</div></pre></td></tr></table></figure></p>
<p>　静态方法：需要通过修饰器”@staticmethod”来进行修饰，静态方法不需要多定义参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line">    @staticmethod </div><div class="line">    #静态方法 </div><div class="line">    def getCountry(): </div><div class="line">        return people.country </div><div class="line"> </div><div class="line"> </div><div class="line">print people.getCountry()</div></pre></td></tr></table></figure></p>
<p>　对于类属性和实例属性，如果在类方法中引用某个属性，该属性必定是类属性，而如果在实例方法中引用某个属性（不作更改），并且存在同名的类属性，此时若实例对象有该名称的实例属性，则实例属性会屏蔽类属性，即引用的是实例属性，若实例对象没有该名称的实例属性，则引用的是类属性；如果在实例方法更改某个属性，并且存在同名的类属性，此时若实例对象有该名称的实例属性，则修改的是实例属性，若实例对象没有该名称的实例属性，则会创建一个同名称的实例属性。想要修改类属性，如果在类外，可以通过类对象修改，如果在类里面，只有在类方法中进行修改。</p>
<h1 id="6-继承和多重继承"><a href="#6-继承和多重继承" class="headerlink" title="6.继承和多重继承"></a>6.继承和多重继承</h1><p>　上面谈到了类的基本定义和使用方法，这只体现了面向对象编程的三大特点之一：封装。下面就来了解一下另外两大特征：继承和多态。<br>　在Python中，如果需要的话，可以让一个类去继承一个类，被继承的类称为父类或者超类、也可以称作基类，继承的类称为子类。并且Python支持多继承，能够让一个子类有多个父类。<br>　Python中类的继承定义基本形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#父类 </div><div class="line">class superClassName: </div><div class="line">    block </div><div class="line"> </div><div class="line">#子类 </div><div class="line">class subClassName(superClassName): </div><div class="line">    block</div></pre></td></tr></table></figure></p>
<p>　　在定义一个类的时候，可以在类名后面紧跟一对括号，在括号中指定所继承的父类，如果有多个父类，多个父类名之间用逗号隔开。以大学里的学生和老师举例，可以定义一个父类UniversityMember，然后类Student和类Teacher分别继承类UniversityMember：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class UniversityMember: </div><div class="line"> </div><div class="line">    def __init__(self,name,age): </div><div class="line">        self.name = name </div><div class="line">        self.age = age </div><div class="line"> </div><div class="line">    def getName(self): </div><div class="line">        return self.name </div><div class="line"> </div><div class="line">    def getAge(self): </div><div class="line">        return self.age </div><div class="line"> </div><div class="line">class Student(UniversityMember): </div><div class="line"> </div><div class="line">    def __init__(self,name,age,sno,mark): </div><div class="line">        UniversityMember.__init__(self,name,age)     #注意要显示调用父类构造方法，并传递参数self </div><div class="line">        self.sno = sno </div><div class="line">        self.mark = mark </div><div class="line"> </div><div class="line">    def getSno(self): </div><div class="line">        return self.sno </div><div class="line"> </div><div class="line">    def getMark(self): </div><div class="line">        return self.mark </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">class Teacher(UniversityMember): </div><div class="line"> </div><div class="line">    def __init__(self,name,age,tno,salary): </div><div class="line">        UniversityMember.__init__(self,name,age) </div><div class="line">        self.tno = tno </div><div class="line">        self.salary = salary </div><div class="line"> </div><div class="line">    def getTno(self): </div><div class="line">        return self.tno </div><div class="line"> </div><div class="line">    def getSalary(self): </div><div class="line">        return self.salary</div></pre></td></tr></table></figure>
<p>　　在大学中的每个成员都有姓名和年龄，而学生有学号和分数这2个属性，老师有教工号和工资这2个属性，从上面的代码中可以看到：<br>　　1）在Python中，如果父类和子类都重新定义了构造方法<strong>init( )</strong>，在进行子类实例化的时候，子类的构造方法不会自动调用父类的构造方法，必须在子类中显示调用。<br>　　2）如果需要在子类中调用父类的方法，需要以”父类名.方法“这种方式调用，以这种方式调用的时候，注意要传递self参数过去。<br>　　对于继承关系，子类继承了父类所有的公有属性和方法，可以在子类中通过父类名来调用，而对于私有的属性和方法，子类是不进行继承的，因此在子类中是无法通过父类名来访问的。<br>　　Python支持多重继承。对于多重继承，比如<br>　　class SubClass(SuperClass1,SuperClass2)<br>　　此时有一个问题就是如果SubClass没有重新定义构造方法，它会自动调用哪个父类的构造方法？这里记住一点：以第一个父类为中心。如果SubClass重新定义了构造方法，需要显示去调用父类的构造方法，此时调用哪个父类的构造方法由你自己决定；若SubClass没有重新定义构造方法，则只会执行第一个父类的构造方法。并且若SuperClass1和SuperClass2中有同名的方法，通过子类的实例化对象去调用该方法时调用的是第一个父类中的方法。</p>
<h1 id="7-多态"><a href="#7-多态" class="headerlink" title="7.多态"></a>7.多态</h1><p>　　多态即多种形态，在运行时确定其状态，在编译阶段无法确定其类型，这就是多态。Python中的多态和Java以及C++中的多态有点不同，Python中的变量是弱类型的，在定义时不用指明其类型，它会根据需要在运行时确定变量的类型（个人觉得这也是多态的一种体现），并且Python本身是一种解释性语言，不进行预编译，因此它就只在运行时确定其状态，故也有人说Python是一种多态语言。在Python中很多地方都可以体现多态的特性，比如内置函数len(object)，len函数不仅可以计算字符串的长度，还可以计算列表、元组等对象中的数据个数，这里在运行时通过参数类型确定其具体的计算过程，正是多态的一种体现。这有点类似于函数重载（一个编译单元中有多个同名函数，但参数不同），相当于为每种类型都定义了一个len函数。这是典型的多态表现。有些朋友提出Python不支持多态，我是完全不赞同的。<br>　　本质上，多态意味着可以对不同的对象使用同样的操作，但它们可能会以多种形态呈现出结果。len(object)函数就体现了这一点。在C++、Java、C#这种编译型语言中，由于有编译过程，因此就鲜明地分成了运行时多态和编译时多态。运行时多态是指允许父类指针或名称来引用子类对象，或对象方法，而实际调用的方法为对象的类类型方法，这就是所谓的动态绑定。编译时多态有模板或范型、方法重载（overload）、方法重写（override）等。而Python是动态语言，动态地确定类型信息恰恰体现了多态的特征。在Python中，任何不知道对象到底是什么类型，但又需要对象做点什么的时候，都会用到多态。<br>　　能够直接说明多态的两段示例代码如下：</p>
<h2 id="多态方法"><a href="#多态方法" class="headerlink" title="多态方法"></a>多态方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">_metaclass_=type # 确定使用新式类 </div><div class="line">class calculator: </div><div class="line"> </div><div class="line">    def count(self,args): </div><div class="line">        return 1 </div><div class="line"> </div><div class="line">calc=calculator() #自定义类型 </div><div class="line"> </div><div class="line">from random import choice </div><div class="line">obj=choice([&apos;hello,world&apos;,[1,2,3],calc]) #obj是随机返回的 类型不确定 </div><div class="line">print type(obj) </div><div class="line">print obj.count(&apos;a&apos;) #方法多态</div></pre></td></tr></table></figure>
<p>　　对于一个临时对象obj，它通过Python的随机函数取出来，不知道具体类型（是字符串、元组还是自定义类型），都可以调用count方法进行计算，至于count由谁（哪种类型）去做怎么去实现我们并不关心。<br>　　有一种称为”鸭子类型（duck typing）“的东西，讲的也是多态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">_metaclass_=type # 确定使用新式类 </div><div class="line">class Duck: </div><div class="line">    def quack(self):  </div><div class="line">        print &quot;Quaaaaaack!&quot; </div><div class="line">    def feathers(self):  </div><div class="line">        print &quot;The duck has white and gray feathers.&quot; </div><div class="line"> </div><div class="line">class Person: </div><div class="line">    def quack(self): </div><div class="line">        print &quot;The person imitates a duck.&quot; </div><div class="line">    def feathers(self):  </div><div class="line">        print &quot;The person takes a feather from the ground and shows it.&quot; </div><div class="line"> </div><div class="line">def in_the_forest(duck): </div><div class="line">    duck.quack() </div><div class="line">    duck.feathers() </div><div class="line"> </div><div class="line">def game(): </div><div class="line">    donald = Duck() </div><div class="line">    john = Person() </div><div class="line">    in_the_forest(donald) </div><div class="line">    in_the_forest(john) </div><div class="line"> </div><div class="line">game()</div></pre></td></tr></table></figure></p>
<p>　　就in_the_forest函数而言，参数对象是一个鸭子类型，它实现了方法多态。但是实际上我们知道，从严格的抽象来讲，Person类型和Duck完全风马牛不相及。</p>
<h2 id="多态运算符"><a href="#多态运算符" class="headerlink" title="多态运算符"></a>多态运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def add(x,y): </div><div class="line">    return x+y </div><div class="line"> </div><div class="line">print add(1,2) #输出3 </div><div class="line"> </div><div class="line">print add(&quot;hello,&quot;,&quot;world&quot;) #输出hello,world </div><div class="line"> </div><div class="line">print add(1,&quot;abc&quot;) #抛出异常 TypeError: unsupported operand type(s) for +: &apos;int&apos; and &apos;str&apos;</div></pre></td></tr></table></figure>
<p>　　上例中，显而易见，Python的加法运算符是”多态“的，理论上，我们实现的add方法支持任意支持加法的对象，但是我们不用关心两个参数x和y具体是什么类型。<br>　　Python同样支持运算符重载，实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Vector: </div><div class="line">   def __init__(self, a, b): </div><div class="line">      self.a = a </div><div class="line">      self.b = b </div><div class="line"> </div><div class="line">   def __str__(self): </div><div class="line">      return &apos;Vector (%d, %d)&apos; % (self.a, self.b) </div><div class="line"> </div><div class="line">   def __add__(self,other): </div><div class="line">      return Vector(self.a + other.a, self.b + other.b) </div><div class="line"> </div><div class="line">v1 = Vector(2,10) </div><div class="line">v2 = Vector(5,-2) </div><div class="line">print v1 + v2</div></pre></td></tr></table></figure></p>
<p>　　一两个示例代码当然不能从根本上说明多态。普遍认为面向对象最有价值最被低估的特征其实是多态。我们所理解的多态的实现和子类的虚函数地址绑定有关系，多态的效果其实和函数地址运行时动态绑定有关。在C++, Java, C#中实现多态的方式通常有重写和重载两种，从上面两段代码，我们其实可以分析得出Python中实现多态也可以变相理解为重写和重载。在Python中很多内置函数和运算符都是多态的。</p>
<p>参考文献：<br><a href="http://www.cnblogs.com/dolphin0520/archive/2013/03/29/2986924.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/archive/2013/03/29/2986924.html</a><br><a href="http://www.cnblogs.com/jeffwongishandsome/archive/2012/10/06/2713258.html" target="_blank" rel="external">http://www.cnblogs.com/jeffwongishandsome/archive/2012/10/06/2713258.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/python/Python面向对象编程指南(转)/" data-id="cj290sb5a002nssqqhz9fco27" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/python进程之进程间通讯——消息队列Queue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/python/python进程之进程间通讯——消息队列Queue/" class="article-date">
  <time datetime="2017-04-16T04:47:25.881Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/python/python进程之进程间通讯——消息队列Queue/">python进程之进程间通讯——消息队列Queue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul>
<li>Queue：是一个消息队列，队列的长度可为无限或者有限</li>
<li>用于父子进程通讯，两个没有关系的进程不能使用Queue通信</li>
<li>使用实例： from mulitprocessing import Queue</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/queue/1.png" alt=""></p>
<ul>
<li>进程之间同步：lock.acquire</li>
<li>当多个进程同时对队列写的时候需要进行同步，保证一个时刻只有一个进程对队列进行写操作</li>
</ul>
<h1 id="2-查看Queue帮助"><a href="#2-查看Queue帮助" class="headerlink" title="2.查看Queue帮助"></a>2.查看Queue帮助</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [36]: from multiprocessing import Queue</div><div class="line">In [37]: help(Queue)</div><div class="line">Help on function Queue in module multiprocessing:</div><div class="line"> </div><div class="line">Queue(maxsize=0)</div><div class="line">    Returns a queue object</div></pre></td></tr></table></figure>
<h1 id="3-Queue常用方法"><a href="#3-Queue常用方法" class="headerlink" title="3.Queue常用方法"></a>3.Queue常用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">In [38]: q = Queue()</div><div class="line"> </div><div class="line">In [39]: q.</div><div class="line">q.cancel_join_thread  </div><div class="line">q.empty               </div><div class="line">q.get                         #取出队列中的消息       </div><div class="line">q.join_thread         </div><div class="line">q.put_nowait</div><div class="line">q.close               </div><div class="line">q.full                </div><div class="line">q.get_nowait          </div><div class="line">q.put                        #向队列中放入消息     </div><div class="line">q.qsize</div></pre></td></tr></table></figure>
<h1 id="4-Queue举例"><a href="#4-Queue举例" class="headerlink" title="4.Queue举例"></a>4.Queue举例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line">from multiprocessing import Queue</div><div class="line"> </div><div class="line">Qmsg = Queue()                #创建一个队列</div><div class="line">pid = os.fork()                    #启动子进程</div><div class="line"> </div><div class="line">if pid==0:                                #说明是子进程</div><div class="line">        msg = Qmsg.get()                #从队列中获取数据</div><div class="line">        print(msg)</div><div class="line">else:                                #父进程</div><div class="line">        Qmsg.put(&quot;msg 1&quot;)                #向队列中放入数据</div><div class="line">        os.wait()                            #等待子进程退出</div><div class="line"></div><div class="line"></div><div class="line">-----------------------------------------------------------------------------------------------------------------</div><div class="line">[root@backup python]# vim queue2.py</div><div class="line"> </div><div class="line">import time</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line">from multiprocessing import Queue,Process</div><div class="line">import time</div><div class="line"> </div><div class="line">Qmsg = Queue()                                       #创建队列</div><div class="line"> </div><div class="line">def child_func(name):</div><div class="line">        print(&quot;child pid=&#123;0&#125;&quot;.format(os.getpid()))        #打印子进程的pid</div><div class="line">        msg = Qmsg.get()                                    #获取队列数据</div><div class="line">        print(&quot;name=&#123;0&#125;,msg=&#123;1&#125;&quot;.format(name,msg))</div><div class="line"> </div><div class="line">print(&quot;Main pid = &#123;0&#125;&quot;.format(os.getpid()))        #打印父进程的pid</div><div class="line"> </div><div class="line">p = Process(target=child_func,args=(&quot;chilid_1&quot;,))        #创建一个子进程，并传递参数</div><div class="line">Qmsg.put(&quot;msg_1&quot;)                                #向队列中放入数据</div><div class="line">p.start()                                            #开启进程</div><div class="line">p.join()                            #等待子进程结束</div><div class="line"> </div><div class="line">#执行                                                                                                                                                                                                          </div><div class="line">[root@backup python]# python queue2.py</div><div class="line">Main pid = 3742</div><div class="line">child pid=3744</div><div class="line">name=chilid_1,msg=msg_1</div></pre></td></tr></table></figure>
<p>将start方法换成run方法，那么child_func相当于在主进程中执行，此时并没有开一个子进程</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/queue/2.png" alt=""></p>
<h1 id="5-Lock锁的使用"><a href="#5-Lock锁的使用" class="headerlink" title="5.Lock锁的使用"></a>5.Lock锁的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">In [39]: from multiprocessing import Lock                    #导入模块</div><div class="line">In [40]: help(Lock)</div><div class="line">Help on function Lock in module multiprocessing:</div><div class="line"> </div><div class="line">Lock()</div><div class="line">    Returns a non-recursive lock object</div><div class="line"> </div><div class="line"> </div><div class="line">In [41]: l = Lock()</div><div class="line">In [43]: l.                                        #其中的方法</div><div class="line">l.acquire  l.release                         #获取锁、释放锁</div></pre></td></tr></table></figure>
<h1 id="6-解决多进程之间的互斥问题"><a href="#6-解决多进程之间的互斥问题" class="headerlink" title="6.解决多进程之间的互斥问题"></a>6.解决多进程之间的互斥问题</h1><p>加上1s的延时，则当前进程会被挂起，去执行其他的进程，所以打印的进程消息将不会有序 ，挂起之后，子进程得到锁的机会是随机的，但是在一个子进程中，因为有锁的存在，所以的能够保证一个进程中的所有的内容会一起执行，以下是解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">[root@backup python]# cat queue3.py      </div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os                                            #导入相应的模块</div><div class="line">from multiprocessing import Queue,Process,Lock</div><div class="line">import time</div><div class="line"> </div><div class="line">Qmsg = Queue()</div><div class="line">lock = Lock()</div><div class="line"> </div><div class="line"> </div><div class="line">def child_func(name):</div><div class="line">        lock.acquire()                                                    #加锁</div><div class="line"> </div><div class="line">        Qmsg.put(&quot;child_&quot;+str(name)+&quot;_msg_1:&quot;+&quot;Pid=&quot;+str(os.getpid))</div><div class="line">        time.sleep(1)</div><div class="line">        Qmsg.put(&quot;child_&quot;+str(name)+&quot;_msg_2:&quot;+&quot;Pid=&quot;+str(os.getpid))</div><div class="line"> </div><div class="line">        lock.release()                                                #释放锁，这样就能保证每一个子进程中的两次put是相邻放入到队列中的</div><div class="line"> </div><div class="line"> </div><div class="line">listp = []</div><div class="line">for i in range(10):</div><div class="line">        p = Process(target=child_func, args=(i,))                        #创建子进程</div><div class="line">        p.start()                                    #开启子进程</div><div class="line">        listp.append(p)</div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg = Qmsg.get()                                    #获取队列消息</div><div class="line">        print(msg)                                #打印</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        listp[i].join()                           #等待子进程结束</div><div class="line">-------------------------------------------------------------------------------------------------</div><div class="line">#执行结果</div><div class="line">[root@backup python]# python queue3.py</div><div class="line">child_0_msg_1:Pid=&lt;built-in function getpid&gt;                    #child_i_msg 总是在一起执行</div><div class="line">child_0_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_3_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_3_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_4_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_4_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_5_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_5_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_2_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_2_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_1_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_1_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_6_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_6_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_7_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_7_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_9_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_9_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_8_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_8_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">^CTraceback (most recent call last):</div><div class="line">  File &quot;queue3.py&quot;, line 28, in &lt;module&gt;</div><div class="line">    msg = Qmsg.get()</div><div class="line">  File &quot;/usr/lib/python2.6/multiprocessing/queues.py&quot;, line 91, in get</div><div class="line">    res = self._recv()</div><div class="line">KeyboardInterrupt</div></pre></td></tr></table></figure></p>
<h1 id="7-使用Queue实现最简单的本地CS架构"><a href="#7-使用Queue实现最简单的本地CS架构" class="headerlink" title="7.使用Queue实现最简单的本地CS架构"></a>7.使用Queue实现最简单的本地CS架构</h1><p>读取客户端输入，并将数据保存到文件中，并在Server端回显</p>
<ul>
<li>基本思路：<ol>
<li>创建小心队列</li>
<li>创建子进程</li>
<li>子进程读取输入并放到消息队列中</li>
<li>父进程读取并处理消息</li>
</ol>
</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/queue/3.png" alt=""><br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/queue/4.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/python/python进程之进程间通讯——消息队列Queue/" data-id="cj290sb8u006issqqxnp9l03h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/python进程之进程间通讯——无名管道" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/python/python进程之进程间通讯——无名管道/" class="article-date">
  <time datetime="2017-04-16T04:47:25.880Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/python/python进程之进程间通讯——无名管道/">python进程之进程间通讯——无名管道</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>管道：是一种半双工的通信机制，他一端用来读，另一端用来写，管道只能用来在具有公共祖先的两个进程之间通信，管道通信消息先进先出的原理，<font color="red">并且数据只能被读取一次，当此段数据被读取后就会被清空，管道的实质是内存的一页（page）</font></li>
<li>相关函数：os.pipe()：返回读写通道文件描述符组成的元组（read_end，write_end 读端和写端)</li>
<li><p>管道示意图<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/1.png" alt=""></p>
</li>
<li><p>管道通讯示意图：</p>
</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/2.png" alt=""></p>
<ul>
<li>公共祖先：父进程和子进程，具有相同的父进程之间</li>
<li><p>无名管道实例：<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/3.png" alt=""></p>
</li>
<li><p>使用上面的方式，我们可以处理一堆父子进程，如果我们这里有N个子进程，而且全双工通讯，那么我们如何处理呢？</p>
<ul>
<li><p>如果要全双工通信（读写同时进行），那么要创建两条管道，因为如果父子进程之间只有一个管道的话，父进程写了之后要读，那么，就会有父进程读取到的是自己写的内容，而一旦内容被读取之后，管道中的内容就没有了，子进程就不会读取到，所以就会出现错乱的情况，解决的办法就是创建两条管道，父进程在一条管道中读，在另一条管道中写，同时子进程在一条管道中写，在另一条管道中读。但是这样的解决方式也是有弊端的，就是每增加一个子进程，就会有2条管道增加，而管道的数量是有上限的。</p>
</li>
<li><p>全双工：在父进程和每一个子进程之间创建两个管道，一条管道用于写，一条管道用于读</p>
</li>
<li>弊端：当两个没有关系的进程不能实现通讯，如下：</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/4.png" alt=""></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line">import time</div><div class="line"> </div><div class="line">p = os.pipe()                    #start a pipe</div><div class="line">pid = os.fork()        #开始一个子进程</div><div class="line"> </div><div class="line">if pid == 0:#only read ,so close write end</div><div class="line">        os.close(p[1])</div><div class="line">        while True:</div><div class="line">                msg = os.read(p[0],1024)</div><div class="line">                print(msg)</div><div class="line">                if msg == &apos;q&apos;:</div><div class="line">                        os.close(p[0])</div><div class="line">                        break</div><div class="line">else:</div><div class="line">        os.close(p[0])   #only write ,so close read end</div><div class="line">        while True:</div><div class="line">                str1 = raw_input(&quot;&gt;&quot;)</div><div class="line">                os.write(p[1],str1) #write &apos;str1&apos; to p[1]</div><div class="line">                if str1 == &apos;q&apos;:</div><div class="line">                        os.close(p[1])</div><div class="line">                        os.wait()       #wait subprocess exit</div><div class="line">                        break</div><div class="line">                time.sleep(1)   #sleep 1s</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/python/python进程之进程间通讯——无名管道/" data-id="cj290sb8p006essqqbqt7fskk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/python进程之进程间通讯——命名管道" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/python/python进程之进程间通讯——命名管道/" class="article-date">
  <time datetime="2017-04-16T04:47:25.879Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/python/python进程之进程间通讯——命名管道/">python进程之进程间通讯——命名管道</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><ul>
<li>命名管道：无名管道的一个扩展，无名管道是程序运行时存在，命名管道是持久的，一旦创建，所有有权限进程都可以访问</li>
<li>命名管道是单向管道，只能以只读或只写方式打开，如果要实现双向通信，必须打开两个管道</li>
<li>命名管道创建：os.mkfifo(path) ，读写和操作文件一样</li>
<li>命名管道通信模型：</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/5.png" alt=""></p>
<ul>
<li>代码示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#process1</div><div class="line">import os</div><div class="line">p_name = &quot;pipe1&quot;</div><div class="line">os.mkfifo(p_name)  </div><div class="line">try:</div><div class="line">    fp=open(p_name,&apos;w&apos;)    #写方式打开管道</div><div class="line">except IOError:</div><div class="line">    print &quot;open %s Error&quot; % p_name</div><div class="line">else:</div><div class="line">    msg = os.write(fp, &quot;hello python&quot;)    #发送消息</div><div class="line">finally:</div><div class="line">    if (fp):</div><div class="line">        fp.close()</div><div class="line"></div><div class="line"></div><div class="line">#process2</div><div class="line">import os</div><div class="line">p_name = &quot;pipe1&quot;</div><div class="line">os.mkfifo(p_name)    #创建管道,管道相当于文件描述符,所以可以像文件一样可以用open进行读写</div><div class="line">try:</div><div class="line">    fp=open(p_name,&apos;r&apos;)    #读方式打开管道</div><div class="line">except IOError:</div><div class="line">    print &quot;open %s Error&quot; % p_name</div><div class="line">else:</div><div class="line">    msg = os.read(fp, 1024)</div><div class="line">    print msg</div><div class="line">finally:</div><div class="line">    if (fp):</div><div class="line">        fp.close()</div></pre></td></tr></table></figure>
<ul>
<li>阻塞：自行设备操作时，如果不能获得资源就会挂起进程，知道获取资源后在进行操作，被挂起的进程进入休眠状态</li>
<li>非阻塞：执行设备操作时，如果不能获取资源直接返回，可以使用轮询的方式进行设备操作</li>
<li>一个管道可以多个进程打开，是否安全</li>
</ul>
<h1 id="2-os-access测试路径的访问权"><a href="#2-os-access测试路径的访问权" class="headerlink" title="2.os.access测试路径的访问权"></a>2.os.access测试路径的访问权</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">os.access(path, mode)</div><div class="line"> </div><div class="line">使用实际的uid和gid去测试路径的访问权。实际的uid和gid指的是用户登录到系统使用的uid和当前用户所在的gid，这和有效用户id和有效组id是有区别的，有效用户id和有效组id是对应于进程的。</div><div class="line"> </div><div class="line">mode参数指定测试路径的方式：</div><div class="line"> </div><div class="line">os.F_OK - 测试路径是否存在</div><div class="line"> </div><div class="line">os.R_OK - 测试文件是否可读</div><div class="line"> </div><div class="line">os.W_OK - 测试文件是否可写</div><div class="line"> </div><div class="line">os.X_OK - 测试文件是否可执行</div><div class="line"> </div><div class="line">其中的R_OK，W_OK，X_OK是可以使用OR操作合起来进行一起测试的。</div><div class="line"> </div><div class="line">#函数返回True如果测试成功，否则返回False。在系统的C API中可以使用access系统调用。</div></pre></td></tr></table></figure>
<h1 id="3-创建pipe，读写举例（以系统的open）"><a href="#3-创建pipe，读写举例（以系统的open）" class="headerlink" title="3.创建pipe，读写举例（以系统的open）"></a>3.创建pipe，读写举例（以系统的open）</h1><p> 如果进程以只读方式打开管道，那么会阻塞，直到有进程以只写方式打开管道为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">#写</div><div class="line">[root@backup python]# cat pipe_w.py</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os                    </div><div class="line"> </div><div class="line">p_name = &quot;./pipe&quot;                        #管道名称</div><div class="line">if os.access(p_name,os.F_OK)==False:                #判断路径是否存在        </div><div class="line">        os.mkfifo(p_name)                            #创建有名管道</div><div class="line"> </div><div class="line">print(&quot;before open&quot;)</div><div class="line"> </div><div class="line">fp_w = open(p_name,&apos;w&apos;)                        #以只写的方式打开一个管道文件，返回管道对象</div><div class="line"> </div><div class="line">print(&quot;end open&quot;)</div><div class="line"> </div><div class="line">msg = &quot;&quot;</div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg1 = raw_input(&quot;&gt;&quot;)</div><div class="line">        fp_w.write(msg1)                            #向管道中写入数据</div><div class="line">        fp_w.flush()                                #刷新缓存数据到管道中，因为使用的是系统的open函数打开的管道，所以相当于是C的方法，而C中是有缓存存在的</div><div class="line">        if msg1==&apos;q&apos;:</div><div class="line">                break</div><div class="line"> </div><div class="line">fp_w.close()</div><div class="line"></div><div class="line"></div><div class="line">---------------------------------------------</div><div class="line">#读</div><div class="line">[root@backup python]# cat pipe_r.py</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line"> </div><div class="line">p_name = &quot;./pipe&quot;</div><div class="line">if os.access(p_name,os.F_OK)==False:</div><div class="line">        os.mkfifo(p_name)                                        </div><div class="line"> </div><div class="line">print(&quot;before open&quot;)</div><div class="line"> </div><div class="line">fp_r = open(p_name,&apos;r&apos;)                # 其实open打开的虽然是管道，但是他相当于一个文件一样，用ls可以在本地看到</div><div class="line"> </div><div class="line">print(&quot;end open&quot;)</div><div class="line"> </div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg = fp_r.read(1)                            #每次读取一个字节</div><div class="line">        print(msg)</div><div class="line">        if msg == &apos;q&apos;:</div><div class="line">                break</div><div class="line">fp_r.close()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@backup python]# ll</div><div class="line">#os.mkfifo(p_name)    ，会生成一个pipe的文件</div><div class="line">prw-r--r-- 1 root root    0 10月  5 16:30 pipe</div></pre></td></tr></table></figure>
<h1 id="4-os-open-read-write简绍"><a href="#4-os-open-read-write简绍" class="headerlink" title="4.os.open/read/write简绍"></a>4.os.open/read/write简绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">In [1]: import os</div><div class="line"> </div><div class="line">In [2]: help(os.open)</div><div class="line">Help on built-in function open in module posix:</div><div class="line"> </div><div class="line">open(...)</div><div class="line">    open(filename, flag [, mode=0777]) -&gt; fd                            #返回fd，即文件描述符</div><div class="line"> </div><div class="line">    Open a file (for low level IO).</div><div class="line"> </div><div class="line">#flag 有以下方式：如  os.O_WRONLY(读写)    os.O_RDONLY（只读）    os.O_WRONLY （只写）</div><div class="line">In [3]: os.O_</div><div class="line">os.O_APPEND     os.O_DIRECT     os.O_EXCL       os.O_NOATIME    os.O_NONBLOCK   os.O_RSYNC      os.O_WRONLY    </div><div class="line">os.O_ASYNC      os.O_DIRECTORY  os.O_LARGEFILE  os.O_NOCTTY     os.O_RDONLY     os.O_SYNC      </div><div class="line">os.O_CREAT      os.O_DSYNC      os.O_NDELAY     os.O_NOFOLLOW   os.O_RDWR       os.O_TRUNC     </div><div class="line"> </div><div class="line">#read</div><div class="line">In [3]: help(os.read)</div><div class="line">Help on built-in function read in module posix:</div><div class="line"> </div><div class="line">read(...)</div><div class="line">    read(fd, buffersize) -&gt; string</div><div class="line"> </div><div class="line">    Read a file descriptor.            #读文件描述符</div><div class="line"> </div><div class="line"> </div><div class="line">#write </div><div class="line">In [4]: help(os.write)</div><div class="line">Help on built-in function write in module posix:</div><div class="line"> </div><div class="line">write(...)</div><div class="line">    write(fd, string) -&gt; byteswritten</div><div class="line"> </div><div class="line">    Write a string to a file descriptor.    #写string 到文件描述符</div><div class="line"> </div><div class="line">#close</div><div class="line">In [5]: help(os.close)</div><div class="line">Help on built-in function close in module posix:</div><div class="line"> </div><div class="line">close(...)</div><div class="line">    close(fd)</div><div class="line"> </div><div class="line">    Close a file descriptor (for low level IO).        #关闭一个文件描述符</div></pre></td></tr></table></figure>
<h1 id="5-创建pipe，读写举例（以os模块的open）"><a href="#5-创建pipe，读写举例（以os模块的open）" class="headerlink" title="5.创建pipe，读写举例（以os模块的open）"></a>5.创建pipe，读写举例（以os模块的open）</h1><p>使用os.open的方式打开，返回的是一个文件描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">#写</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line"> </div><div class="line">p_name = &quot;./pipe&quot;</div><div class="line">if os.access(p_name,os.F_OK)==False:</div><div class="line">        os.mkfifo(p_name)                    #没有就创建管道</div><div class="line"> </div><div class="line">print(&quot;before open&quot;)</div><div class="line"> </div><div class="line">fp_w = os.open(p_name, os.O_WRONLY)            #os.open返回一个文件描述符</div><div class="line"> </div><div class="line">print(&quot;end open&quot;)</div><div class="line"> </div><div class="line">msg = &quot;&quot;</div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg1 = raw_input(&quot;&gt;&quot;)</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        #fp_w.write(msg1)                        #如果使用的是os.open就不用刷新，os中并没有缓冲的存在，而是直接读取的。所以是写端写多少，在读端读多少</div><div class="line">        #fp_w.flush()</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        os.write(fp_name,msg1)                   #向文件描述符中写</div><div class="line">        if msg1==&apos;q&apos;:</div><div class="line">                break</div><div class="line"> </div><div class="line"> </div><div class="line">os.close(fp_w)                            #关闭文件描述符</div><div class="line"></div><div class="line"></div><div class="line">---------------------------------------------------------------------</div><div class="line"></div><div class="line">#读</div><div class="line">[root@backup python]# cat pipe_os_r.py </div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line"> </div><div class="line">p_name = &quot;./pipe&quot;</div><div class="line">if os.access(p_name,os.F_OK)==False:</div><div class="line">        os.mkfifo(p_name)</div><div class="line"> </div><div class="line">print(&quot;before open&quot;)</div><div class="line"> </div><div class="line">fp_r = os.open(p_name,os.O_RDONLY)                        #打开一个文件描述符</div><div class="line"> </div><div class="line">print(&quot;end open&quot;)</div><div class="line"> </div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg = os.read(fp_r, 1024)                            #读入文件描述符中的内容</div><div class="line">        if msg == &apos;&apos;:                        #如果杀掉写端的进程，那么在读端会继续读，所以我们对读取的内容进行判断，如果为空字符串，就退出</div><div class="line">                break</div><div class="line">        print(msg)</div><div class="line">        if msg == &apos;q&apos;:</div><div class="line">                break</div><div class="line"> </div><div class="line">     </div><div class="line">os.close(fp_r)                                    #关闭文件描述符</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/python/python进程之进程间通讯——命名管道/" data-id="cj290sb8n006bssqqaymb2wng" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/python进程之进程间通讯——共享内存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/python/python进程之进程间通讯——共享内存/" class="article-date">
  <time datetime="2017-04-16T04:47:25.878Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/python/python进程之进程间通讯——共享内存/">python进程之进程间通讯——共享内存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-共享内存简介"><a href="#1-共享内存简介" class="headerlink" title="1. 共享内存简介"></a>1. 共享内存简介</h1><ul>
<li>共享内存：进程间的一种通讯方式，他允许多个进程访问相同的内存，一个进程改变其中的数据后，其他的进程都可以看到数据的变化</li>
<li><p>Linux的内存模型：</p>
<ol>
<li>每个进程的虚拟内存被分为页（page）</li>
<li>每个进程维护自己的内存地址到虚拟内存页之间的映射</li>
<li>实际的数据存在于进程的内存地址上</li>
<li>每个进程都有自己的地址空间，多个进程的映射还是可以指定相同的页</li>
</ol>
</li>
<li><p>数据可以使用Value或Array类型存储在共享内存映射中，需要导入：from multiprocessing import Process, Value, Array</p>
</li>
<li>Manger()返回的管理者，支持类型包括：list  、dict、Namespance、Lock、RLock、Semaphore、BoundedSemaphore、Condition、Event、Queue、Avalue and Array</li>
</ul>
<h1 id="2-Value-and-Array-帮助"><a href="#2-Value-and-Array-帮助" class="headerlink" title="2.Value and Array 帮助"></a>2.Value and Array 帮助</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">In [5]: from multiprocessing import Process,Value,Array                    #导入模块</div><div class="line"> </div><div class="line">In [6]: help(Value)                                                #Value</div><div class="line">Help on function Value in module multiprocessing:</div><div class="line"> </div><div class="line">Value(typecode_or_type, *args, **kwds)                            #typecode_or_type是指定数据类型，见下文</div><div class="line">    Returns a synchronized shared object</div><div class="line"> </div><div class="line"> </div><div class="line">In [7]: help(Array)                                             #Array</div><div class="line">Help on function Array in module multiprocessing:</div><div class="line"> </div><div class="line">Array(typecode_or_type, size_or_initializer, **kwds)</div><div class="line">    Returns a synchronized shared array</div></pre></td></tr></table></figure>
<h1 id="3-typecode-or-type数据类型"><a href="#3-typecode-or-type数据类型" class="headerlink" title="3.typecode_or_type数据类型"></a>3.typecode_or_type数据类型</h1><table>
<thead>
<tr>
<th>Type code</th>
<th>C Type</th>
<th>Python Type</th>
<th>Minimum size in bytes</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘b’</td>
<td>signed char</td>
<td>int</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>‘B’</td>
<td>unsigned char</td>
<td>int</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>‘u’</td>
<td>Py_UNICODE    Unicode character</td>
<td>2</td>
<td>(1)</td>
</tr>
<tr>
<td>‘h’</td>
<td>signed short</td>
<td>int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>‘H’</td>
<td>unsigned short</td>
<td>int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>‘i’</td>
<td>signed</td>
<td>int    int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>‘I’</td>
<td>unsigned</td>
<td>int    int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>‘l’</td>
<td>signed long</td>
<td>int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>‘L’</td>
<td>unsigned long</td>
<td>int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>‘q’</td>
<td>signed long long</td>
<td>int</td>
<td>8</td>
<td>(2)</td>
<td></td>
</tr>
<tr>
<td>‘Q’</td>
<td>unsigned long long</td>
<td>int</td>
<td>8</td>
<td>(2)</td>
<td></td>
</tr>
<tr>
<td>‘f’</td>
<td>float</td>
<td>float</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>‘d’</td>
<td>double</td>
<td>float</td>
<td>8</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array(&apos;l&apos;)</div><div class="line">array(&apos;u&apos;, &apos;hello \u2641&apos;)</div><div class="line">array(&apos;l&apos;, [1, 2, 3, 4, 5])</div><div class="line">array(&apos;d&apos;, [1.0, 2.0, 3.14])</div></pre></td></tr></table></figure>
<h1 id="4-Array、Value常用方法"><a href="#4-Array、Value常用方法" class="headerlink" title="4.Array、Value常用方法"></a>4.Array、Value常用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#Array</div><div class="line">In [8]: ay = Array(&apos;i&apos;, range(10))                #指定数据类型，创建Array</div><div class="line">In [9]: ay</div><div class="line">Out[9]: &lt;SynchronizedArray wrapper for &lt;multiprocessing.sharedctypes.c_long_Array_10 object at 0x96f48e4&gt;&gt;</div><div class="line">In [10]: ay.                                           #常用的方法</div><div class="line">ay.acquire                                           #加锁</div><div class="line">ay.get_lock                                          #获取锁</div><div class="line">ay.get_obj                                           #获取对象</div><div class="line">ay.release                                          #释放锁</div><div class="line"> </div><div class="line">In [10]: c = ay.get_obj()                       #获取对象      </div><div class="line">In [11]: c</div><div class="line">Out[11]: &lt;multiprocessing.sharedctypes.c_long_Array_10 at 0x96f48e4&gt;</div><div class="line">In [12]: c[:]                                            #打印对象分片</div><div class="line">Out[12]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line"> </div><div class="line"></div><div class="line">-------------------------------------------------------------------------------------</div><div class="line">#Value</div><div class="line">In [13]: value = Value(&apos;i&apos;,11)</div><div class="line">In [14]: value.</div><div class="line">value.acquire                  #加锁   </div><div class="line">value.get_lock                #获取锁</div><div class="line">value.get_obj                  #获取对象</div><div class="line">value.release                  #释放锁</div><div class="line">value.value                     #获取其中的值</div><div class="line"> </div><div class="line">In [14]: value.value              #打印值      </div><div class="line">Out[14]: 11</div></pre></td></tr></table></figure>
<h1 id="5-Value、Array举例"><a href="#5-Value、Array举例" class="headerlink" title="5.Value、Array举例"></a>5.Value、Array举例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">[root@backup python]# cat gongxiang.py</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">from multiprocessing import Process,Value,Array            #导入相应的模块</div><div class="line">import time</div><div class="line">import os</div><div class="line"> </div><div class="line">def child_func(g_value, g_array, ar):</div><div class="line">        g_value.value = ar</div><div class="line">        g_array[ar] = ar*ar</div><div class="line">        print(&quot;g_value.value=&quot;,g_value.value)</div><div class="line"> </div><div class="line">listp = []</div><div class="line"> </div><div class="line">g_value = Value(&apos;i&apos;,0)                                    #初始化共享类型</div><div class="line">g_array = Array(&apos;i&apos;,range(10))</div><div class="line"> </div><div class="line">print(&quot;init g_value=&#123;0&#125;,g_array=&#123;1&#125;&quot;.format(g_value.value,g_array[:]))</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        p = Process(target=child_func, args=(g_value,g_array,i))       #启动子进程，子进程会调用对应的函数，所有的子进程会共享g_value,g_array，因为他们会继承父进程的内存</div><div class="line">        p.start()</div><div class="line">        listp.append(p)</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        listp[i].join()                                                                #等待子进程关闭</div><div class="line"> </div><div class="line">print(&quot;end vlaue=&quot;,g_value.value)</div><div class="line">print(&quot;end array=&quot;,g_array[:])</div><div class="line"></div><div class="line">----------------------------------------------------------------------------</div><div class="line">#打印结果</div><div class="line">[root@backup python]# python gongxiang.py</div><div class="line">init g_value=0,g_array=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">(&apos;g_value.value=&apos;, 1)</div><div class="line">(&apos;g_value.value=&apos;, 0)</div><div class="line">(&apos;g_value.value=&apos;, 2)</div><div class="line">(&apos;g_value.value=&apos;, 3)</div><div class="line">(&apos;g_value.value=&apos;, 4)</div><div class="line">(&apos;g_value.value=&apos;, 5)</div><div class="line">(&apos;g_value.value=&apos;, 6)</div><div class="line">(&apos;g_value.value=&apos;, 7)</div><div class="line">(&apos;g_value.value=&apos;, 9)</div><div class="line">(&apos;g_value.value=&apos;, 8)</div><div class="line">(&apos;end vlaue=&apos;, 8)</div><div class="line">(&apos;end array=&apos;, [0, 1, 4, 9, 16, 25, 36, 49, 64, 81])</div></pre></td></tr></table></figure>
<h1 id="6-Manger查看帮助及常用方法"><a href="#6-Manger查看帮助及常用方法" class="headerlink" title="6.Manger查看帮助及常用方法"></a>6.Manger查看帮助及常用方法</h1><p>因为Value和Array中的数据类型是固定的，所以我们引入了Manger的方式来共享内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">In [20]: from multiprocessing import Manager</div><div class="line">#帮助</div><div class="line">In [22]: help(Manager)</div><div class="line">Help on function Manager in module multiprocessing:</div><div class="line"> </div><div class="line">Manager()</div><div class="line">    Returns a manager associated with a running server process</div><div class="line"> </div><div class="line">    The managers methods such as `Lock()`, `Condition()` and `Queue()`</div><div class="line">    can be used to create shared objects.</div><div class="line"></div><div class="line"></div><div class="line">#常用方法</div><div class="line">In [23]: ma = Manager() </div><div class="line">#可以获取下面的数据类型</div><div class="line">In [25]: ma.</div><div class="line">ma.Array                        #数组 </div><div class="line">ma.JoinableQueue     </div><div class="line">ma.Queue                     #队列</div><div class="line">ma.address          </div><div class="line"> ma.join              </div><div class="line">ma.start</div><div class="line">ma.BoundedSemaphore  </div><div class="line">ma.Lock              </div><div class="line">ma.RLock            </div><div class="line">ma.connect           </div><div class="line">ma.list                         #列表</div><div class="line">ma.Condition         </div><div class="line">ma.Namespace         </div><div class="line">ma.Semaphore         </div><div class="line">ma.dict                       #字典</div><div class="line">ma.register         </div><div class="line">ma.Event            </div><div class="line">ma.Pool              </div><div class="line">ma.Value             </div><div class="line">ma.get_server        </div><div class="line">ma.shutdown         </div><div class="line">  </div><div class="line">In [26]: dict = ma.dict()            #返回一个字典类型</div><div class="line"> </div><div class="line">In [27]: dict</div><div class="line">Out[27]: &lt;DictProxy object, typeid &apos;dict&apos; at 0x9795aac&gt;</div><div class="line"></div><div class="line"> </div><div class="line">In [28]: dict[&apos;name&apos;]=&apos;zhangsan&apos;            #为字典赋值</div><div class="line"></div><div class="line">In [32]: dict.values()</div><div class="line">Out[32]: [&apos;zhangsan&apos;]</div><div class="line"> </div><div class="line">In [34]: dict[&apos;name&apos;]                           #取出其中的值</div><div class="line">Out[34]: &apos;zhangsan&apos;</div></pre></td></tr></table></figure></p>
<h1 id="7-Manger举例"><a href="#7-Manger举例" class="headerlink" title="7.Manger举例"></a>7.Manger举例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">[root@backup python]# cat manager.py</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">from multiprocessing import Process,Value,Array,Manager</div><div class="line">import time</div><div class="line">import os</div><div class="line"> </div><div class="line"> </div><div class="line">def child_func(g_value,g_array,g_dict,ar):</div><div class="line">        g_value.value = ar</div><div class="line">        g_array[ar] = ar*ar</div><div class="line">        g_dict[ar] = ar+ar</div><div class="line"> </div><div class="line">listp = []</div><div class="line">g_value = Value(&apos;i&apos;,0)</div><div class="line">g_array = Array(&apos;i&apos;,range(10))</div><div class="line">manager = Manager()</div><div class="line">g_dict = manager.dict()                                                #返回一个dict类型的字典</div><div class="line"> </div><div class="line">print(&quot;init g_value=&#123;0&#125;,g_array=&#123;1&#125;,g_dict=&#123;2&#125;&quot;.format(g_value.value,g_array[:],g_dict))</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        p = Process(target=child_func, args=(g_value,g_array,g_dict,i))</div><div class="line">        p.start()</div><div class="line">        listp.append(p)</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        listp[i].join()</div><div class="line"> </div><div class="line">print(&quot;init g_value=&#123;0&#125;,g_array=&#123;1&#125;,g_dict=&#123;2&#125;&quot;.format(g_value.value,g_array[:],g_dict))</div><div class="line"></div><div class="line"></div><div class="line">-------------------------------------------------------------</div><div class="line">#执行结果</div><div class="line">[root@backup python]# python manager.py</div><div class="line">init g_value=0,g_array=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],g_dict=&#123;&#125;</div><div class="line">init g_value=8,g_array=[0, 1, 4, 9, 16, 25, 36, 49, 64, 81],g_dict=&#123;0: 0, 1: 2, 2: 4, 3: 6, 4: 8, 5: 10, 6: 12, 7: 14, 8: 16, 9: 18&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/python/python进程之进程间通讯——共享内存/" data-id="cj290sb8k0067ssqqjio3rgtz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python/python进程之进程基本概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/python/python进程之进程基本概念/" class="article-date">
  <time datetime="2017-04-16T04:47:25.876Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/python/python进程之进程基本概念/">python进程之进程基本概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>进程：存储在磁盘上的程序被读取到内存的一次执行</li>
<li>进程是一个实体，每个进程都会有自己的地址空间，内存、数据栈</li>
<li>进程之间的数据不能共享，通过进程间通讯进行交互</li>
<li>python进程机制基于系统机制实现</li>
<li>Linux进程调度：<br>  通过合理的调度，最大限度的利用处理器时间和系统资源，如果进程数大于处理器个数，某一时刻调度不到的进程会等待运行，调度程序会在这些等待运行的进程中选择一个合适的来执行。</li>
<li><p>python进程：<br>  基于系统进程实现，启动一个进程相当于启动一个python虚拟机<br>  每创建一个进程，就相当于复制一个python虚拟机</p>
</li>
<li><p>有两种方式来实现并发性，一种方式是让每个“任务”或“进程”在单独的内在空间中工作，每个都有自已的工作内存区域。不过，虽然进程可在单独的内存空间中执行，但除非这些进程在单独的处理器上执行，否则，<font color="red">实际并不是“同时”运行的。是由操作系统把处理器的时间片分配给一个进程，用完时间片后就需退出处理器等待另一个时间片的到来</font>。另一种方式是在在程序中指定多个“执行线程”，让它们在相同的内存空间中工作。这称为“多线程处理”</p>
</li>
<li><p>子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间，它们之间共享的存储空间只有代码段。</p>
</li>
<li>python程序运行的状态： <ul>
<li>运行</li>
<li>休眠</li>
<li>等待</li>
<li>僵尸进程</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/python/python进程之进程基本概念/" data-id="cj290sb8j0064ssqq9obpw585" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/58/">58</a><a class="extend next" rel="next" href="/page/11/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IDEA/">IDEA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NFS/">NFS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tachyon/">Tachyon</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/azkaban/">azkaban</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/echarts/">echarts</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hbase/">hbase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hive/">hive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/inotify/">inotify</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/logstash/">logstash</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rsync/">rsync</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/socket/">socket</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sqoop/">sqoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storm/">storm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux基础命令/">Linux基础命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux重要配置文件/">Linux重要配置文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NFS/">NFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/azkaban/">azkaban</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echarts/">echarts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hbase/">hbase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inotify/">inotify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logstash/">logstash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mapreduce/">mapreduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcached/">memcached</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rpc/">rpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rsync/">rsync</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala/">scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala函数式编程/">scala函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala编程/">scala编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqoop/">sqoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storm/">storm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Linux基础命令/" style="font-size: 19.52px;">Linux基础命令</a> <a href="/tags/Linux重要配置文件/" style="font-size: 14.76px;">Linux重要配置文件</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/NIO/" style="font-size: 11.43px;">NIO</a> <a href="/tags/azkaban/" style="font-size: 10.48px;">azkaban</a> <a href="/tags/echarts/" style="font-size: 10.95px;">echarts</a> <a href="/tags/flume/" style="font-size: 10.95px;">flume</a> <a href="/tags/hadoop/" style="font-size: 18.57px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 13.33px;">hbase</a> <a href="/tags/hive/" style="font-size: 18.1px;">hive</a> <a href="/tags/inotify/" style="font-size: 10px;">inotify</a> <a href="/tags/java/" style="font-size: 12.38px;">java</a> <a href="/tags/kafka/" style="font-size: 12.86px;">kafka</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/logstash/" style="font-size: 10.48px;">logstash</a> <a href="/tags/mapreduce/" style="font-size: 16.67px;">mapreduce</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/memcached/" style="font-size: 13.81px;">memcached</a> <a href="/tags/mongodb/" style="font-size: 14.76px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 17.14px;">mysql</a> <a href="/tags/netty/" style="font-size: 10.95px;">netty</a> <a href="/tags/nginx/" style="font-size: 14.29px;">nginx</a> <a href="/tags/project/" style="font-size: 10.48px;">project</a> <a href="/tags/python/" style="font-size: 19.05px;">python</a> <a href="/tags/redis/" style="font-size: 17.14px;">redis</a> <a href="/tags/rpc/" style="font-size: 10.48px;">rpc</a> <a href="/tags/rsync/" style="font-size: 10px;">rsync</a> <a href="/tags/scala/" style="font-size: 17.62px;">scala</a> <a href="/tags/scala函数式编程/" style="font-size: 11.9px;">scala函数式编程</a> <a href="/tags/scala编程/" style="font-size: 15.71px;">scala编程</a> <a href="/tags/shell/" style="font-size: 17.62px;">shell</a> <a href="/tags/socket/" style="font-size: 11.9px;">socket</a> <a href="/tags/spark/" style="font-size: 20px;">spark</a> <a href="/tags/sqoop/" style="font-size: 10.95px;">sqoop</a> <a href="/tags/storm/" style="font-size: 15.24px;">storm</a> <a href="/tags/zookeeper/" style="font-size: 16.19px;">zookeeper</a> <a href="/tags/数据仓库/" style="font-size: 11.43px;">数据仓库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/02/bigdata/spark从入门到精通_笔记/Tachyon/">Tachyon</a>
          </li>
        
          <li>
            <a href="/2017/04/30/数据仓库/数据仓库2/">数据仓库</a>
          </li>
        
          <li>
            <a href="/2017/04/29/IDEA/IDEA/">IDEA</a>
          </li>
        
          <li>
            <a href="/2017/04/29/数据仓库/ETL/">ETL</a>
          </li>
        
          <li>
            <a href="/2017/04/28/数据仓库/PowderDesigner/">PowderDesigner的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Mr. Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>