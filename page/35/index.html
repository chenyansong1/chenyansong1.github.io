<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Chen&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个技术渣的自说自话">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen's Blog">
<meta property="og:url" content="http://yoursite.com/page/35/index.html">
<meta property="og:site_name" content="Chen's Blog">
<meta property="og:description" content="一个技术渣的自说自话">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen's Blog">
<meta name="twitter:description" content="一个技术渣的自说自话">
  
    <link rel="alternate" href="/atom.xml" title="Chen&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chen&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个技术渣的自说自话</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-functionalProgrammingInScala/第三章 函数式数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/functionalProgrammingInScala/第三章 函数式数据结构/" class="article-date">
  <time datetime="2017-04-16T04:47:25.374Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/functionalProgrammingInScala/第三章 函数式数据结构/">第三章 函数式数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-定义函数式数据结构"><a href="#1-定义函数式数据结构" class="headerlink" title="1.定义函数式数据结构"></a>1.定义函数式数据结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package fpinscala.datastructures</div><div class="line"></div><div class="line">sealed trait List[+A]</div><div class="line">case object Nil extends List[Nothing]</div><div class="line">case class Cons[+A](head: A, tail: List[A]) extends List[A]</div><div class="line"></div><div class="line">object List&#123;</div><div class="line">  def sum(ints: List[Int]): Int = ints match &#123;</div><div class="line">    case Nil =&gt; 0</div><div class="line">    case Cons(x,xs) =&gt; x+sum(xs)</div><div class="line">  &#125;</div><div class="line">  def product(ds: List[Double]): Double = ds match &#123;</div><div class="line">    case Nil =&gt; 1.0</div><div class="line">    case Cons(0.0, _) =&gt; 0.0</div><div class="line">    case Cons(x, xs) =&gt; x*product(xs)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  def apply[A](as: A*): List[A] =</div><div class="line">    if (as.isEmpty) Nil</div><div class="line">    else Cons(as.head, apply(as.tail:_*))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;List有两种实现,或者是说构造器(每种都由case关键字引入),表示List有两种可能的形式,如上面的代码所示,List如果为空,使用数据构造器Nil表示,如果非空,使用数据构造器Cons表示,一个非空List由初始元素head和后续紧跟的也是List结构的tail组成</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/Functional_Programming_in_Scala/3/1.png" alt="单项链表" title="单项链表"></p>
<blockquote>
<p>关于型变</p>
</blockquote>
<p>&emsp;在trait List[+A]声明里,类型参数A前面的+是一个型变的符号,标志着A是协变的或正向的参数,意味着假设Dog是Animal的子类,那么List[Dog] 是List[Animal]的子类,(多数情况下,所有类型X和Y,如果X是Y的子类型,那么List[X]是List[Y]的子类型),我们可以在A的前面去掉+号,那么标记List的参数类型是非协变的<br>&emsp;注意:Nil继承List[Nothing] ,Nothing是所有类型的子类型,也就是说使用型变符号后Nil可以当成是List[Int],或List[Double]等任何List的具体类型</p>
<h1 id="2-模式匹配"><a href="#2-模式匹配" class="headerlink" title="2.模式匹配"></a>2.模式匹配</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def sum(ints: List[Int]): Int = ints match &#123;</div><div class="line">  case Nil =&gt; 0</div><div class="line">  case Cons(x,xs) =&gt; x+sum(xs)</div><div class="line">&#125;</div><div class="line">def product(ds: List[Double]): Double = ds match &#123;</div><div class="line">  case Nil =&gt; 1.0</div><div class="line">  case Cons(0.0, _) =&gt; 0.0</div><div class="line">  case Cons(x, xs) =&gt; x*product(xs)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;模式匹配有点像一个别致的switch声明,他可以侵入到表达式的数据结构内部,对这个结构进行检验和提取子表达式,他由一个表达式引入,例如ds(目标或被检验者)后边跟着一个关键字match和一个用花括号封装起来的一系列case语句,每一条case语句由=&gt;箭头左边的模式(如Cons(x,xs)) 和=&gt;箭头右边的结果(如 x*product(xs))组成,如果目标匹配其中的一种模式,他的结果就是整个match表达式的结果,如果目标与多个模式都匹配,scala选择第一个匹配的模式</p>
<blockquote>
<p>scala中的伴生对象<br>&emsp;除了经常声明数据类型和数据构造器之外,我们也经常声明伴生对象,他只是与数据类型同名的一个单例,通常在里面定义一些用于创建或处理数据类型的便捷方法,例如我们想让函数def  fill<a href="n:Int, a:A" target="_blank" rel="external">A</a>: List[A]创建一个有n个拷贝元素的List,很适合把它放在List伴生对象里,用伴生对象是scala中的一种惯例</p>
</blockquote>
<p>来看几个模式匹配的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List(1,2,3) match &#123;case _ =&gt; 42&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;结果是42,这里使用变量模式<em>,匹配任何表达式,我们可以用x或foo替代</em>,但通常使用_指示一个在匹配结果里不关心的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List(1,2,3) match &#123;case Cons(h, _) =&gt; h&#125;</div></pre></td></tr></table></figure>
<p>&emsp;结果是1,这里使用了一个数据构造器模式结合一个变量模式捕获目标的子表达式</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/Functional_Programming_in_Scala/3/2.png" alt="匹配一个List" title="匹配一个List"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List(1,2,3) match &#123;case Cons(_, t) =&gt; t&#125;</div></pre></td></tr></table></figure>
<p>&emsp;结果是List(2,3)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List(1,2,3) match &#123;case Nil =&gt; 42&#125;</div></pre></td></tr></table></figure>
<p>&emsp;结果是运行时匹配错误(Match-Error),表示没有表达式与目标匹配</p>
<p>&emsp;表达式是否符合模式匹配是由什么决定的?一个模式或许包含只能匹配常量的诸如3或”hi”这样的字面量;或能匹配任何表达式的以小写字母开头的如x,xs这样的变量;或以下划线和只能匹配相应形式的如Cons(x,xs) 和Nil这样的数据构造器,模式IDE组成可以是任意嵌套的—Cons(x1, Cons(x2, Nil))和 Cons(y1, Cons(y2, Cons(y3,_)))都是有效的模式,如果将模式中的变量分配给目标子表达式,使得他在结构上与目标一致,模式与目标就是匹配的,匹配上的话,结果表达式可以访问这些模式中定义的局部变量</p>
<p>&emsp;下面的匹配表达式结果是什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  val x = List(1,2,3,4,5) match &#123;</div><div class="line">    case Cons(x, Cons(2, Cons(4, _))) =&gt; x</div><div class="line">    case Nil =&gt; 42</div><div class="line">    case Cons(x, Cons(y, Cons(3, Cons(4, _)))) =&gt; x + y    //匹配</div><div class="line">    case Cons(h, t) =&gt; h + sum(t)</div><div class="line">    case _ =&gt; 101</div><div class="line">  &#125;</div><div class="line"></div><div class="line">//x = 3</div></pre></td></tr></table></figure>
<h1 id="3-函数式数据结构中的数据共享"><a href="#3-函数式数据结构中的数据共享" class="headerlink" title="3.函数式数据结构中的数据共享"></a>3.函数式数据结构中的数据共享</h1><p>&emsp;当数据不可变时,我们该怎么写一些例如从List中删除元素之类的函数?答案很简单,当我们对一个以存在的列表xs在前面添加一个元素1的时候,返回一个新的元素,即Cons(1, xs) ,既然列表是不可变的,我们不需要真的去复制一份xs,可以直接复用他,这也称为数据共享,共享不可变数据可以让函数实现更高的效率,我们可以返回不可变数据结构而不用担心后续代码修改他,不需要悲观的复制一份数据以避免对其修改或污染<br>&emsp;以同样的方式,删除一个列表的第一个元素,比如:myList = Cons(x, xs) ,只需要返回尾部的xs,并没有真的删除元素,原始列表myList依然可用,丝毫未受影响,我们说函数式数据结构是持久的,意味着已存在的引用不会因为数据结构的操作而改变</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/Functional_Programming_in_Scala/3/3.png" alt="数据共享" title="数据共享"></p>
<p> &emsp;练习: 实现tail函数,删除一个List的第一个函数,注意这个函数的时间开销是常量级的,如果列表是Nil,在实现的时候会有什么不同的选择?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def tail[A](l: List[A]): List[A] =</div><div class="line">  l match &#123;</div><div class="line">    case Nil =&gt; sys.error(&quot;tail of empty list&quot;)</div><div class="line">    case Cons(_,t) =&gt; t</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;练习2: 使用相同的思路,实现函数setHead用一个不同的值替代列表中的第一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def setHead[A](l: List[A], h: A): List[A] = l match &#123;</div><div class="line">  case Nil =&gt; sys.error(&quot;setHead on empty list&quot;)</div><div class="line">  case Cons(_,t) =&gt; Cons(h,t)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-1-数据共享的效率"><a href="#3-1-数据共享的效率" class="headerlink" title="3.1.数据共享的效率"></a>3.1.数据共享的效率</h2><p>&emsp;练习1:把tail泛化为drop函数,用于从列表中删除前n个元素,注意,这个函数的时间开销只需要与drop的元素个数成正比—-不需要复制整个列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def drop[A](l: List[A], n: Int): List[A] =</div><div class="line">  if (n &lt;= 0) l</div><div class="line">  else l match &#123;</div><div class="line">    case Nil =&gt; Nil</div><div class="line">    case Cons(_,t) =&gt; drop(t, n-1)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;练习2:实现dropWhile函数,删除列表中前缀全部符合判定的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def dropWhile[A](l: List[A], f: A =&gt; Boolean): List[A] =</div><div class="line">  l match &#123;</div><div class="line">    case Cons(h,t) if f(h) =&gt; dropWhile(t, f)</div><div class="line">    case _ =&gt; l</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;练习3:利用数据共享的特性将一个列表的所有元素加到另一个列表的后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def append[A](a1: List[A], a2: List[A]): List[A] = </div><div class="line">    a1 match &#123;</div><div class="line">        case Nil =&gt; a2</div><div class="line">        case Cons(h,t) =&gt; Cons(h, append(t, a2))</div><div class="line">    &#125;</div><div class="line">//这样之后的结果是:Cons(1.1, Cons(1.2, Cons(1.3, a2)    //假设a1(1.1, 1.2, 1.3)</div></pre></td></tr></table></figure></p>
<p>&emsp;这个定义只做数据复制,直到第一个列表中没有元素可用,所以他的时间和内存开销只取决于a1的长度,如果我们用两个数组实现相同的函数,被迫要复制两个数组中的所有元素到一个结果集中,这种情况下不可变链表比数组更有效率</p>
<p>&emsp;练习4:不是所有的实现都令人满意,实现一个init函数,返回一个列表,他包含源列表中除了最后一个元素之外的所有元素,比如,传入List(1,2,3,4)返回List(1,2,3),为什么这个函数不能实现同tail一样的常量级时间开销呢?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def init[A](l: List[A]): List[A] =</div><div class="line">  l match &#123;</div><div class="line">    case Nil =&gt; sys.error(&quot;init of empty list&quot;)</div><div class="line">    case Cons(_,Nil) =&gt; Nil    //去掉最后一个元素的关键步</div><div class="line">    case Cons(h,t) =&gt; Cons(h,init(t))</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;由上面知道,只有将列表的所有的元素迭代一遍之后,才能得到的结果,所以时间复杂度与列表的大小相关</p>
<h2 id="3-2-改进高阶函数的类型推导"><a href="#3-2-改进高阶函数的类型推导" class="headerlink" title="3.2.改进高阶函数的类型推导"></a>3.2.改进高阶函数的类型推导</h2><p>&emsp;高阶函数如dropWhile经常传递匿名函数,看一个典型的例子,回忆一下dropWhile的签名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def dropWhile[A](l: List[A], f: A =&gt; Boolean): List[A]</div></pre></td></tr></table></figure></p>
<p>&emsp;当我们传入一个匿名函数来调用它时,我们必须指定他的参数类型,这里是x:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val xs: List[Int] = List(1,2,3,4,5)</div><div class="line">val ex1 = dropWhile(xs, (x: Int)=&gt; x&lt;4)    //ex1的值为List(4,5)</div></pre></td></tr></table></figure></p>
<p>&emsp;不幸的是,我们需要声明x类型是Int,dropWhile的第一个参数是一个List[Int],所以函数上的第二个参数必须接受Int类型,scala可以推导这种情况,如果我们把dropWhile的参数分成两组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def dropWhile[A](l: List[A])( f: A =&gt; Boolean): List[A] =</div><div class="line">  l match &#123;</div><div class="line">    case Cons(h,t) if f(h) =&gt; dropWhile(t)(f)</div><div class="line">    case _ =&gt; l</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;这个版本的dropWhile的语法看起来像dropWhile(xs)(f), 这里dropWhile(xs)返回一个函数,然后对这个函数传入参数调用(换句话说dropWhile是柯里化的),使用这种方式把参数分组的目的是帮助类型推导,现在我们可以使用dropWhile时不加类型标注<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val xs: List[Int] = List(1,2,3,4,5)</div><div class="line">val ex1 = dropWhile(xs)(x=&gt;x&lt;4)        //注意变量x没有使用类型标注</div></pre></td></tr></table></figure></p>
<p>&emsp;一般来讲,当函数定义包含多个参数数组时,参数里的类型信息从左到右传递,这里第一个参数组确定A类型参数为Int,所以x=&gt;x&lt;4里的类型标注可以不需要</p>
<h1 id="4-基于list的递归并泛化为高阶函数"><a href="#4-基于list的递归并泛化为高阶函数" class="headerlink" title="4.基于list的递归并泛化为高阶函数"></a>4.基于list的递归并泛化为高阶函数</h1><p>&emsp;再看一下sum和product的实现,我们已经稍微简化了product的实现,不引入检测0.0的短路逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def sum(ints: List[Int]): Int = ints match &#123;</div><div class="line">    case Nil =&gt; 0</div><div class="line">    case Cons(x,xs) =&gt; x+sum(xs)</div><div class="line">  &#125;</div><div class="line">  def product(ds: List[Double]): Double = ds match &#123;</div><div class="line">    case Nil =&gt; 1.0</div><div class="line">    case Cons(x, xs) =&gt; x*product(xs)</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;注意:这两个定义很相似,他们操作不同的数据类型(List[Int]与List[Double]), 除此之外的差异还有在List为空时的返回值(sum返回0,product返回1.0), 以及对结果的组合操作(sum是+,而product是*),如果再遇到类似重复的情况,可以把子表达式放到函数参数里来进行泛化,如果一个子表达式引用任何局部变量(+操作引用了模式中的x和xs局部变量,product里也存在相同的情况),把子表达式放入一个接收这些变量作为参数的函数,现在就改一下,函数的参数包含当列表为空时返回的值,以及列表非空时用于将元素添加到结果的函数</p>
<p>&emsp;下面是右折叠的简单运用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def foldRight[A,B](as: List[A], z:B)(f: (A,B)=&gt;B): B = as match &#123;</div><div class="line">  case Nil =&gt; z</div><div class="line">  case Cons(x,xs) =&gt; f(x, foldRight(xs,z)(f))</div><div class="line">&#125;</div><div class="line"></div><div class="line">def sum(ints: List[Int]): Int = foldRight(ints, 0)((x,y)=&gt;x+y)</div><div class="line">def product(ds: List[Double]): Double = foldRight(ds, 1.0)(_ * _)</div><div class="line">// _ * _ 是对(x,y) =&gt; x*y 更简练的写法</div></pre></td></tr></table></figure></p>
<p>&emsp;来看一下sum函数调用foldRight的执行过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//sum(List(1,2,3))</div><div class="line"></div><div class="line">foldRight(Cons(1, Cons(2, Cons(3,Nil))), 0)((x,y) =&gt; x+y)</div><div class="line">1 + foldRight(Cons(2, Cons(3,Nil)), 0)((x,y) =&gt; x+y)</div><div class="line">1 + (2 + foldRight(Cons(Cons(3, Nil), 0)((x,y) =&gt; x+y))</div><div class="line">1 + (2 + 3 + foldRight(Cons(Nil), 0)((x,y) =&gt; x+y))</div><div class="line">1 + (2 + (3 + (0)))</div><div class="line">6</div><div class="line">//注意foldRight在开始迭代之前,必须一路遍历到列表的末尾(在处理过程中不断压栈)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>针对匿名函数的下划线</p>
</blockquote>
<p>&emsp;匿名函数(x,y)=&gt; x+y ,在x和y类型可以被scala推导的情况下可以缩写为<em>+</em>,对那些函数参数只在函数体中出现一次的函数,这种缩写很适用,匿名函数表达式中的每一个下划线,例如<em>+</em>会引入一个新的(未命名的)函数参数,并对其引用,参数的引入按照从左到右的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_ + _     // (x,y) =&gt; x+y</div><div class="line">_ * 2     // x =&gt; x*2</div><div class="line">_.head     // xs =&gt; xs.head</div><div class="line">_ drop _     // (xs, n) =&gt; xs drop n</div></pre></td></tr></table></figure></p>
<h2 id="4-1-更多与列表相关的函数"><a href="#4-1-更多与列表相关的函数" class="headerlink" title="4.1.更多与列表相关的函数"></a>4.1.更多与列表相关的函数</h2><blockquote>
<p>练习题1:使用foldRight计算List的长度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def length[A](l: List[A]): Int =</div><div class="line">  foldRight(l, 0)((_,acc) =&gt; acc + 1)</div></pre></td></tr></table></figure>
<blockquote>
<p>练习题2:使用尾递归的方式写一个递归函数foldLeft</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@annotation.tailrec</div><div class="line">def foldLeft[A,B](l: List[A], z: B)(f: (B, A) =&gt; B): B = l match &#123;   //注意函数f的参数的位置变了</div><div class="line">  case Nil =&gt; z</div><div class="line">  case Cons(h,t) =&gt; foldLeft(t, f(z,h))(f)</div><div class="line">&#125;</div><div class="line"></div><div class="line">def sum3(l: List[Int]) = foldLeft(l, 0)(_ + _)   //实现sum函数</div><div class="line">def product3(l: List[Double]) = foldLeft(l, 1.0)(_ * _)   //实现product函数</div><div class="line">def length2[A](l: List[A]): Int = foldLeft(l, 0)((acc,h) =&gt; acc + 1)   //计算列表的长度</div><div class="line">def reverse[A](l: List[A]): List[A] = foldLeft(l, List[A]())((acc,h) =&gt; Cons(h,acc))   //对列表的元素颠倒顺序</div></pre></td></tr></table></figure>
<blockquote>
<p>练习题3:写一个函数将List[Int]中的每一个元素都加1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def add1(l: List[Int]): List[Int] =</div><div class="line">  foldRight(l, Nil:List[Int])((h,t) =&gt; Cons(h+1,t))</div></pre></td></tr></table></figure>
<blockquote>
<p>练习题4:写一个函数将List[Double] 中每一个元素转成String, 形成List[String]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def doubleToString(l: List[Double]): List[String] =</div><div class="line">  foldRight(l, Nil:List[String])((h,t) =&gt; Cons(h.toString,t))</div></pre></td></tr></table></figure>
<blockquote>
<p>练习题5:写一个函数,将列表中的每个元素进行修改,并维持列表结构,签名如下:<br>def map<a href="as: List[A]" target="_blank" rel="external">A,B</a>(f: A=&gt;B): List[B] </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def map[A,B](l: List[A])(f: A =&gt; B): List[B] =</div><div class="line">  foldRight(l, Nil:List[B])((h,t) =&gt; Cons(f(h),t))    //f(h)就是对每一个元素进行操作</div></pre></td></tr></table></figure>
<blockquote>
<p>练习题6:写一个filter函数,从列表中删除所有不满足断言的元素,并用他删除一个List[Int]中的所有奇数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def filter[A](l: List[A])(f: A =&gt; Boolean): List[A] =</div><div class="line">  foldRight(l, Nil:List[A])((h,t) =&gt; if (f(h)) Cons(h,t) else t)</div></pre></td></tr></table></figure>
<blockquote>
<p>练习题7:写一个flatMap函数,他跟map函数有些像,除了传入的函数f返回的是列表而非单个结果,这个f所返回的列表会被塞到flatMap最终所返回的列表中,如下签名:<br>def flatMap<a href="as: List[A]" target="_blank" rel="external">A,B</a>(f: A=&gt;List[B]): List[B]<br>&emsp; 例如:flatMap[List(1,2,3))(i=&gt;List(i,i))    ,结果是List(1,1,2,2,3,3)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def flatMap[A,B](l: List[A])(f: A =&gt; List[B]): List[B] =</div><div class="line">  concat(map(l)(f))</div><div class="line"></div><div class="line">def concat[A](l: List[List[A]]): List[A] =</div><div class="line">  foldRight(l, Nil:List[A])(append)</div></pre></td></tr></table></figure>
<blockquote>
<p>练习题8:写一个函数,接收2个列表,通过对相应元素的相加构造出一个新的列表,比如:List(1,2,3) 和List(4,5,6) ,构造出List(5,7,9)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def addPairwise(a: List[Int], b: List[Int]): List[Int] = (a,b) match &#123;</div><div class="line">  case (Nil, _) =&gt; Nil</div><div class="line">  case (_, Nil) =&gt; Nil</div><div class="line">  case (Cons(h1,t1), Cons(h2,t2)) =&gt; Cons(h1+h2, addPairwise(t1,t2))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>练习题9:针对上面的函数进行泛化,不只是针对整数或相加操作,将这个泛化函数命名 为zipWith</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def zipWith[A,B,C](a: List[A], b: List[B])(f: (A,B) =&gt; C): List[C] = (a,b) match &#123;</div><div class="line">  case (Nil, _) =&gt; Nil</div><div class="line">  case (_, Nil) =&gt; Nil</div><div class="line">  case (Cons(h1,t1), Cons(h2,t2)) =&gt; Cons(f(h1,h2), zipWith(t1,t2)(f))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>标准库中的列表</p>
</blockquote>
<p>&emsp;列表(List)存在于scala标准库中,我们写的List和标准库中的List不同的是,Cons在标准库的版本写为::, 他使用右结合,所以1::2::Nil等于1::(2::Nil) ,也等于List(1,2,3) ,进行模式匹配时,case Cons(h,t) 变为了case h::t<br>&emsp;下面是一个其他的List 的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def take(n: Int): List[A]    </div><div class="line">//返回一个由当前列表中前n个元素构成的列表</div><div class="line"></div><div class="line">def takeWhile(f: A=&gt;Boolean): List[A]</div><div class="line">//返回当前列表中最长的多个连续元素的列表,这些元素都必须满足断言f</div><div class="line"></div><div class="line">def forall(f: A=&gt;Boolean): Boolean</div><div class="line">//如果存在所有的元素都满足断言f就返回true</div><div class="line"></div><div class="line">def exists(f: A=&gt;Boolean): Boolean</div><div class="line">//如果存在任何一个元素满足断言f就返回true</div><div class="line"></div><div class="line">scanLeft和scanRight </div><div class="line">//就像foldLeft和foldRight,但他们都返回部分结果,而非最终的累计值列表</div></pre></td></tr></table></figure></p>
<h2 id="4-2-用简单组件组合list函数时的效率损失"><a href="#4-2-用简单组件组合list函数时的效率损失" class="headerlink" title="4.2.用简单组件组合list函数时的效率损失"></a>4.2.用简单组件组合list函数时的效率损失</h2><blockquote>
<p>练习:写一个hasSubsequence 来检测List子序列是否包含一个另外指定的一个List,比如List(1,2,3,4) 包含List(1,2),List(1,2,3),List(2,3,4)等,下面是用一种方式实现,第五章,会有改进</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@annotation.tailrec</div><div class="line">def startsWith[A](l: List[A], prefix: List[A]): Boolean = (l,prefix) match &#123;</div><div class="line">  case (_,Nil) =&gt; true</div><div class="line">  case (Cons(h,t),Cons(h2,t2)) if h == h2 =&gt; startsWith(t, t2)</div><div class="line">  case _ =&gt; false</div><div class="line">&#125;</div><div class="line">@annotation.tailrec</div><div class="line">def hasSubsequence[A](sup: List[A], sub: List[A]): Boolean = sup match &#123;</div><div class="line">  case Nil =&gt; sub == Nil</div><div class="line">  case _ if startsWith(sup, sub) =&gt; true    //如果是开头匹配</div><div class="line">  case Cons(h,t) =&gt; hasSubsequence(t, sub)    //如果不是开头匹配,那么去掉开头的元素</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-树"><a href="#5-树" class="headerlink" title="5.树"></a>5.树</h1><blockquote>
<p>scala中的元组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">scala&gt; val p = (&quot;Bob&quot;, 42)</div><div class="line">p: (String, Int) = (Bob,42)</div><div class="line"></div><div class="line">scala&gt; p._1</div><div class="line">res0: String = Bob</div><div class="line"></div><div class="line">scala&gt; p._2</div><div class="line">res1: Int = 42</div><div class="line"></div><div class="line">scala&gt; p match &#123;case (a,b) =&gt; b&#125;</div><div class="line">res2: Int = 42</div><div class="line"></div><div class="line">//这个例子中(&quot;Bob&quot;, 42) 是一个类型为(String,Int)的数据对(pair),他其实是Tuple2[String, Int] 的语法糖,</div></pre></td></tr></table></figure>
<blockquote>
<p>二叉树数据结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sealed trait Tree[+A]</div><div class="line">case class Leaf[A](value: A) extends Tree[A]</div><div class="line">case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]</div></pre></td></tr></table></figure>
<p>&emsp;如下是图示</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/Functional_Programming_in_Scala/3/4.png" alt="树" title="树"></p>
<blockquote>
<p>练习1:写一个size函数,统计一颗树中的节点数(叶子节点和分支节点)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def size[A](t: Tree[A]): Int = t match &#123;</div><div class="line">  case Leaf(_) =&gt; 1</div><div class="line">  case Branch(l,r) =&gt; 1 + size(l) + size(r)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>练习2:写一个maxinum返回Tree[Int]中的最大的元素</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def maximum(t: Tree[Int]): Int = t match &#123;</div><div class="line">  case Leaf(n) =&gt; n</div><div class="line">  case Branch(l,r) =&gt; maximum(l) max maximum(r)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>练习3:写一个depth函数,返回一颗树中从根节点到任何叶子节点最大的路径长度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def depth[A](t: Tree[A]): Int = t match &#123;</div><div class="line">  case Leaf(_) =&gt; 0</div><div class="line">  case Branch(l,r) =&gt; 1 + (depth(l) max depth(r))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>练习4:写一个map函数,类似于List中的同名函数,接受一个函数,对树中的每个元素进行修改</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def map[A,B](t: Tree[A])(f: A =&gt; B): Tree[B] = t match &#123;</div><div class="line">  case Leaf(a) =&gt; Leaf(f(a))</div><div class="line">  case Branch(l,r) =&gt; Branch(map(l)(f), map(r)(f))   //map(l)(f) 再次进入map的时候会调用第一个case</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/functionalProgrammingInScala/第三章 函数式数据结构/" data-id="cj290sb2l000essqq4qi6cnbv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala函数式编程/">scala函数式编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-functionalProgrammingInScala/第一章 什么是函数式编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/functionalProgrammingInScala/第一章 什么是函数式编程/" class="article-date">
  <time datetime="2017-04-16T04:47:25.373Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/functionalProgrammingInScala/第一章 什么是函数式编程/">第一章 什么是函数式编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-函数式编程的好处-一个简单的例子"><a href="#1-函数式编程的好处-一个简单的例子" class="headerlink" title="1.函数式编程的好处:一个简单的例子"></a>1.函数式编程的好处:一个简单的例子</h1><p>&emsp;函数式编程(FP)基于一个简单又蕴含深远的前提:只用纯函数来构造程序—-换句话说,函数没有副作用,什么是副作用?一个带有副作用的函数不仅是简单的返回一个值,还干了一些其他事情,比如:</p>
<ol>
<li>修改了一个变量</li>
<li>直接修改数据结构</li>
<li>设置一个对象的成员</li>
<li>抛出一个异常或者一个错误停止</li>
<li>打印到终端或读取用户的输入</li>
<li>读取或写入一个文件</li>
<li>在屏幕上绘画</li>
</ol>
<p>&emsp;函数式编程更加模块化,由于纯函数的模块化特性,他们很容易被测试,复用,并行化,泛化以及推导,此外,纯函数减少了产生bug的可能性<br>&emsp;在这一章,我们将演示一个简单的带有副作用的程序,并通过去除这些副作用来示范函数式的一些好处</p>
<h2 id="1-1-一段带有副作用的程序"><a href="#1-1-一段带有副作用的程序" class="headerlink" title="1.1.一段带有副作用的程序"></a>1.1.一段带有副作用的程序</h2><p>&emsp;假设我们要为一家咖啡店的购物编写一段程序,先用一段带有副作用的scala程序来实现<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cafe</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">buyCoffee</span></span>(cc: <span class="type">CreditCard</span>): <span class="type">Coffee</span> = &#123;</div><div class="line">    <span class="keyword">val</span> cup = <span class="keyword">new</span> <span class="type">Coffee</span>()</div><div class="line">    cc.charge(cup.price)  <span class="comment">//副作用,信用卡计费,我需要的是一杯咖啡,返回coffee即可,其他额外的是不需要做</span></div><div class="line">    cup <span class="comment">//返回coffee</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;cc.charge(cup.price)这行是一个副作用的例子,信用卡的计费涉及与外部世界的一些交互——-假设需要通过web service联系信用卡公司,授权交易,对卡片计费,并且持久化一些记录以便以后引用,我们的函数不过是返回一杯咖啡,这些其他行为也额外发生了,因此也被称为”副作用”<br>&emsp;副作用导致这段代码很难测试,我们不希望测试逻辑真的是去联系信用卡公司并对卡片计费,缺乏可测试性预示着设计的修改:按理说CreditCard不应该知道如何联系信用卡公司实际执行一次计费,他就是一张信用卡,他应该拥有的是信用卡的属性,所以同样也不应该知道怎么把一次计费持久化到内部系统,我们可以让CreditCard忽略掉这些事情,通过传递一个Payments对象(支付对象)给buyCoffee函数,使代码更加模块化和可测化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class Cafe&#123;</div><div class="line">  def buyCoffee(cc: CreditCard, p: Payment): Coffee = &#123;</div><div class="line">    val cup = new Coffee()</div><div class="line">    p.charge(cc, cup.price)  //副作用,信用卡计费,我需要的是一杯咖啡,返回coffee即可,其他额外的是不需要做</div><div class="line">    cup //返回coffee</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;虽然当我们调用p.charge(cc, cup.price)的时候仍然有副作用发生,但至少恢复了一些可测试性,Payments可以是一个接口,我们可以写一个合适于测试的mock实现这个接口<br>&emsp;撇开对测试的担心,这里还有另一个问题,buyCoffee方法很难被复用,假设一个叫Alice的顾客,要订购12杯咖啡,最理想的情况是只要复用这个方法,通过循环来调用12次buyCoffee,但是基于当前的程序,会陷入12次对支付系统的调用,对Alice的信用卡执行12次计费,那样所产生的更多的手续费对Alice和咖啡店都不好</p>
<p>&emsp;多次购买的话我们该怎么做呢?如下图,我们编写一个全新的函数buyCoffees,他使用特别的逻辑去批量处理计费,这里可能不是什么大问题,因为buyCoffee的逻辑很简单,但是在别的情况下我们需要重复的逻辑就会很多,而且要为失去代码的可复用性和可组合性而难过</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/Functional_Programming_in_Scala/1/1.png" alt="buyCoffee的一次调用" title="buyCoffee的一次调用"></p>
<h2 id="1-2-函数式的解法-去除副作用"><a href="#1-2-函数式的解法-去除副作用" class="headerlink" title="1.2.函数式的解法:去除副作用"></a>1.2.函数式的解法:去除副作用</h2><p>&emsp;函数式的解法是消除副作用,通过让buyCoffees方法在返回咖啡(Coffee)的时候,把费用(Charge)一并返回,计费的处理包括:发送到信用卡公司,持久化这条记录等,这些过程将在其他地方来做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Cafe&#123;</div><div class="line">  def buyCoffee(cc: CreditCard): (Coffee, Charge) = &#123;</div><div class="line">    val cup = new Coffee()</div><div class="line">    (cup, Charge(cc, cup.price))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;我们先来看看”Charge”怎么定义?我们所构造的这个数据类型有信用卡(CreditCard)和金额(amount)组成,并提供了一个combine函数,以便对同一张信用卡合并计费<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">case class Charge(cc: CreditCard, amount: Double)&#123;</div><div class="line">  //对相同的信用卡进行合并计费</div><div class="line">  def combine(other: Charge) =&#123;</div><div class="line">    if (cc == other.cc)</div><div class="line">      Charge(cc, amount+other.amount)    //case类可以不通过new关键字创建,我们只需要在类名后面传递一组参数到主构造器</div><div class="line">    else </div><div class="line">      throw new Exception(&quot;Can&apos;t combine charge to different cards&quot;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;现在我们来看看buyCoffee方法如何实现购买n杯咖啡,与之前不同,现在可以利用buyCoffees方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//用同一张信用卡点了多杯咖啡</div><div class="line">def buyCoffees(cc: CrediCard, n: Int): (List[Coffee], Charge) = &#123;</div><div class="line">  val purchases: List[(Coffee, Charge)] = List.fill(n)(buyCoffee(cc))    //List.fill(n)(x)创建一个对x赋值n份的列表</div><div class="line">  val (coffees, charges) = purchases.unzip    //unzip将数值对儿列表,分成一对儿(pair)列表,所以分解成为了两个list</div><div class="line">  (coffees, charges.reduce((c1,c2)=&gt;c1.combine(c2))    //charges.reduce对整个charge列表规约成一个charge</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;总体上看,这个解决方案有显著的改善,现在我们可以直接复用buyCoffee来定义buyCoffees函数,这两个函数都很简单并容易测试,不需要实现一些Payments接口来进行复杂的mock,事实上,Cafe现在完全忽略了计费是如何处理的,当然我们可以用一个Payments类来做付款处理,但Cafe并不需要了解他<br>&emsp;让Charge成为一等值,还有一些我们没有预期到的好处:我们能更容易的组装业务,举个例子:Alice带着她的笔记本电脑来咖啡店并在这里工作几个小时,中间时不时地会买几杯咖啡,如果咖啡店能把Alice买的咖啡合并成一笔费用以节约信用卡的手续费就太好了,因为Charge是一等值,我们可以用下面的函数把同一张信用卡的费用合并为一个List[Charge]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def coalesce(charges: List[Charge]): List[Charge] =&#123;</div><div class="line">  charges.groupBy(_.cc).values.map(_.reduce(_ combine _)).toList</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;这个函数接收一个计费列表参数,按照信用卡对这个参数进行group,然后对每张卡组合成一个单独的计费</p>
<h1 id="2-纯-函数究竟是什么"><a href="#2-纯-函数究竟是什么" class="headerlink" title="2.(纯)函数究竟是什么?"></a>2.(纯)函数究竟是什么?</h1><p>&emsp;对于一个输入类型为A和输出类型为B的函数f(用scala写为:A=&gt;B,读作”A到B”或”A箭头B”),他是一种将所有的A类型值的值a关联到某个确切的值b的运算过程,及b由a来决定,任何内部或外部过程的状态改变都不会影响到f(a)的计算机结果,例如,函数intToString的类型为Int=&gt;String,他负责将整数转换为一个相应的字符串,除此之外应该什么也不用做<br>&emsp;换言之,一个函数在程序的执行过程中除了根据输入参数给出运行结果之外没有其他的影响,就可以说是没有副作用的,将这一类函数称之为”纯函数”<br>&emsp;你可能已经了解过一些纯函数了,比如考虑整数的加法(+)函数,他接收两个整数值并返回一个整数值,对于给定的两个整数值,他的返回值永远是相同的整数值,另一个例子是java,scala和其他字符串作为不可变对象的语言中对字符串求长度的函数,对于给定的字符串,返回的长度总是相同的</p>
<blockquote>
<p>引用透明</p>
</blockquote>
<p>&emsp;我们可以使用引用透明的概念对纯函数进行形式化,这不仅仅是函数的属性,而且是一般表达式的属性,为了便于讨论,设定一个程序的任何部分的表达式,都可以计算为一个结果,在scala解释器下输入的任何内容都会得到结果,例如:2 + 3是一个表达式,他使用纯函数+对数值2和3进行计算(注意:数值2和3同样也是一个表达式),他没有副作用,这个表达式每次运算的结果都是同一个值5,实际上,如果看到程序里有2+3这样的表达式可以直接替换为5,并不会改变程序的含义<br>&emsp;这意味着任何程序中符合引用透明的表达式都可以由他的结果所取代,而不改变该程序的含义,当调用一个函数时所传入的参数是引用透明的,并且函数调用也是引用透明的,那么这个函数是一个纯函数</p>
<blockquote>
<p>引用透明与纯粹性</p>
</blockquote>
<p>&emsp;对于程序p,如果他包含的表达式e满足引用透明,所有的e都可以替换为他的运算结果而不会改变程序p的含义,假设存在一个函数f,若表达式f(x)对所有的引用透明的表达式x也是引用透明的,那么这个f是一个纯函数</p>
<h1 id="3-引用透明-纯粹性以及代换模型"><a href="#3-引用透明-纯粹性以及代换模型" class="headerlink" title="3.引用透明/纯粹性以及代换模型"></a>3.引用透明/纯粹性以及代换模型</h1><p>&emsp;让我们看看如何对原先的buyCoffee例子定义引用透明的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def buyCoffee(cc: CreditCard): Coffee = &#123;</div><div class="line">  val cup = new Coffee()</div><div class="line">  cc.charge(cup.price)</div><div class="line">  cup</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;无论cc.charge(cup.price)返回什么类型,他都会被buyCoffee丢弃<br>&emsp;因此,buyCoffee(aliceCreditCard)的运算结果将仅仅是一杯咖啡,这相当于new Coffee() , 那么根据我们定义的引用透明,如果buyCoffee要满足纯函数,对于任何p而言,p(buyCoffee(aliceCreditCard))行为需要与p(new Coffee())相同,这显然不成立,表达式new Coffee()不做任何事情,但是buyCoffee(aliceCreditCard)将会连接信用卡公司并授权计费,两个程序显然有差异<br>&emsp;引用透明要求函数不论进行任何操作都可以用它的返回值来代替,这种限制使得推到一个程序的求值变得简单而自然,我们称之为代换模型,如果表达式是引用透明的,那么可以想象计算过程就像在解代数方程,展开表达式的每一部分,使用指示对象替代变量,然后规约到最简单的形式,在这个过程中,每一项都被等价值所替代,计算的过程就是被一个又一个等价值所替代的过程,换句话说:引用透明使得程序具备了等式推理的能力</p>
<blockquote>
<p>一个引用透明的例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; val x = &quot;Hello, World&quot;</div><div class="line">x: String = Hello, World</div><div class="line"></div><div class="line">scala&gt; val r1 = x.reverse</div><div class="line">r1: String = dlroW ,olleH</div><div class="line"></div><div class="line">scala&gt; val r2 = x.reverse</div><div class="line">r2: String = dlroW ,olleH</div></pre></td></tr></table></figure>
<p>&emsp;假设我们把所有使用x的地方用它所引用的表达式来替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; val r1 = &quot;Hello, World&quot;.reverse</div><div class="line">r1: String = dlroW ,olleH</div><div class="line"></div><div class="line">scala&gt; val r2 = &quot;Hello, World&quot;.reverse</div><div class="line">r2: String = dlroW ,olleH</div></pre></td></tr></table></figure></p>
<p>&emsp;这样做并不影响结果,r1和r2的值和以前一样,所以说x是引用透明的,另外,r1和r2也是引用透明的,如果他们出现在某个程序中也可以替代为他们所引用的值而不会对程序造成影响</p>
<blockquote>
<p>一个不是引用透明的例子</p>
</blockquote>
<p>&emsp;比如,java.lang.StringBuilder类里的append方法,这个方法改变了StringBuilder对象自身,在调用append方法之后,StringBuilder对象之前的状态被破坏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">scala&gt; val x = new StringBuilder(&quot;Hello&quot;)</div><div class="line">x: StringBuilder = Hello</div><div class="line"></div><div class="line">scala&gt; val y = x.append(&quot;, World&quot;)</div><div class="line">y: StringBuilder = Hello, World</div><div class="line"></div><div class="line">scala&gt; val r1 =  y.toString</div><div class="line">r1: String = Hello, World</div><div class="line"></div><div class="line">scala&gt; val r2 = y.toString</div><div class="line">r2: String = Hello, World</div></pre></td></tr></table></figure></p>
<p>&emsp;我们将y利用等值替换为append(“, World”),然后r1和r2就不再相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; val r1 = x.append(&quot;, World&quot;).toString</div><div class="line">r1: String = Hello, World, World</div><div class="line"></div><div class="line">scala&gt; val r2 = x.append(&quot;, World&quot;).toString</div><div class="line">r2: String = Hello, World, World, World</div></pre></td></tr></table></figure></p>
<p>&emsp;上面的例子说明:StringBuilder.append不是一个纯函数,虽然r1和r2看上去是同一个表达式,但他们引用的StringBuilder是两个不同的值,在r2调用x.append的时候,r1已经改变了x引用的对象(这就是副作用的产生之处)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/functionalProgrammingInScala/第一章 什么是函数式编程/" data-id="cj290sb2i000cssqq5b2xzyve" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala函数式编程/">scala函数式编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-echarts/直角坐标系之axis(xAsix和yAxis)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/echarts/直角坐标系之axis(xAsix和yAxis)/" class="article-date">
  <time datetime="2017-04-16T04:47:25.368Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/echarts/">echarts</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/echarts/直角坐标系之axis(xAsix和yAxis)/">直角坐标系之axis(xAsix/yAxis)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>下面是对axis(轴)的一些常用选项的介绍<br>
        
          <p class="article-more-link">
            <a href="/2017/04/16/echarts/直角坐标系之axis(xAsix和yAxis)/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/echarts/直角坐标系之axis(xAsix和yAxis)/" data-id="cj290sb2d0007ssqq6j3f2vew" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/echarts/">echarts</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-echarts/echarts上各部分组件图解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/echarts/echarts上各部分组件图解/" class="article-date">
  <time datetime="2017-04-16T04:47:25.366Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/echarts/">echarts</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/echarts/echarts上各部分组件图解/">echarts上各部分组件图解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>下图标注了一个普通的echarts图表的各个组成部分,如下:<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/echarts/combiner/all.png" alt=""><br>在学习echarts之前,需要了解echarts的整体结构以及各个部分的组件有大概的了解,下面是对echarts的组件进行图解,说明各名词的含义</p>
        
          <p class="article-more-link">
            <a href="/2017/04/16/echarts/echarts上各部分组件图解/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/echarts/echarts上各部分组件图解/" data-id="cj290sb2b0006ssqqysfrbdkz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/echarts/">echarts</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-echarts/5 分钟上手 ECharts" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/echarts/5 分钟上手 ECharts/" class="article-date">
  <time datetime="2017-04-16T04:47:25.365Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/echarts/">echarts</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/echarts/5 分钟上手 ECharts/">5 分钟上手 ECharts</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-获取-ECharts的几种方式"><a href="#1-获取-ECharts的几种方式" class="headerlink" title="1.获取 ECharts的几种方式"></a>1.获取 ECharts的几种方式</h1><ul>
<li>从官网下载界面选择你需要的版本下载，根据开发者功能和体积上的需求，我们提供了不同打包的下载，如果你在体积上没有要求，可以直接下载完整版本。开发环境建议下载源代码版本，包含了常见的错误提示和警告。</li>
<li>在 ECharts 的 GitHub 上下载最新的 release 版本，解压出来的文件夹里的 dist 目录里可以找到最新版本的 echarts 库。</li>
<li>通过 npm 获取 echarts，npm install echarts –save，详见“在 webpack 中使用 echarts”</li>
<li>cdn 引入，你可以在 cdnjs，npmcdn 或者国内的 bootcdn 上找到 ECharts 的最新版本。</li>
</ul>
<h1 id="2-引入-ECharts"><a href="#2-引入-ECharts" class="headerlink" title="2.引入 ECharts"></a>2.引入 ECharts</h1><p>ECharts 3 开始不再强制使用 AMD 的方式按需引入，代码里也不再内置 AMD 加载器。因此引入方式简单了很多，只需要像普通的 JavaScript 库一样用 script 标签引入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;!-- 引入 ECharts 文件 --&gt;</div><div class="line">    &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h1 id="3-绘制一个简单的图表"><a href="#3-绘制一个简单的图表" class="headerlink" title="3.绘制一个简单的图表"></a>3.绘制一个简单的图表</h1><p>在绘图前我们需要为 ECharts 准备一个具备高宽的 DOM 容器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</div><div class="line">    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>然后就可以通过 echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图，下面是完整代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;ECharts&lt;/title&gt;</div><div class="line">    &lt;!-- 引入 echarts.js --&gt;</div><div class="line">    &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;</div><div class="line">    &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        // 基于准备好的dom，初始化echarts实例</div><div class="line">        var myChart = echarts.init(document.getElementById(&apos;main&apos;));</div><div class="line"></div><div class="line">        // 指定图表的配置项和数据</div><div class="line">        var option = &#123;</div><div class="line">            title: &#123;</div><div class="line">                text: &apos;ECharts 入门示例&apos;</div><div class="line">            &#125;,</div><div class="line">            tooltip: &#123;&#125;,</div><div class="line">            legend: &#123;</div><div class="line">                data:[&apos;销量&apos;]</div><div class="line">            &#125;,</div><div class="line">            xAxis: &#123;</div><div class="line">                data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]</div><div class="line">            &#125;,</div><div class="line">            yAxis: &#123;&#125;,</div><div class="line">            series: [&#123;</div><div class="line">                name: &apos;销量&apos;,</div><div class="line">                type: &apos;bar&apos;,</div><div class="line">                data: [5, 20, 36, 10, 10, 20]</div><div class="line">            &#125;]</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        // 使用刚指定的配置项和数据显示图表。</div><div class="line">        myChart.setOption(option);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/echarts/echarts_hello_world.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/echarts/5 分钟上手 ECharts/" data-id="cj290sb210003ssqq0d59vl87" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/echarts/">echarts</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/深入理解spark核心思想与源码分析/第4章 存储系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第4章 存储系统/" class="article-date">
  <time datetime="2017-04-16T04:47:25.361Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spark/">spark</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第4章 存储系统/">第4章 存储系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>spark为了避免Hadoop读写磁盘的I/O操作成为性能瓶颈,优先将配置信息,计算结果等数据存入内存,这极大的提升了系统的执行效率,正是因为这一关键决策,才让spark能在大数据应用中表现出优秀的计算能力</p>
        
          <p class="article-more-link">
            <a href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第4章 存储系统/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第4章 存储系统/" data-id="cj290scoy01dhssqq8uplxujr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spark/">spark</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/深入理解spark核心思想与源码分析/第3章 SparkContext的初始化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第3章 SparkContext的初始化/" class="article-date">
  <time datetime="2017-04-16T04:47:25.359Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spark/">spark</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第3章 SparkContext的初始化/">第3章 SparkContext的初始化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SparkContext的初始化是Driver应用程序提交执行的前提,本章内容以local模式为主,并按照代码执行顺序讲解</p>
        
          <p class="article-more-link">
            <a href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第3章 SparkContext的初始化/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第3章 SparkContext的初始化/" data-id="cj290sd0z01mfssqqqxeilxzz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spark/">spark</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/深入理解spark核心思想与源码分析/第2章 spark设计理念与基本架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第2章 spark设计理念与基本架构/" class="article-date">
  <time datetime="2017-04-16T04:47:25.358Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spark/">spark</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第2章 spark设计理念与基本架构/">第2章 spark设计理念与基本架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>spark也是基于map reduce算法模式实现的分布式框架,拥有hadoop MapReduce所具有的优点,并且解决了Hadoop MapReduce中的诸多缺陷.</p>
        
          <p class="article-more-link">
            <a href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第2章 spark设计理念与基本架构/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第2章 spark设计理念与基本架构/" data-id="cj290scou01dessqqrb73598d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spark/">spark</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/深入理解spark核心思想与源码分析/第1章 环境准备" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第1章 环境准备/" class="article-date">
  <time datetime="2017-04-16T04:47:25.357Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spark/">spark</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第1章 环境准备/">第1章 环境准备</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="剖析spark-shell"><a href="#剖析spark-shell" class="headerlink" title="剖析spark-shell"></a>剖析spark-shell</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function main() &#123;</div><div class="line">  if $cygwin; then</div><div class="line">    stty -icanon min 1 -echo &gt; /dev/null 2&gt;&amp;1</div><div class="line">    export SPARK_SUBMIT_OPTS=&quot;$SPARK_SUBMIT_OPTS -Djline.terminal=unix&quot;</div><div class="line">    &quot;$&#123;SPARK_HOME&#125;&quot;/bin/spark-submit --class org.apache.spark.repl.Main --name &quot;Spark shell&quot; &quot;$@&quot;</div><div class="line">    stty icanon echo &gt; /dev/null 2&gt;&amp;1</div><div class="line">  else</div><div class="line">    export SPARK_SUBMIT_OPTS</div><div class="line">    &quot;$&#123;SPARK_HOME&#125;&quot;/bin/spark-submit --class org.apache.spark.repl.Main --name &quot;Spark shell&quot; &quot;$@&quot;</div><div class="line">  fi</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到脚本spark-shell里执行了spark-submit脚本,打开spark-submit脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">exec &quot;$&#123;SPARK_HOME&#125;&quot;/bin/spark-class org.apache.spark.deploy.SparkSubmit &quot;$@&quot;</div></pre></td></tr></table></figure></p>
<p>在脚本spark-submit中执行的是spark-class,并且增加了参数 SparkSubmit,打开spark-class脚本,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">if [ -n &quot;$&#123;JAVA_HOME&#125;&quot; ]; then</div><div class="line">  RUNNER=&quot;$&#123;JAVA_HOME&#125;/bin/java&quot;</div><div class="line">else</div><div class="line">  if [ `command -v java` ]; then</div><div class="line">    RUNNER=&quot;java&quot;</div><div class="line">  else</div><div class="line">    echo &quot;JAVA_HOME is not set&quot; &gt;&amp;2</div><div class="line">    exit 1</div><div class="line">  fi</div><div class="line">fi</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">CMD=()</div><div class="line">while IFS= read -d &apos;&apos; -r ARG; do</div><div class="line">  CMD+=(&quot;$ARG&quot;)</div><div class="line">done &lt; &lt;(&quot;$RUNNER&quot; -cp &quot;$LAUNCH_CLASSPATH&quot; org.apache.spark.launcher.Main &quot;$@&quot;)</div><div class="line">exec &quot;$&#123;CMD[@]&#125;&quot;</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">结合spark-submit脚本:</div><div class="line">exec &quot;$&#123;SPARK_HOME&#125;&quot;/bin/spark-class org.apache.spark.deploy.SparkSubmit &quot;$@&quot;</div><div class="line">就是:</div><div class="line">exec &quot;$RUNNER&quot; -cp &quot;$LAUNCH_CLASSPATH&quot; org.apache.spark.launcher.Main org.apache.spark.deploy.SparkSubmit &quot;$@&quot;</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>读到这里,应该知道spark启动了以SparkSubmit为主类jvm进程,</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/深入理解spark核心思想与源码分析/第1章 环境准备/" data-id="cj290scop01dbssqqvdapbgmd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spark/">spark</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bigdata/zookeeper/服务器动态上下线程序的工作机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/bigdata/zookeeper/服务器动态上下线程序的工作机制/" class="article-date">
  <time datetime="2017-04-16T04:47:25.354Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hadoop/">hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/bigdata/zookeeper/服务器动态上下线程序的工作机制/">服务器动态上下线程序的工作机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>需求:客户端能够实时洞察到服务器上下线的变化</p>
<p>原理图如下:</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/bigdata/zookeeper/d_on_off_line/1.png" alt=""></p>
<ul>
<li>服务器端启动时就去zookeeper注册信息,如图</li>
<li>客户端启动就去getChildren,获取当前在服务器列表,并且注册监听</li>
<li>如果服务器上下线,就会有事件通知</li>
<li>客户端的监听机制再去重新获取服务器列表,并注册监听</li>
</ul>
<p>服务器端实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">package cn.itcast.bigdata.zkdist;</div><div class="line"></div><div class="line">import org.apache.zookeeper.CreateMode;</div><div class="line">import org.apache.zookeeper.WatchedEvent;</div><div class="line">import org.apache.zookeeper.Watcher;</div><div class="line">import org.apache.zookeeper.ZooDefs.Ids;</div><div class="line">import org.apache.zookeeper.ZooKeeper;</div><div class="line"></div><div class="line">public class DistributedServer &#123;</div><div class="line">	private static final String connectString = &quot;mini1:2181,mini2:2181,mini3:2181&quot;;</div><div class="line">	private static final int sessionTimeout = 2000;</div><div class="line">	private static final String parentNode = &quot;/servers&quot;;</div><div class="line"></div><div class="line">	private ZooKeeper zk = null;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 创建到zk的客户端连接</div><div class="line">	 * </div><div class="line">	 * @throws Exception</div><div class="line">	 */</div><div class="line">	public void getConnect() throws Exception &#123;</div><div class="line"></div><div class="line">		zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;</div><div class="line">			@Override</div><div class="line">			public void process(WatchedEvent event) &#123;</div><div class="line">				// 收到事件通知后的回调函数（应该是我们自己的事件处理逻辑）</div><div class="line">				System.out.println(event.getType() + &quot;---&quot; + event.getPath());</div><div class="line">				try &#123;</div><div class="line">					zk.getChildren(&quot;/&quot;, true);</div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 向zk集群注册服务器信息</div><div class="line">	 * </div><div class="line">	 * @param hostname</div><div class="line">	 * @throws Exception</div><div class="line">	 */</div><div class="line">	public void registerServer(String hostname) throws Exception &#123;</div><div class="line"></div><div class="line">		String create = zk.create(parentNode + &quot;/server&quot;, hostname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</div><div class="line">		System.out.println(hostname + &quot;is online..&quot; + create);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 业务功能</div><div class="line">	 * </div><div class="line">	 * @throws InterruptedException</div><div class="line">	 */</div><div class="line">	public void handleBussiness(String hostname) throws InterruptedException &#123;</div><div class="line">		System.out.println(hostname + &quot;start working.....&quot;);</div><div class="line">		Thread.sleep(Long.MAX_VALUE);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">		// 获取zk连接</div><div class="line">		DistributedServer server = new DistributedServer();</div><div class="line">		server.getConnect();</div><div class="line"></div><div class="line">		// 利用zk连接注册服务器信息</div><div class="line">		server.registerServer(args[0]);</div><div class="line"></div><div class="line">		// 启动业务功能</div><div class="line">		server.handleBussiness(args[0]);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">package cn.itcast.bigdata.zkdist;</div><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">import org.apache.zookeeper.KeeperException;</div><div class="line">import org.apache.zookeeper.WatchedEvent;</div><div class="line">import org.apache.zookeeper.Watcher;</div><div class="line">import org.apache.zookeeper.ZooKeeper;</div><div class="line"></div><div class="line">public class DistributedClient &#123;</div><div class="line"></div><div class="line">	private static final String connectString = &quot;mini1:2181,mini2:2181,mini3:2181&quot;;</div><div class="line">	private static final int sessionTimeout = 2000;</div><div class="line">	private static final String parentNode = &quot;/servers&quot;;</div><div class="line">	// 注意:加volatile的意义何在？</div><div class="line">	private volatile List&lt;String&gt; serverList;</div><div class="line">	private ZooKeeper zk = null;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 创建到zk的客户端连接</div><div class="line">	 * </div><div class="line">	 * @throws Exception</div><div class="line">	 */</div><div class="line">	public void getConnect() throws Exception &#123;</div><div class="line"></div><div class="line">		zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123;</div><div class="line">			@Override</div><div class="line">			public void process(WatchedEvent event) &#123;</div><div class="line">				// 收到事件通知后的回调函数（应该是我们自己的事件处理逻辑）</div><div class="line">				try &#123;</div><div class="line">					//重新更新服务器列表，并且注册了监听，很重要</div><div class="line">					getServerList();</div><div class="line"></div><div class="line">				&#125; catch (Exception e) &#123;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 获取服务器信息列表</div><div class="line">	 * </div><div class="line">	 * @throws Exception</div><div class="line">	 */</div><div class="line">	public void getServerList() throws Exception &#123;</div><div class="line"></div><div class="line">		// 获取服务器子节点信息，并且对父节点进行监听</div><div class="line">		List&lt;String&gt; children = zk.getChildren(parentNode, true);</div><div class="line"></div><div class="line">		// 先创建一个局部的list来存服务器信息</div><div class="line">		List&lt;String&gt; servers = new ArrayList&lt;String&gt;();</div><div class="line">		for (String child : children) &#123;</div><div class="line">			// child只是子节点的节点名</div><div class="line">			byte[] data = zk.getData(parentNode + &quot;/&quot; + child, false, null);</div><div class="line">			servers.add(new String(data));</div><div class="line">		&#125;</div><div class="line">		// 把servers赋值给成员变量serverList，已提供给各业务线程使用</div><div class="line">		serverList = servers;</div><div class="line">		</div><div class="line">		//打印服务器列表</div><div class="line">		System.out.println(serverList);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 业务功能</div><div class="line">	 * </div><div class="line">	 * @throws InterruptedException</div><div class="line">	 */</div><div class="line">	public void handleBussiness() throws InterruptedException &#123;</div><div class="line">		System.out.println(&quot;client start working.....&quot;);</div><div class="line">		Thread.sleep(Long.MAX_VALUE);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">	public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">		// 获取zk连接</div><div class="line">		DistributedClient client = new DistributedClient();</div><div class="line">		client.getConnect();</div><div class="line">		// 获取servers的子节点信息（并监听），从中获取服务器信息列表</div><div class="line">		client.getServerList();</div><div class="line"></div><div class="line">		// 业务线程启动</div><div class="line">		client.handleBussiness();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/bigdata/zookeeper/服务器动态上下线程序的工作机制/" data-id="cj290scom01d8ssqqgh767rey" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/zookeeper/">zookeeper</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/34/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="page-number" href="/page/34/">34</a><span class="page-number current">35</span><a class="page-number" href="/page/36/">36</a><a class="page-number" href="/page/37/">37</a><span class="space">&hellip;</span><a class="page-number" href="/page/58/">58</a><a class="extend next" rel="next" href="/page/36/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IDEA/">IDEA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NFS/">NFS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tachyon/">Tachyon</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/azkaban/">azkaban</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/echarts/">echarts</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hbase/">hbase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hive/">hive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/inotify/">inotify</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/logstash/">logstash</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rsync/">rsync</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/socket/">socket</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sqoop/">sqoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storm/">storm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux基础命令/">Linux基础命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux重要配置文件/">Linux重要配置文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NFS/">NFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/azkaban/">azkaban</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echarts/">echarts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hbase/">hbase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inotify/">inotify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logstash/">logstash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mapreduce/">mapreduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcached/">memcached</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rpc/">rpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rsync/">rsync</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala/">scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala函数式编程/">scala函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala编程/">scala编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqoop/">sqoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storm/">storm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Linux基础命令/" style="font-size: 19.52px;">Linux基础命令</a> <a href="/tags/Linux重要配置文件/" style="font-size: 14.76px;">Linux重要配置文件</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/NIO/" style="font-size: 11.43px;">NIO</a> <a href="/tags/azkaban/" style="font-size: 10.48px;">azkaban</a> <a href="/tags/echarts/" style="font-size: 10.95px;">echarts</a> <a href="/tags/flume/" style="font-size: 10.95px;">flume</a> <a href="/tags/hadoop/" style="font-size: 18.57px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 13.33px;">hbase</a> <a href="/tags/hive/" style="font-size: 18.1px;">hive</a> <a href="/tags/inotify/" style="font-size: 10px;">inotify</a> <a href="/tags/java/" style="font-size: 12.38px;">java</a> <a href="/tags/kafka/" style="font-size: 12.86px;">kafka</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/logstash/" style="font-size: 10.48px;">logstash</a> <a href="/tags/mapreduce/" style="font-size: 16.67px;">mapreduce</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/memcached/" style="font-size: 13.81px;">memcached</a> <a href="/tags/mongodb/" style="font-size: 14.76px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 17.14px;">mysql</a> <a href="/tags/netty/" style="font-size: 10.95px;">netty</a> <a href="/tags/nginx/" style="font-size: 14.29px;">nginx</a> <a href="/tags/project/" style="font-size: 10.48px;">project</a> <a href="/tags/python/" style="font-size: 19.05px;">python</a> <a href="/tags/redis/" style="font-size: 17.14px;">redis</a> <a href="/tags/rpc/" style="font-size: 10.48px;">rpc</a> <a href="/tags/rsync/" style="font-size: 10px;">rsync</a> <a href="/tags/scala/" style="font-size: 17.62px;">scala</a> <a href="/tags/scala函数式编程/" style="font-size: 11.9px;">scala函数式编程</a> <a href="/tags/scala编程/" style="font-size: 15.71px;">scala编程</a> <a href="/tags/shell/" style="font-size: 17.62px;">shell</a> <a href="/tags/socket/" style="font-size: 11.9px;">socket</a> <a href="/tags/spark/" style="font-size: 20px;">spark</a> <a href="/tags/sqoop/" style="font-size: 10.95px;">sqoop</a> <a href="/tags/storm/" style="font-size: 15.24px;">storm</a> <a href="/tags/zookeeper/" style="font-size: 16.19px;">zookeeper</a> <a href="/tags/数据仓库/" style="font-size: 11.43px;">数据仓库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/02/bigdata/spark从入门到精通_笔记/Tachyon/">Tachyon</a>
          </li>
        
          <li>
            <a href="/2017/04/30/数据仓库/数据仓库2/">数据仓库</a>
          </li>
        
          <li>
            <a href="/2017/04/29/IDEA/IDEA/">IDEA</a>
          </li>
        
          <li>
            <a href="/2017/04/29/数据仓库/ETL/">ETL</a>
          </li>
        
          <li>
            <a href="/2017/04/28/数据仓库/PowderDesigner/">PowderDesigner的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Mr. Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>