<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一个技术渣的自说自话">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen's Blog">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Chen's Blog">
<meta property="og:description" content="一个技术渣的自说自话">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen's Blog">
<meta name="twitter:description" content="一个技术渣的自说自话">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/"/>





  <title> Chen's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个技术渣的自说自话</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/用图片解释：进程（process）和线程（thread）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/用图片解释：进程（process）和线程（thread）/" itemprop="url">
                  用图片解释：进程（process）和线程（thread)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转自:<br><a href="http://blog.csdn.net/dbanote/article/details/8857825" target="_blank" rel="external">用图片解释：进程（process）和线程（thread）</a></p>
<p>进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。<br>最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。<br>1.</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/1.png" alt=""></p>
<p>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。<br>2.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/2.png" alt=""></p>
<p>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br>3.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/3.png" alt=""></p>
<p>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。<br>4.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/4.png" alt=""></p>
<p>一个车间里，可以有很多工人。他们协同完成一个任务。<br>5.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/5.png" alt=""></p>
<p>线程就好比车间里的工人。一个进程可以包括多个线程。<br>6.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/6.png" alt=""></p>
<p>车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。<br>7.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/7.png" alt=""></p>
<p>可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。<br>8.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/8.png" alt=""></p>
<p>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。<br>9.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/9.png" alt=""></p>
<p>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。<br>10.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/10.png" alt=""></p>
<p>这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。<br>不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。<br>11.<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process_thread_picture/11.png" alt=""></p>
<p>操作系统的设计，因此可以归结为三点：<br>（1）以多进程形式，允许多个任务同时运行；<br>（2）以多线程形式，允许单个任务分成不同的部分运行；<br>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/Python面向对象编程指南(转)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/Python面向对象编程指南(转)/" itemprop="url">
                  Python面向对象编程指南(转)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转自:<br><a href="http://blog.csdn.net/zhoudaxia/article/details/23341261" target="_blank" rel="external">Python面向对象编程指南</a></p>
<p>　抽象是隐藏多余细节的艺术。在面向对象的概念中，抽象的直接表现形式通常为类。虽然Python是解释性语言，但是它是面向对象的，从设计之初就已经是一门面向对象的语言。Python基本上提供了面向对象编程语言的所有元素，如果你已经至少掌握了一门面向对象语言，那么利用Python进行面向对象程序设计将会相当容易。下面就来了解一下如何在Python中进行对象编程。</p>
<h1 id="1-如何定义一个类"><a href="#1-如何定义一个类" class="headerlink" title="1.如何定义一个类"></a>1.如何定义一个类</h1><p>在进行python面向对象编程之前，先来了解几个术语：类，类对象，实例对象，属性，函数和方法。<br>类是对现实世界中一些事物的封装，定义一个类可以采用下面的方式来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class className: </div><div class="line">    block</div></pre></td></tr></table></figure></p>
<p>　　注意类名后面有个冒号，在block块里面就可以定义属性和方法了。当一个类定义完之后，就产生了一个类对象。类对象支持两种操作：引用和实例化。引用操作是通过类对象去调用类中的属性或者方法，而实例化是产生出一个类对象的实例，称作实例对象。比如定义了一个people类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos;       #定义了一个属性 </div><div class="line">    #定义了一个方法 </div><div class="line">    def printName(self): </div><div class="line">        print self.name</div></pre></td></tr></table></figure>
<p> people类定义完成之后就产生了一个全局的类对象，可以通过类对象来访问类中的属性和方法了。当通过people.name（至于为什么可以直接这样访问属性后面再解释，这里只要理解类对象这个概念就行了）来访问时，people.name中的people称为类对象，这点和C++中的有所不同。当然还可以进行实例化操作，p=people( )，这样就产生了一个people的实例对象，此时也可以通过实例对象p来访问属性或者方法了(p.name).<br>　　理解了类、类对象和实例对象的区别之后，我们来了解一下Python中属性、方法和函数的区别。<br>　　在上面代码中注释的很清楚了，name是一个属性，printName( )是一个方法，与某个对象进行绑定的函数称作为方法。一般在类里面定义的函数与类对象或者实例对象绑定了，所以称作为方法；而在类外定义的函数一般没有同对象进行绑定，就称为函数。</p>
<h1 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h1><p>在类中我们可以定义一些属性，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos; </div><div class="line">    age = 12 </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.name,p.age</div></pre></td></tr></table></figure></p>
<p>　　定义了一个people类，里面定义了name和age属性，默认值分别为’jack’和12。在定义了类之后，就可以用来产生实例化对象了，这句p = people( )实例化了一个对象p，然后就可以通过p来读取属性了。这里的name和age都是公有的，可以直接在类外通过对象名访问，如果想定义成私有的，则需在前面加2个下划线 ‘ __’。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    __name = &apos;jack&apos; </div><div class="line">    __age = 12 </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.__name,p.__age</div></pre></td></tr></table></figure></p>
<p>这段程序运行会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last): </div><div class="line">  File &quot;C:/PycharmProjects/FirstProject/oop.py&quot;, line 6, in &lt;module&gt; </div><div class="line">    print p.__name,p.__age </div><div class="line">AttributeError: people instance has no attribute &apos;__name</div></pre></td></tr></table></figure></p>
<p>　　提示找不到该属性，因为私有属性是不能够在类外通过对象名来进行访问的。在Python中没有像C++中public和private这些关键字来区别公有属性和私有属性，它是以属性命名方式来区分，如果在属性名前面加了2个下划线’__’，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。</p>
<h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h1><p>　　在类中可以根据需要定义一些方法，定义方法采用def关键字，在类中定义的方法至少会有一个参数，，一般以名为’self’的变量作为该参数（用其他名称也可以），而且需要作为第一个参数。下面看个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    __name = &apos;jack&apos; </div><div class="line">    __age = 12 </div><div class="line"> </div><div class="line">    def getName(self): </div><div class="line">        return self.__name </div><div class="line">    def getAge(self): </div><div class="line">        return self.__age </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.getName(),p.getAge()</div></pre></td></tr></table></figure></p>
<p>　　如果对self不好理解的话，可以把它当做C++中类里面的this指针一样理解，就是对象自身的意思，在用某个对象调用该方法时，就将该对象作为第一个参数传递给self。</p>
<h1 id="4-类中内置的方法"><a href="#4-类中内置的方法" class="headerlink" title="4.类中内置的方法"></a>4.类中内置的方法</h1><p>　　在Python中有一些内置的方法，这些方法命名都有比较特殊的地方（其方法名以2个下划线开始然后以2个下划线结束）。类中最常用的就是构造方法和析构方法。<br>　　构造方法<strong>init</strong>(self,….)：在生成对象时调用，可以用来进行一些初始化操作，不需要显示去调用，系统会默认去执行。构造方法支持重载，如果用户自己没有重新定义构造方法，系统就自动执行默认的构造方法。<br>　　析构方法<strong>del</strong>(self)：在释放对象时调用，支持重载，可以在里面进行一些释放资源的操作，不需要显示调用。<br>　　还有其他的一些内置方法，比如 <strong>cmp</strong>( ), <strong>len( )</strong>等。下面是常用的内置方法：</p>
<table>
<thead>
<tr>
<th>内置方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>init</strong>(self,…)</td>
<td>初始化对象，在创建新对象时调用</td>
</tr>
<tr>
<td><strong>del</strong>(self)</td>
<td>释放对象，在对象被删除之前调用</td>
</tr>
<tr>
<td><strong>new</strong>(cls,<em>args,*</em>kwd)</td>
<td>实例的生成操作</td>
</tr>
<tr>
<td><strong>str</strong>(self)</td>
<td>在使用print语句时被调用</td>
</tr>
<tr>
<td><strong>getitem</strong>(self,key)</td>
<td>获取序列的索引key对应的值，等价于seq[key]</td>
</tr>
<tr>
<td><strong>len</strong>(self)</td>
<td>在调用内联函数len()时被调用</td>
</tr>
<tr>
<td><strong>cmp</strong>(stc,dst)</td>
<td>比较两个对象src和dst</td>
</tr>
<tr>
<td><strong>getattr</strong>(s,name)</td>
<td>获取属性的值</td>
</tr>
<tr>
<td><strong>setattr</strong>(s,name,value)</td>
<td>设置属性的值</td>
</tr>
<tr>
<td><strong>delattr</strong>(s,name)</td>
<td>删除name属性</td>
</tr>
<tr>
<td><strong>getattribute</strong>()</td>
<td><strong>getattribute</strong>()功能与<strong>getattr</strong>()类似</td>
</tr>
<tr>
<td><strong>gt</strong>(self,other)</td>
<td>判断self对象是否大于other对象</td>
</tr>
<tr>
<td><strong>lt</strong>(slef,other)</td>
<td>判断self对象是否小于other对象</td>
</tr>
<tr>
<td><strong>ge</strong>(slef,other)</td>
<td>判断self对象是否大于或者等于other对象</td>
</tr>
<tr>
<td><strong>le</strong>(slef,other)</td>
<td>判断self对象是否小于或者等于other对象</td>
</tr>
<tr>
<td><strong>eq</strong>(slef,other)</td>
<td>判断self对象是否等于other对象</td>
</tr>
<tr>
<td><strong>call</strong>(self,*args)</td>
<td>把实例对象作为函数调用</td>
</tr>
</tbody>
</table>
<p>　　<strong>init</strong>():<strong>init</strong>方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的初始化。注意，这个名称的开始和结尾都是双下划线。代码例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Filename: class_init.py </div><div class="line">class Person: </div><div class="line">    def __init__(self, name): </div><div class="line">        self.name = name </div><div class="line">    def sayHi(self): </div><div class="line">        print &apos;Hello, my name is&apos;, self.name </div><div class="line"> </div><div class="line">p = Person(&apos;Swaroop&apos;) </div><div class="line">p.sayHi() </div><div class="line"> </div><div class="line">输出： </div><div class="line">Hello, my name is Swaroop</div></pre></td></tr></table></figure>
<p>　　<strong>new</strong>():<strong>new</strong>()在<strong>init</strong>()之前被调用，用于生成实例对象。利用这个方法和类属性的特性可以实现设计模式中的单例模式。单例模式是指创建唯一对象吗，单例模式设计的类只能实例化一个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Singleton(object): </div><div class="line">    __instance = None                       # 定义实例 </div><div class="line"> </div><div class="line">    def __init__(self): </div><div class="line">        pass </div><div class="line"> </div><div class="line">    def __new__(cls, *args, **kwd):         # 在__init__之前调用 </div><div class="line">        if Singleton.__instance is None:    # 生成唯一实例 </div><div class="line">            Singleton.__instance = object.__new__(cls, *args, **kwd) </div><div class="line">        return Singleton.__instance</div></pre></td></tr></table></figure></p>
<p>　　<strong>getattr</strong>()、<strong>setattr</strong>()和<strong>getattribute</strong>():当读取对象的某个属性时，python会自动调用<strong>getattr</strong>()方法。例如，fruit.color将转换为fruit.<strong>getattr</strong>(color)。当使用赋值语句对属性进行设置时，python会自动调用<strong>setattr</strong>()方法。<strong>getattribute</strong>()的功能与<strong>getattr</strong>()类似，用于获取属性的值。但是<strong>getattribute</strong>()能提供更好的控制，代码更健壮。注意，python中并不存在<strong>setattribute</strong>()方法。代码例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class Fruit(object): </div><div class="line">    def __init__(self, color=&quot;red&quot;, price=0): </div><div class="line">        self.__color = color </div><div class="line">        self.__price = price </div><div class="line"> </div><div class="line">    def __getattribute__(self, item):              # &lt;span style=&quot;font-family:宋体;font-size:12px;&quot;&gt;获取属性的方法&lt;/span&gt; </div><div class="line">        return object.__getattribute__(self, item) </div><div class="line"> </div><div class="line">    def __setattr__(self, key, value): </div><div class="line">        self.__dict__[key] = value </div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;: </div><div class="line">    fruit = Fruit(&quot;blue&quot;, 10) </div><div class="line">    print fruit.__dict__.get(&quot;_Fruit__color&quot;)    # &lt;span style=&quot;font-family:宋体;font-size:12px;&quot;&gt;获取color属性&lt;/span&gt; </div><div class="line">    fruit.__dict__[&quot;_Fruit__price&quot;] = 5 </div><div class="line">    print fruit.__dict__.get(&quot;_Fruit__price&quot;)    # &lt;span style=&quot;font-family:宋体;font-size:12px;&quot;&gt;获取price属性&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p>Python不允许实例化的类访问私有数据，但你可以使用object._className<strong>attrName访问这些私有属性。
　　</strong>getitem<strong>():如果类把某个属性定义为序列，可以使用</strong>getitem<strong>()输出序列属性中的某个元素.假设水果店中销售多钟水果，可以通过</strong>getitem__()方法获取水果店中的没种水果。代码例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class FruitShop: </div><div class="line">     def __getitem__(self, i):      # 获取水果店的水果 </div><div class="line">         return self.fruits[i]       </div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;: </div><div class="line">    shop = FruitShop() </div><div class="line">    shop.fruits = [&quot;apple&quot;, &quot;banana&quot;] </div><div class="line">    print shop[1] </div><div class="line">    for item in shop:               # 输出水果店的水果 </div><div class="line">        print item,</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">banana </div><div class="line">apple banana</div></pre></td></tr></table></figure></p>
<p>　　<strong>str</strong>():<strong>str</strong>()用于表示对象代表的含义，返回一个字符串.实现了<strong>str</strong>()方法后，可以直接使用print语句输出对象，也可以通过函数str()触发<strong>str</strong>()的执行。这样就把对象和字符串关联起来，便于某些程序的实现，可以用这个字符串来表示某个类。代码例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class Fruit:      </div><div class="line">    &apos;&apos;&apos;&apos;&apos;Fruit类&apos;&apos;&apos;               #为Fruit类定义了文档字符串 </div><div class="line">    def __str__(self):          # 定义对象的字符串表示 </div><div class="line">        return self.__doc__ </div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;: </div><div class="line">    fruit = Fruit() </div><div class="line">    print str(fruit)            # 调用内置函数str()触发__str__()方法，输出结果为:Fruit类 </div><div class="line">    print fruit                 #直接输出对象fruit,返回__str__()方法的值，输出结果为:Fruit类</div></pre></td></tr></table></figure></p>
<p>　<strong>call</strong>():在类中实现<strong>call</strong>()方法，可以在对象创建时直接返回<strong>call</strong>()的内容。使用该方法可以模拟静态方法。代码例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class Fruit: </div><div class="line">    class Growth:        # 内部类 </div><div class="line">        def __call__(self): </div><div class="line">            print &quot;grow ...&quot; </div><div class="line"> </div><div class="line">    grow = Growth()      # 调用Growth()，此时将类Growth作为函数返回,即为外部类Fruit定义方法grow(),grow()将执行__call__()内的代码 </div><div class="line">if __name__ == &apos;__main__&apos;: </div><div class="line">    fruit = Fruit() </div><div class="line">    fruit.grow()         # 输出结果：grow ... </div><div class="line">    Fruit.grow()         # 输出结果：grow ...</div></pre></td></tr></table></figure></p>
<h1 id="5-类属性、实例属性、类方法、实例方法以及静态方法"><a href="#5-类属性、实例属性、类方法、实例方法以及静态方法" class="headerlink" title="5.类属性、实例属性、类方法、实例方法以及静态方法"></a>5.类属性、实例属性、类方法、实例方法以及静态方法</h1><p>　　在了解了类基本的东西之后，下面看一下python中这几个概念的区别。<br>　　先来谈一下类属性和实例属性<br>　　在前面的例子中我们接触到的就是类属性，顾名思义，类属性就是类对象所拥有的属性，它被所有类对象的实例对象所共有，在内存中只存在一个副本，这个和C++中类的静态成员变量有点类似。对于公有的类属性，在类外可以通过类对象和实例对象访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos;  #公有的类属性 </div><div class="line">    __age = 12     #私有的类属性 </div><div class="line"> </div><div class="line">p = people() </div><div class="line"> </div><div class="line">print p.name             #正确 </div><div class="line">print people.name        #正确 </div><div class="line">print p.__age            #错误，不能在类外通过实例对象访问私有的类属性 </div><div class="line">print people.__age       #错误，不能在类外通过类对象访问私有的类属性</div></pre></td></tr></table></figure></p>
<p>　实例属性是不需要在类中显示定义的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos; </div><div class="line"> </div><div class="line">p = people() </div><div class="line">p.age =12 </div><div class="line">print p.name    #正确 </div><div class="line">print p.age     #正确 </div><div class="line"> </div><div class="line">print people.name    #正确 </div><div class="line">print people.age     #错误</div></pre></td></tr></table></figure></p>
<p>　　在类外对类对象people进行实例化之后，产生了一个实例对象p，然后p.age = 12这句给p添加了一个实例属性age，赋值为12。这个实例属性是实例对象p所特有的，注意，类对象people并不拥有它（所以不能通过类对象来访问这个age属性）。当然还可以在实例化对象的时候给age赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    name = &apos;jack&apos; </div><div class="line"> </div><div class="line">    #__init__()是内置的构造方法，在实例化对象时自动调用 </div><div class="line">    def __init__(self,age): </div><div class="line">        self.age = age </div><div class="line"> </div><div class="line">p = people(12) </div><div class="line">print p.name    #正确 </div><div class="line">print p.age     #正确 </div><div class="line"> </div><div class="line">print people.name    #正确 </div><div class="line">print people.age     #错误</div></pre></td></tr></table></figure></p>
<p>　　如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line"> </div><div class="line">print people.country </div><div class="line">p = people() </div><div class="line">print p.country </div><div class="line">p.country = &apos;japan&apos;  </div><div class="line">print p.country      #实例属性会屏蔽掉同名的类属性 </div><div class="line">print people.country </div><div class="line">del p.country    #删除实例属性 </div><div class="line">print p.country</div></pre></td></tr></table></figure>
<p>　　下面来看一下类方法、实例方法和静态方法的区别。<br>　　类方法：是类对象所拥有的方法，需要用修饰器”@classmethod”来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以”cls”作为第一个参数（当然可以用其他名称的变量作为其第一个参数，但是大部分人都习惯以’cls’作为第一个参数的名字，就最好用’cls’了），能够通过实例对象和类对象去访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line">    #类方法，用classmethod来进行修饰 </div><div class="line">    @classmethod </div><div class="line">    def getCountry(cls): </div><div class="line">        return cls.country </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.getCountry()    #可以用过实例对象引用 </div><div class="line">print people.getCountry()    #可以通过类对象引用</div></pre></td></tr></table></figure></p>
<p>类方法还有一个用途就是可以对类属性进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line">    #类方法，用classmethod来进行修饰 </div><div class="line">    @classmethod </div><div class="line">    def getCountry(cls): </div><div class="line">        return cls.country </div><div class="line"> </div><div class="line">    @classmethod </div><div class="line">    def setCountry(cls,country): </div><div class="line">        cls.country = country </div><div class="line"> </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.getCountry()    #可以用过实例对象引用 </div><div class="line">print people.getCountry()    #可以通过类对象引用 </div><div class="line"> </div><div class="line">p.setCountry(&apos;japan&apos;)    </div><div class="line"> </div><div class="line">print p.getCountry()    </div><div class="line">print people.getCountry() </div><div class="line"></div><div class="line">#运行结果：</div><div class="line">china </div><div class="line">china </div><div class="line">japan </div><div class="line">japan</div></pre></td></tr></table></figure></p>
<p>　结果显示在用类方法对类属性修改之后，通过类对象和实例对象访问都发生了改变。<br>　实例方法：在类中最常定义的成员方法，它至少有一个参数并且必须以实例对象作为其第一个参数，一般以名为’self’的变量作为第一个参数（当然可以以其他名称的变量作为第一个参数）。在类外实例方法只能通过实例对象去调用，不能通过其他方式去调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line">    #实例方法 </div><div class="line">    def getCountry(self): </div><div class="line">        return self.country </div><div class="line"> </div><div class="line"> </div><div class="line">p = people() </div><div class="line">print p.getCountry()         #正确，可以用过实例对象引用 </div><div class="line">print people.getCountry()    #错误，不能通过类对象引用实例方法</div></pre></td></tr></table></figure></p>
<p>　静态方法：需要通过修饰器”@staticmethod”来进行修饰，静态方法不需要多定义参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class people: </div><div class="line">    country = &apos;china&apos; </div><div class="line"> </div><div class="line">    @staticmethod </div><div class="line">    #静态方法 </div><div class="line">    def getCountry(): </div><div class="line">        return people.country </div><div class="line"> </div><div class="line"> </div><div class="line">print people.getCountry()</div></pre></td></tr></table></figure></p>
<p>　对于类属性和实例属性，如果在类方法中引用某个属性，该属性必定是类属性，而如果在实例方法中引用某个属性（不作更改），并且存在同名的类属性，此时若实例对象有该名称的实例属性，则实例属性会屏蔽类属性，即引用的是实例属性，若实例对象没有该名称的实例属性，则引用的是类属性；如果在实例方法更改某个属性，并且存在同名的类属性，此时若实例对象有该名称的实例属性，则修改的是实例属性，若实例对象没有该名称的实例属性，则会创建一个同名称的实例属性。想要修改类属性，如果在类外，可以通过类对象修改，如果在类里面，只有在类方法中进行修改。</p>
<h1 id="6-继承和多重继承"><a href="#6-继承和多重继承" class="headerlink" title="6.继承和多重继承"></a>6.继承和多重继承</h1><p>　上面谈到了类的基本定义和使用方法，这只体现了面向对象编程的三大特点之一：封装。下面就来了解一下另外两大特征：继承和多态。<br>　在Python中，如果需要的话，可以让一个类去继承一个类，被继承的类称为父类或者超类、也可以称作基类，继承的类称为子类。并且Python支持多继承，能够让一个子类有多个父类。<br>　Python中类的继承定义基本形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#父类 </div><div class="line">class superClassName: </div><div class="line">    block </div><div class="line"> </div><div class="line">#子类 </div><div class="line">class subClassName(superClassName): </div><div class="line">    block</div></pre></td></tr></table></figure></p>
<p>　　在定义一个类的时候，可以在类名后面紧跟一对括号，在括号中指定所继承的父类，如果有多个父类，多个父类名之间用逗号隔开。以大学里的学生和老师举例，可以定义一个父类UniversityMember，然后类Student和类Teacher分别继承类UniversityMember：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">class UniversityMember: </div><div class="line"> </div><div class="line">    def __init__(self,name,age): </div><div class="line">        self.name = name </div><div class="line">        self.age = age </div><div class="line"> </div><div class="line">    def getName(self): </div><div class="line">        return self.name </div><div class="line"> </div><div class="line">    def getAge(self): </div><div class="line">        return self.age </div><div class="line"> </div><div class="line">class Student(UniversityMember): </div><div class="line"> </div><div class="line">    def __init__(self,name,age,sno,mark): </div><div class="line">        UniversityMember.__init__(self,name,age)     #注意要显示调用父类构造方法，并传递参数self </div><div class="line">        self.sno = sno </div><div class="line">        self.mark = mark </div><div class="line"> </div><div class="line">    def getSno(self): </div><div class="line">        return self.sno </div><div class="line"> </div><div class="line">    def getMark(self): </div><div class="line">        return self.mark </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">class Teacher(UniversityMember): </div><div class="line"> </div><div class="line">    def __init__(self,name,age,tno,salary): </div><div class="line">        UniversityMember.__init__(self,name,age) </div><div class="line">        self.tno = tno </div><div class="line">        self.salary = salary </div><div class="line"> </div><div class="line">    def getTno(self): </div><div class="line">        return self.tno </div><div class="line"> </div><div class="line">    def getSalary(self): </div><div class="line">        return self.salary</div></pre></td></tr></table></figure>
<p>　　在大学中的每个成员都有姓名和年龄，而学生有学号和分数这2个属性，老师有教工号和工资这2个属性，从上面的代码中可以看到：<br>　　1）在Python中，如果父类和子类都重新定义了构造方法<strong>init( )</strong>，在进行子类实例化的时候，子类的构造方法不会自动调用父类的构造方法，必须在子类中显示调用。<br>　　2）如果需要在子类中调用父类的方法，需要以”父类名.方法“这种方式调用，以这种方式调用的时候，注意要传递self参数过去。<br>　　对于继承关系，子类继承了父类所有的公有属性和方法，可以在子类中通过父类名来调用，而对于私有的属性和方法，子类是不进行继承的，因此在子类中是无法通过父类名来访问的。<br>　　Python支持多重继承。对于多重继承，比如<br>　　class SubClass(SuperClass1,SuperClass2)<br>　　此时有一个问题就是如果SubClass没有重新定义构造方法，它会自动调用哪个父类的构造方法？这里记住一点：以第一个父类为中心。如果SubClass重新定义了构造方法，需要显示去调用父类的构造方法，此时调用哪个父类的构造方法由你自己决定；若SubClass没有重新定义构造方法，则只会执行第一个父类的构造方法。并且若SuperClass1和SuperClass2中有同名的方法，通过子类的实例化对象去调用该方法时调用的是第一个父类中的方法。</p>
<h1 id="7-多态"><a href="#7-多态" class="headerlink" title="7.多态"></a>7.多态</h1><p>　　多态即多种形态，在运行时确定其状态，在编译阶段无法确定其类型，这就是多态。Python中的多态和Java以及C++中的多态有点不同，Python中的变量是弱类型的，在定义时不用指明其类型，它会根据需要在运行时确定变量的类型（个人觉得这也是多态的一种体现），并且Python本身是一种解释性语言，不进行预编译，因此它就只在运行时确定其状态，故也有人说Python是一种多态语言。在Python中很多地方都可以体现多态的特性，比如内置函数len(object)，len函数不仅可以计算字符串的长度，还可以计算列表、元组等对象中的数据个数，这里在运行时通过参数类型确定其具体的计算过程，正是多态的一种体现。这有点类似于函数重载（一个编译单元中有多个同名函数，但参数不同），相当于为每种类型都定义了一个len函数。这是典型的多态表现。有些朋友提出Python不支持多态，我是完全不赞同的。<br>　　本质上，多态意味着可以对不同的对象使用同样的操作，但它们可能会以多种形态呈现出结果。len(object)函数就体现了这一点。在C++、Java、C#这种编译型语言中，由于有编译过程，因此就鲜明地分成了运行时多态和编译时多态。运行时多态是指允许父类指针或名称来引用子类对象，或对象方法，而实际调用的方法为对象的类类型方法，这就是所谓的动态绑定。编译时多态有模板或范型、方法重载（overload）、方法重写（override）等。而Python是动态语言，动态地确定类型信息恰恰体现了多态的特征。在Python中，任何不知道对象到底是什么类型，但又需要对象做点什么的时候，都会用到多态。<br>　　能够直接说明多态的两段示例代码如下：</p>
<h2 id="多态方法"><a href="#多态方法" class="headerlink" title="多态方法"></a>多态方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># -*- coding: UTF-8 -*- </div><div class="line"> </div><div class="line">_metaclass_=type # 确定使用新式类 </div><div class="line">class calculator: </div><div class="line"> </div><div class="line">    def count(self,args): </div><div class="line">        return 1 </div><div class="line"> </div><div class="line">calc=calculator() #自定义类型 </div><div class="line"> </div><div class="line">from random import choice </div><div class="line">obj=choice([&apos;hello,world&apos;,[1,2,3],calc]) #obj是随机返回的 类型不确定 </div><div class="line">print type(obj) </div><div class="line">print obj.count(&apos;a&apos;) #方法多态</div></pre></td></tr></table></figure>
<p>　　对于一个临时对象obj，它通过Python的随机函数取出来，不知道具体类型（是字符串、元组还是自定义类型），都可以调用count方法进行计算，至于count由谁（哪种类型）去做怎么去实现我们并不关心。<br>　　有一种称为”鸭子类型（duck typing）“的东西，讲的也是多态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">_metaclass_=type # 确定使用新式类 </div><div class="line">class Duck: </div><div class="line">    def quack(self):  </div><div class="line">        print &quot;Quaaaaaack!&quot; </div><div class="line">    def feathers(self):  </div><div class="line">        print &quot;The duck has white and gray feathers.&quot; </div><div class="line"> </div><div class="line">class Person: </div><div class="line">    def quack(self): </div><div class="line">        print &quot;The person imitates a duck.&quot; </div><div class="line">    def feathers(self):  </div><div class="line">        print &quot;The person takes a feather from the ground and shows it.&quot; </div><div class="line"> </div><div class="line">def in_the_forest(duck): </div><div class="line">    duck.quack() </div><div class="line">    duck.feathers() </div><div class="line"> </div><div class="line">def game(): </div><div class="line">    donald = Duck() </div><div class="line">    john = Person() </div><div class="line">    in_the_forest(donald) </div><div class="line">    in_the_forest(john) </div><div class="line"> </div><div class="line">game()</div></pre></td></tr></table></figure></p>
<p>　　就in_the_forest函数而言，参数对象是一个鸭子类型，它实现了方法多态。但是实际上我们知道，从严格的抽象来讲，Person类型和Duck完全风马牛不相及。</p>
<h2 id="多态运算符"><a href="#多态运算符" class="headerlink" title="多态运算符"></a>多态运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def add(x,y): </div><div class="line">    return x+y </div><div class="line"> </div><div class="line">print add(1,2) #输出3 </div><div class="line"> </div><div class="line">print add(&quot;hello,&quot;,&quot;world&quot;) #输出hello,world </div><div class="line"> </div><div class="line">print add(1,&quot;abc&quot;) #抛出异常 TypeError: unsupported operand type(s) for +: &apos;int&apos; and &apos;str&apos;</div></pre></td></tr></table></figure>
<p>　　上例中，显而易见，Python的加法运算符是”多态“的，理论上，我们实现的add方法支持任意支持加法的对象，但是我们不用关心两个参数x和y具体是什么类型。<br>　　Python同样支持运算符重载，实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Vector: </div><div class="line">   def __init__(self, a, b): </div><div class="line">      self.a = a </div><div class="line">      self.b = b </div><div class="line"> </div><div class="line">   def __str__(self): </div><div class="line">      return &apos;Vector (%d, %d)&apos; % (self.a, self.b) </div><div class="line"> </div><div class="line">   def __add__(self,other): </div><div class="line">      return Vector(self.a + other.a, self.b + other.b) </div><div class="line"> </div><div class="line">v1 = Vector(2,10) </div><div class="line">v2 = Vector(5,-2) </div><div class="line">print v1 + v2</div></pre></td></tr></table></figure></p>
<p>　　一两个示例代码当然不能从根本上说明多态。普遍认为面向对象最有价值最被低估的特征其实是多态。我们所理解的多态的实现和子类的虚函数地址绑定有关系，多态的效果其实和函数地址运行时动态绑定有关。在C++, Java, C#中实现多态的方式通常有重写和重载两种，从上面两段代码，我们其实可以分析得出Python中实现多态也可以变相理解为重写和重载。在Python中很多内置函数和运算符都是多态的。</p>
<p>参考文献：<br><a href="http://www.cnblogs.com/dolphin0520/archive/2013/03/29/2986924.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/archive/2013/03/29/2986924.html</a><br><a href="http://www.cnblogs.com/jeffwongishandsome/archive/2012/10/06/2713258.html" target="_blank" rel="external">http://www.cnblogs.com/jeffwongishandsome/archive/2012/10/06/2713258.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/python进程之进程间通讯——消息队列Queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/python进程之进程间通讯——消息队列Queue/" itemprop="url">
                  python进程之进程间通讯——消息队列Queue
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul>
<li>Queue：是一个消息队列，队列的长度可为无限或者有限</li>
<li>用于父子进程通讯，两个没有关系的进程不能使用Queue通信</li>
<li>使用实例： from mulitprocessing import Queue</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/queue/1.png" alt=""></p>
<ul>
<li>进程之间同步：lock.acquire</li>
<li>当多个进程同时对队列写的时候需要进行同步，保证一个时刻只有一个进程对队列进行写操作</li>
</ul>
<h1 id="2-查看Queue帮助"><a href="#2-查看Queue帮助" class="headerlink" title="2.查看Queue帮助"></a>2.查看Queue帮助</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [36]: from multiprocessing import Queue</div><div class="line">In [37]: help(Queue)</div><div class="line">Help on function Queue in module multiprocessing:</div><div class="line"> </div><div class="line">Queue(maxsize=0)</div><div class="line">    Returns a queue object</div></pre></td></tr></table></figure>
<h1 id="3-Queue常用方法"><a href="#3-Queue常用方法" class="headerlink" title="3.Queue常用方法"></a>3.Queue常用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">In [38]: q = Queue()</div><div class="line"> </div><div class="line">In [39]: q.</div><div class="line">q.cancel_join_thread  </div><div class="line">q.empty               </div><div class="line">q.get                         #取出队列中的消息       </div><div class="line">q.join_thread         </div><div class="line">q.put_nowait</div><div class="line">q.close               </div><div class="line">q.full                </div><div class="line">q.get_nowait          </div><div class="line">q.put                        #向队列中放入消息     </div><div class="line">q.qsize</div></pre></td></tr></table></figure>
<h1 id="4-Queue举例"><a href="#4-Queue举例" class="headerlink" title="4.Queue举例"></a>4.Queue举例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line">from multiprocessing import Queue</div><div class="line"> </div><div class="line">Qmsg = Queue()                #创建一个队列</div><div class="line">pid = os.fork()                    #启动子进程</div><div class="line"> </div><div class="line">if pid==0:                                #说明是子进程</div><div class="line">        msg = Qmsg.get()                #从队列中获取数据</div><div class="line">        print(msg)</div><div class="line">else:                                #父进程</div><div class="line">        Qmsg.put(&quot;msg 1&quot;)                #向队列中放入数据</div><div class="line">        os.wait()                            #等待子进程退出</div><div class="line"></div><div class="line"></div><div class="line">-----------------------------------------------------------------------------------------------------------------</div><div class="line">[root@backup python]# vim queue2.py</div><div class="line"> </div><div class="line">import time</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line">from multiprocessing import Queue,Process</div><div class="line">import time</div><div class="line"> </div><div class="line">Qmsg = Queue()                                       #创建队列</div><div class="line"> </div><div class="line">def child_func(name):</div><div class="line">        print(&quot;child pid=&#123;0&#125;&quot;.format(os.getpid()))        #打印子进程的pid</div><div class="line">        msg = Qmsg.get()                                    #获取队列数据</div><div class="line">        print(&quot;name=&#123;0&#125;,msg=&#123;1&#125;&quot;.format(name,msg))</div><div class="line"> </div><div class="line">print(&quot;Main pid = &#123;0&#125;&quot;.format(os.getpid()))        #打印父进程的pid</div><div class="line"> </div><div class="line">p = Process(target=child_func,args=(&quot;chilid_1&quot;,))        #创建一个子进程，并传递参数</div><div class="line">Qmsg.put(&quot;msg_1&quot;)                                #向队列中放入数据</div><div class="line">p.start()                                            #开启进程</div><div class="line">p.join()                            #等待子进程结束</div><div class="line"> </div><div class="line">#执行                                                                                                                                                                                                          </div><div class="line">[root@backup python]# python queue2.py</div><div class="line">Main pid = 3742</div><div class="line">child pid=3744</div><div class="line">name=chilid_1,msg=msg_1</div></pre></td></tr></table></figure>
<p>将start方法换成run方法，那么child_func相当于在主进程中执行，此时并没有开一个子进程</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/queue/2.png" alt=""></p>
<h1 id="5-Lock锁的使用"><a href="#5-Lock锁的使用" class="headerlink" title="5.Lock锁的使用"></a>5.Lock锁的使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">In [39]: from multiprocessing import Lock                    #导入模块</div><div class="line">In [40]: help(Lock)</div><div class="line">Help on function Lock in module multiprocessing:</div><div class="line"> </div><div class="line">Lock()</div><div class="line">    Returns a non-recursive lock object</div><div class="line"> </div><div class="line"> </div><div class="line">In [41]: l = Lock()</div><div class="line">In [43]: l.                                        #其中的方法</div><div class="line">l.acquire  l.release                         #获取锁、释放锁</div></pre></td></tr></table></figure>
<h1 id="6-解决多进程之间的互斥问题"><a href="#6-解决多进程之间的互斥问题" class="headerlink" title="6.解决多进程之间的互斥问题"></a>6.解决多进程之间的互斥问题</h1><p>加上1s的延时，则当前进程会被挂起，去执行其他的进程，所以打印的进程消息将不会有序 ，挂起之后，子进程得到锁的机会是随机的，但是在一个子进程中，因为有锁的存在，所以的能够保证一个进程中的所有的内容会一起执行，以下是解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">[root@backup python]# cat queue3.py      </div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os                                            #导入相应的模块</div><div class="line">from multiprocessing import Queue,Process,Lock</div><div class="line">import time</div><div class="line"> </div><div class="line">Qmsg = Queue()</div><div class="line">lock = Lock()</div><div class="line"> </div><div class="line"> </div><div class="line">def child_func(name):</div><div class="line">        lock.acquire()                                                    #加锁</div><div class="line"> </div><div class="line">        Qmsg.put(&quot;child_&quot;+str(name)+&quot;_msg_1:&quot;+&quot;Pid=&quot;+str(os.getpid))</div><div class="line">        time.sleep(1)</div><div class="line">        Qmsg.put(&quot;child_&quot;+str(name)+&quot;_msg_2:&quot;+&quot;Pid=&quot;+str(os.getpid))</div><div class="line"> </div><div class="line">        lock.release()                                                #释放锁，这样就能保证每一个子进程中的两次put是相邻放入到队列中的</div><div class="line"> </div><div class="line"> </div><div class="line">listp = []</div><div class="line">for i in range(10):</div><div class="line">        p = Process(target=child_func, args=(i,))                        #创建子进程</div><div class="line">        p.start()                                    #开启子进程</div><div class="line">        listp.append(p)</div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg = Qmsg.get()                                    #获取队列消息</div><div class="line">        print(msg)                                #打印</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        listp[i].join()                           #等待子进程结束</div><div class="line">-------------------------------------------------------------------------------------------------</div><div class="line">#执行结果</div><div class="line">[root@backup python]# python queue3.py</div><div class="line">child_0_msg_1:Pid=&lt;built-in function getpid&gt;                    #child_i_msg 总是在一起执行</div><div class="line">child_0_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_3_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_3_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_4_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_4_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_5_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_5_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_2_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_2_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_1_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_1_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_6_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_6_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_7_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_7_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_9_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_9_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_8_msg_1:Pid=&lt;built-in function getpid&gt;</div><div class="line">child_8_msg_2:Pid=&lt;built-in function getpid&gt;</div><div class="line">^CTraceback (most recent call last):</div><div class="line">  File &quot;queue3.py&quot;, line 28, in &lt;module&gt;</div><div class="line">    msg = Qmsg.get()</div><div class="line">  File &quot;/usr/lib/python2.6/multiprocessing/queues.py&quot;, line 91, in get</div><div class="line">    res = self._recv()</div><div class="line">KeyboardInterrupt</div></pre></td></tr></table></figure></p>
<h1 id="7-使用Queue实现最简单的本地CS架构"><a href="#7-使用Queue实现最简单的本地CS架构" class="headerlink" title="7.使用Queue实现最简单的本地CS架构"></a>7.使用Queue实现最简单的本地CS架构</h1><p>读取客户端输入，并将数据保存到文件中，并在Server端回显</p>
<ul>
<li>基本思路：<ol>
<li>创建小心队列</li>
<li>创建子进程</li>
<li>子进程读取输入并放到消息队列中</li>
<li>父进程读取并处理消息</li>
</ol>
</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/queue/3.png" alt=""><br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/queue/4.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/python进程之进程间通讯——无名管道/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/python进程之进程间通讯——无名管道/" itemprop="url">
                  python进程之进程间通讯——无名管道
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>管道：是一种半双工的通信机制，他一端用来读，另一端用来写，管道只能用来在具有公共祖先的两个进程之间通信，管道通信消息先进先出的原理，<font color="red">并且数据只能被读取一次，当此段数据被读取后就会被清空，管道的实质是内存的一页（page）</font></li>
<li>相关函数：os.pipe()：返回读写通道文件描述符组成的元组（read_end，write_end 读端和写端)</li>
<li><p>管道示意图<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/1.png" alt=""></p>
</li>
<li><p>管道通讯示意图：</p>
</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/2.png" alt=""></p>
<ul>
<li>公共祖先：父进程和子进程，具有相同的父进程之间</li>
<li><p>无名管道实例：<br><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/3.png" alt=""></p>
</li>
<li><p>使用上面的方式，我们可以处理一堆父子进程，如果我们这里有N个子进程，而且全双工通讯，那么我们如何处理呢？</p>
<ul>
<li><p>如果要全双工通信（读写同时进行），那么要创建两条管道，因为如果父子进程之间只有一个管道的话，父进程写了之后要读，那么，就会有父进程读取到的是自己写的内容，而一旦内容被读取之后，管道中的内容就没有了，子进程就不会读取到，所以就会出现错乱的情况，解决的办法就是创建两条管道，父进程在一条管道中读，在另一条管道中写，同时子进程在一条管道中写，在另一条管道中读。但是这样的解决方式也是有弊端的，就是每增加一个子进程，就会有2条管道增加，而管道的数量是有上限的。</p>
</li>
<li><p>全双工：在父进程和每一个子进程之间创建两个管道，一条管道用于写，一条管道用于读</p>
</li>
<li>弊端：当两个没有关系的进程不能实现通讯，如下：</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/4.png" alt=""></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line">import time</div><div class="line"> </div><div class="line">p = os.pipe()                    #start a pipe</div><div class="line">pid = os.fork()        #开始一个子进程</div><div class="line"> </div><div class="line">if pid == 0:#only read ,so close write end</div><div class="line">        os.close(p[1])</div><div class="line">        while True:</div><div class="line">                msg = os.read(p[0],1024)</div><div class="line">                print(msg)</div><div class="line">                if msg == &apos;q&apos;:</div><div class="line">                        os.close(p[0])</div><div class="line">                        break</div><div class="line">else:</div><div class="line">        os.close(p[0])   #only write ,so close read end</div><div class="line">        while True:</div><div class="line">                str1 = raw_input(&quot;&gt;&quot;)</div><div class="line">                os.write(p[1],str1) #write &apos;str1&apos; to p[1]</div><div class="line">                if str1 == &apos;q&apos;:</div><div class="line">                        os.close(p[1])</div><div class="line">                        os.wait()       #wait subprocess exit</div><div class="line">                        break</div><div class="line">                time.sleep(1)   #sleep 1s</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/python进程之进程间通讯——命名管道/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/python进程之进程间通讯——命名管道/" itemprop="url">
                  python进程之进程间通讯——命名管道
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><ul>
<li>命名管道：无名管道的一个扩展，无名管道是程序运行时存在，命名管道是持久的，一旦创建，所有有权限进程都可以访问</li>
<li>命名管道是单向管道，只能以只读或只写方式打开，如果要实现双向通信，必须打开两个管道</li>
<li>命名管道创建：os.mkfifo(path) ，读写和操作文件一样</li>
<li>命名管道通信模型：</li>
</ul>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/pipe/5.png" alt=""></p>
<ul>
<li>代码示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#process1</div><div class="line">import os</div><div class="line">p_name = &quot;pipe1&quot;</div><div class="line">os.mkfifo(p_name)  </div><div class="line">try:</div><div class="line">    fp=open(p_name,&apos;w&apos;)    #写方式打开管道</div><div class="line">except IOError:</div><div class="line">    print &quot;open %s Error&quot; % p_name</div><div class="line">else:</div><div class="line">    msg = os.write(fp, &quot;hello python&quot;)    #发送消息</div><div class="line">finally:</div><div class="line">    if (fp):</div><div class="line">        fp.close()</div><div class="line"></div><div class="line"></div><div class="line">#process2</div><div class="line">import os</div><div class="line">p_name = &quot;pipe1&quot;</div><div class="line">os.mkfifo(p_name)    #创建管道,管道相当于文件描述符,所以可以像文件一样可以用open进行读写</div><div class="line">try:</div><div class="line">    fp=open(p_name,&apos;r&apos;)    #读方式打开管道</div><div class="line">except IOError:</div><div class="line">    print &quot;open %s Error&quot; % p_name</div><div class="line">else:</div><div class="line">    msg = os.read(fp, 1024)</div><div class="line">    print msg</div><div class="line">finally:</div><div class="line">    if (fp):</div><div class="line">        fp.close()</div></pre></td></tr></table></figure>
<ul>
<li>阻塞：自行设备操作时，如果不能获得资源就会挂起进程，知道获取资源后在进行操作，被挂起的进程进入休眠状态</li>
<li>非阻塞：执行设备操作时，如果不能获取资源直接返回，可以使用轮询的方式进行设备操作</li>
<li>一个管道可以多个进程打开，是否安全</li>
</ul>
<h1 id="2-os-access测试路径的访问权"><a href="#2-os-access测试路径的访问权" class="headerlink" title="2.os.access测试路径的访问权"></a>2.os.access测试路径的访问权</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">os.access(path, mode)</div><div class="line"> </div><div class="line">使用实际的uid和gid去测试路径的访问权。实际的uid和gid指的是用户登录到系统使用的uid和当前用户所在的gid，这和有效用户id和有效组id是有区别的，有效用户id和有效组id是对应于进程的。</div><div class="line"> </div><div class="line">mode参数指定测试路径的方式：</div><div class="line"> </div><div class="line">os.F_OK - 测试路径是否存在</div><div class="line"> </div><div class="line">os.R_OK - 测试文件是否可读</div><div class="line"> </div><div class="line">os.W_OK - 测试文件是否可写</div><div class="line"> </div><div class="line">os.X_OK - 测试文件是否可执行</div><div class="line"> </div><div class="line">其中的R_OK，W_OK，X_OK是可以使用OR操作合起来进行一起测试的。</div><div class="line"> </div><div class="line">#函数返回True如果测试成功，否则返回False。在系统的C API中可以使用access系统调用。</div></pre></td></tr></table></figure>
<h1 id="3-创建pipe，读写举例（以系统的open）"><a href="#3-创建pipe，读写举例（以系统的open）" class="headerlink" title="3.创建pipe，读写举例（以系统的open）"></a>3.创建pipe，读写举例（以系统的open）</h1><p> 如果进程以只读方式打开管道，那么会阻塞，直到有进程以只写方式打开管道为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">#写</div><div class="line">[root@backup python]# cat pipe_w.py</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os                    </div><div class="line"> </div><div class="line">p_name = &quot;./pipe&quot;                        #管道名称</div><div class="line">if os.access(p_name,os.F_OK)==False:                #判断路径是否存在        </div><div class="line">        os.mkfifo(p_name)                            #创建有名管道</div><div class="line"> </div><div class="line">print(&quot;before open&quot;)</div><div class="line"> </div><div class="line">fp_w = open(p_name,&apos;w&apos;)                        #以只写的方式打开一个管道文件，返回管道对象</div><div class="line"> </div><div class="line">print(&quot;end open&quot;)</div><div class="line"> </div><div class="line">msg = &quot;&quot;</div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg1 = raw_input(&quot;&gt;&quot;)</div><div class="line">        fp_w.write(msg1)                            #向管道中写入数据</div><div class="line">        fp_w.flush()                                #刷新缓存数据到管道中，因为使用的是系统的open函数打开的管道，所以相当于是C的方法，而C中是有缓存存在的</div><div class="line">        if msg1==&apos;q&apos;:</div><div class="line">                break</div><div class="line"> </div><div class="line">fp_w.close()</div><div class="line"></div><div class="line"></div><div class="line">---------------------------------------------</div><div class="line">#读</div><div class="line">[root@backup python]# cat pipe_r.py</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line"> </div><div class="line">p_name = &quot;./pipe&quot;</div><div class="line">if os.access(p_name,os.F_OK)==False:</div><div class="line">        os.mkfifo(p_name)                                        </div><div class="line"> </div><div class="line">print(&quot;before open&quot;)</div><div class="line"> </div><div class="line">fp_r = open(p_name,&apos;r&apos;)                # 其实open打开的虽然是管道，但是他相当于一个文件一样，用ls可以在本地看到</div><div class="line"> </div><div class="line">print(&quot;end open&quot;)</div><div class="line"> </div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg = fp_r.read(1)                            #每次读取一个字节</div><div class="line">        print(msg)</div><div class="line">        if msg == &apos;q&apos;:</div><div class="line">                break</div><div class="line">fp_r.close()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@backup python]# ll</div><div class="line">#os.mkfifo(p_name)    ，会生成一个pipe的文件</div><div class="line">prw-r--r-- 1 root root    0 10月  5 16:30 pipe</div></pre></td></tr></table></figure>
<h1 id="4-os-open-read-write简绍"><a href="#4-os-open-read-write简绍" class="headerlink" title="4.os.open/read/write简绍"></a>4.os.open/read/write简绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">In [1]: import os</div><div class="line"> </div><div class="line">In [2]: help(os.open)</div><div class="line">Help on built-in function open in module posix:</div><div class="line"> </div><div class="line">open(...)</div><div class="line">    open(filename, flag [, mode=0777]) -&gt; fd                            #返回fd，即文件描述符</div><div class="line"> </div><div class="line">    Open a file (for low level IO).</div><div class="line"> </div><div class="line">#flag 有以下方式：如  os.O_WRONLY(读写)    os.O_RDONLY（只读）    os.O_WRONLY （只写）</div><div class="line">In [3]: os.O_</div><div class="line">os.O_APPEND     os.O_DIRECT     os.O_EXCL       os.O_NOATIME    os.O_NONBLOCK   os.O_RSYNC      os.O_WRONLY    </div><div class="line">os.O_ASYNC      os.O_DIRECTORY  os.O_LARGEFILE  os.O_NOCTTY     os.O_RDONLY     os.O_SYNC      </div><div class="line">os.O_CREAT      os.O_DSYNC      os.O_NDELAY     os.O_NOFOLLOW   os.O_RDWR       os.O_TRUNC     </div><div class="line"> </div><div class="line">#read</div><div class="line">In [3]: help(os.read)</div><div class="line">Help on built-in function read in module posix:</div><div class="line"> </div><div class="line">read(...)</div><div class="line">    read(fd, buffersize) -&gt; string</div><div class="line"> </div><div class="line">    Read a file descriptor.            #读文件描述符</div><div class="line"> </div><div class="line"> </div><div class="line">#write </div><div class="line">In [4]: help(os.write)</div><div class="line">Help on built-in function write in module posix:</div><div class="line"> </div><div class="line">write(...)</div><div class="line">    write(fd, string) -&gt; byteswritten</div><div class="line"> </div><div class="line">    Write a string to a file descriptor.    #写string 到文件描述符</div><div class="line"> </div><div class="line">#close</div><div class="line">In [5]: help(os.close)</div><div class="line">Help on built-in function close in module posix:</div><div class="line"> </div><div class="line">close(...)</div><div class="line">    close(fd)</div><div class="line"> </div><div class="line">    Close a file descriptor (for low level IO).        #关闭一个文件描述符</div></pre></td></tr></table></figure>
<h1 id="5-创建pipe，读写举例（以os模块的open）"><a href="#5-创建pipe，读写举例（以os模块的open）" class="headerlink" title="5.创建pipe，读写举例（以os模块的open）"></a>5.创建pipe，读写举例（以os模块的open）</h1><p>使用os.open的方式打开，返回的是一个文件描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">#写</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line"> </div><div class="line">p_name = &quot;./pipe&quot;</div><div class="line">if os.access(p_name,os.F_OK)==False:</div><div class="line">        os.mkfifo(p_name)                    #没有就创建管道</div><div class="line"> </div><div class="line">print(&quot;before open&quot;)</div><div class="line"> </div><div class="line">fp_w = os.open(p_name, os.O_WRONLY)            #os.open返回一个文件描述符</div><div class="line"> </div><div class="line">print(&quot;end open&quot;)</div><div class="line"> </div><div class="line">msg = &quot;&quot;</div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg1 = raw_input(&quot;&gt;&quot;)</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        #fp_w.write(msg1)                        #如果使用的是os.open就不用刷新，os中并没有缓冲的存在，而是直接读取的。所以是写端写多少，在读端读多少</div><div class="line">        #fp_w.flush()</div><div class="line">        &apos;&apos;&apos;</div><div class="line">        os.write(fp_name,msg1)                   #向文件描述符中写</div><div class="line">        if msg1==&apos;q&apos;:</div><div class="line">                break</div><div class="line"> </div><div class="line"> </div><div class="line">os.close(fp_w)                            #关闭文件描述符</div><div class="line"></div><div class="line"></div><div class="line">---------------------------------------------------------------------</div><div class="line"></div><div class="line">#读</div><div class="line">[root@backup python]# cat pipe_os_r.py </div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">import os</div><div class="line"> </div><div class="line">p_name = &quot;./pipe&quot;</div><div class="line">if os.access(p_name,os.F_OK)==False:</div><div class="line">        os.mkfifo(p_name)</div><div class="line"> </div><div class="line">print(&quot;before open&quot;)</div><div class="line"> </div><div class="line">fp_r = os.open(p_name,os.O_RDONLY)                        #打开一个文件描述符</div><div class="line"> </div><div class="line">print(&quot;end open&quot;)</div><div class="line"> </div><div class="line"> </div><div class="line">while True:</div><div class="line">        msg = os.read(fp_r, 1024)                            #读入文件描述符中的内容</div><div class="line">        if msg == &apos;&apos;:                        #如果杀掉写端的进程，那么在读端会继续读，所以我们对读取的内容进行判断，如果为空字符串，就退出</div><div class="line">                break</div><div class="line">        print(msg)</div><div class="line">        if msg == &apos;q&apos;:</div><div class="line">                break</div><div class="line"> </div><div class="line">     </div><div class="line">os.close(fp_r)                                    #关闭文件描述符</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/python进程之进程间通讯——共享内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/python进程之进程间通讯——共享内存/" itemprop="url">
                  python进程之进程间通讯——共享内存
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-共享内存简介"><a href="#1-共享内存简介" class="headerlink" title="1. 共享内存简介"></a>1. 共享内存简介</h1><ul>
<li>共享内存：进程间的一种通讯方式，他允许多个进程访问相同的内存，一个进程改变其中的数据后，其他的进程都可以看到数据的变化</li>
<li><p>Linux的内存模型：</p>
<ol>
<li>每个进程的虚拟内存被分为页（page）</li>
<li>每个进程维护自己的内存地址到虚拟内存页之间的映射</li>
<li>实际的数据存在于进程的内存地址上</li>
<li>每个进程都有自己的地址空间，多个进程的映射还是可以指定相同的页</li>
</ol>
</li>
<li><p>数据可以使用Value或Array类型存储在共享内存映射中，需要导入：from multiprocessing import Process, Value, Array</p>
</li>
<li>Manger()返回的管理者，支持类型包括：list  、dict、Namespance、Lock、RLock、Semaphore、BoundedSemaphore、Condition、Event、Queue、Avalue and Array</li>
</ul>
<h1 id="2-Value-and-Array-帮助"><a href="#2-Value-and-Array-帮助" class="headerlink" title="2.Value and Array 帮助"></a>2.Value and Array 帮助</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">In [5]: from multiprocessing import Process,Value,Array                    #导入模块</div><div class="line"> </div><div class="line">In [6]: help(Value)                                                #Value</div><div class="line">Help on function Value in module multiprocessing:</div><div class="line"> </div><div class="line">Value(typecode_or_type, *args, **kwds)                            #typecode_or_type是指定数据类型，见下文</div><div class="line">    Returns a synchronized shared object</div><div class="line"> </div><div class="line"> </div><div class="line">In [7]: help(Array)                                             #Array</div><div class="line">Help on function Array in module multiprocessing:</div><div class="line"> </div><div class="line">Array(typecode_or_type, size_or_initializer, **kwds)</div><div class="line">    Returns a synchronized shared array</div></pre></td></tr></table></figure>
<h1 id="3-typecode-or-type数据类型"><a href="#3-typecode-or-type数据类型" class="headerlink" title="3.typecode_or_type数据类型"></a>3.typecode_or_type数据类型</h1><table>
<thead>
<tr>
<th>Type code</th>
<th>C Type</th>
<th>Python Type</th>
<th>Minimum size in bytes</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘b’</td>
<td>signed char</td>
<td>int</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>‘B’</td>
<td>unsigned char</td>
<td>int</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>‘u’</td>
<td>Py_UNICODE    Unicode character</td>
<td>2</td>
<td>(1)</td>
</tr>
<tr>
<td>‘h’</td>
<td>signed short</td>
<td>int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>‘H’</td>
<td>unsigned short</td>
<td>int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>‘i’</td>
<td>signed</td>
<td>int    int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>‘I’</td>
<td>unsigned</td>
<td>int    int</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>‘l’</td>
<td>signed long</td>
<td>int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>‘L’</td>
<td>unsigned long</td>
<td>int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>‘q’</td>
<td>signed long long</td>
<td>int</td>
<td>8</td>
<td>(2)</td>
<td></td>
</tr>
<tr>
<td>‘Q’</td>
<td>unsigned long long</td>
<td>int</td>
<td>8</td>
<td>(2)</td>
<td></td>
</tr>
<tr>
<td>‘f’</td>
<td>float</td>
<td>float</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>‘d’</td>
<td>double</td>
<td>float</td>
<td>8</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array(&apos;l&apos;)</div><div class="line">array(&apos;u&apos;, &apos;hello \u2641&apos;)</div><div class="line">array(&apos;l&apos;, [1, 2, 3, 4, 5])</div><div class="line">array(&apos;d&apos;, [1.0, 2.0, 3.14])</div></pre></td></tr></table></figure>
<h1 id="4-Array、Value常用方法"><a href="#4-Array、Value常用方法" class="headerlink" title="4.Array、Value常用方法"></a>4.Array、Value常用方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#Array</div><div class="line">In [8]: ay = Array(&apos;i&apos;, range(10))                #指定数据类型，创建Array</div><div class="line">In [9]: ay</div><div class="line">Out[9]: &lt;SynchronizedArray wrapper for &lt;multiprocessing.sharedctypes.c_long_Array_10 object at 0x96f48e4&gt;&gt;</div><div class="line">In [10]: ay.                                           #常用的方法</div><div class="line">ay.acquire                                           #加锁</div><div class="line">ay.get_lock                                          #获取锁</div><div class="line">ay.get_obj                                           #获取对象</div><div class="line">ay.release                                          #释放锁</div><div class="line"> </div><div class="line">In [10]: c = ay.get_obj()                       #获取对象      </div><div class="line">In [11]: c</div><div class="line">Out[11]: &lt;multiprocessing.sharedctypes.c_long_Array_10 at 0x96f48e4&gt;</div><div class="line">In [12]: c[:]                                            #打印对象分片</div><div class="line">Out[12]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line"> </div><div class="line"></div><div class="line">-------------------------------------------------------------------------------------</div><div class="line">#Value</div><div class="line">In [13]: value = Value(&apos;i&apos;,11)</div><div class="line">In [14]: value.</div><div class="line">value.acquire                  #加锁   </div><div class="line">value.get_lock                #获取锁</div><div class="line">value.get_obj                  #获取对象</div><div class="line">value.release                  #释放锁</div><div class="line">value.value                     #获取其中的值</div><div class="line"> </div><div class="line">In [14]: value.value              #打印值      </div><div class="line">Out[14]: 11</div></pre></td></tr></table></figure>
<h1 id="5-Value、Array举例"><a href="#5-Value、Array举例" class="headerlink" title="5.Value、Array举例"></a>5.Value、Array举例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">[root@backup python]# cat gongxiang.py</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">from multiprocessing import Process,Value,Array            #导入相应的模块</div><div class="line">import time</div><div class="line">import os</div><div class="line"> </div><div class="line">def child_func(g_value, g_array, ar):</div><div class="line">        g_value.value = ar</div><div class="line">        g_array[ar] = ar*ar</div><div class="line">        print(&quot;g_value.value=&quot;,g_value.value)</div><div class="line"> </div><div class="line">listp = []</div><div class="line"> </div><div class="line">g_value = Value(&apos;i&apos;,0)                                    #初始化共享类型</div><div class="line">g_array = Array(&apos;i&apos;,range(10))</div><div class="line"> </div><div class="line">print(&quot;init g_value=&#123;0&#125;,g_array=&#123;1&#125;&quot;.format(g_value.value,g_array[:]))</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        p = Process(target=child_func, args=(g_value,g_array,i))       #启动子进程，子进程会调用对应的函数，所有的子进程会共享g_value,g_array，因为他们会继承父进程的内存</div><div class="line">        p.start()</div><div class="line">        listp.append(p)</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        listp[i].join()                                                                #等待子进程关闭</div><div class="line"> </div><div class="line">print(&quot;end vlaue=&quot;,g_value.value)</div><div class="line">print(&quot;end array=&quot;,g_array[:])</div><div class="line"></div><div class="line">----------------------------------------------------------------------------</div><div class="line">#打印结果</div><div class="line">[root@backup python]# python gongxiang.py</div><div class="line">init g_value=0,g_array=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">(&apos;g_value.value=&apos;, 1)</div><div class="line">(&apos;g_value.value=&apos;, 0)</div><div class="line">(&apos;g_value.value=&apos;, 2)</div><div class="line">(&apos;g_value.value=&apos;, 3)</div><div class="line">(&apos;g_value.value=&apos;, 4)</div><div class="line">(&apos;g_value.value=&apos;, 5)</div><div class="line">(&apos;g_value.value=&apos;, 6)</div><div class="line">(&apos;g_value.value=&apos;, 7)</div><div class="line">(&apos;g_value.value=&apos;, 9)</div><div class="line">(&apos;g_value.value=&apos;, 8)</div><div class="line">(&apos;end vlaue=&apos;, 8)</div><div class="line">(&apos;end array=&apos;, [0, 1, 4, 9, 16, 25, 36, 49, 64, 81])</div></pre></td></tr></table></figure>
<h1 id="6-Manger查看帮助及常用方法"><a href="#6-Manger查看帮助及常用方法" class="headerlink" title="6.Manger查看帮助及常用方法"></a>6.Manger查看帮助及常用方法</h1><p>因为Value和Array中的数据类型是固定的，所以我们引入了Manger的方式来共享内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">In [20]: from multiprocessing import Manager</div><div class="line">#帮助</div><div class="line">In [22]: help(Manager)</div><div class="line">Help on function Manager in module multiprocessing:</div><div class="line"> </div><div class="line">Manager()</div><div class="line">    Returns a manager associated with a running server process</div><div class="line"> </div><div class="line">    The managers methods such as `Lock()`, `Condition()` and `Queue()`</div><div class="line">    can be used to create shared objects.</div><div class="line"></div><div class="line"></div><div class="line">#常用方法</div><div class="line">In [23]: ma = Manager() </div><div class="line">#可以获取下面的数据类型</div><div class="line">In [25]: ma.</div><div class="line">ma.Array                        #数组 </div><div class="line">ma.JoinableQueue     </div><div class="line">ma.Queue                     #队列</div><div class="line">ma.address          </div><div class="line"> ma.join              </div><div class="line">ma.start</div><div class="line">ma.BoundedSemaphore  </div><div class="line">ma.Lock              </div><div class="line">ma.RLock            </div><div class="line">ma.connect           </div><div class="line">ma.list                         #列表</div><div class="line">ma.Condition         </div><div class="line">ma.Namespace         </div><div class="line">ma.Semaphore         </div><div class="line">ma.dict                       #字典</div><div class="line">ma.register         </div><div class="line">ma.Event            </div><div class="line">ma.Pool              </div><div class="line">ma.Value             </div><div class="line">ma.get_server        </div><div class="line">ma.shutdown         </div><div class="line">  </div><div class="line">In [26]: dict = ma.dict()            #返回一个字典类型</div><div class="line"> </div><div class="line">In [27]: dict</div><div class="line">Out[27]: &lt;DictProxy object, typeid &apos;dict&apos; at 0x9795aac&gt;</div><div class="line"></div><div class="line"> </div><div class="line">In [28]: dict[&apos;name&apos;]=&apos;zhangsan&apos;            #为字典赋值</div><div class="line"></div><div class="line">In [32]: dict.values()</div><div class="line">Out[32]: [&apos;zhangsan&apos;]</div><div class="line"> </div><div class="line">In [34]: dict[&apos;name&apos;]                           #取出其中的值</div><div class="line">Out[34]: &apos;zhangsan&apos;</div></pre></td></tr></table></figure></p>
<h1 id="7-Manger举例"><a href="#7-Manger举例" class="headerlink" title="7.Manger举例"></a>7.Manger举例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">[root@backup python]# cat manager.py</div><div class="line">#!/usr/bin/python</div><div class="line"> </div><div class="line">from multiprocessing import Process,Value,Array,Manager</div><div class="line">import time</div><div class="line">import os</div><div class="line"> </div><div class="line"> </div><div class="line">def child_func(g_value,g_array,g_dict,ar):</div><div class="line">        g_value.value = ar</div><div class="line">        g_array[ar] = ar*ar</div><div class="line">        g_dict[ar] = ar+ar</div><div class="line"> </div><div class="line">listp = []</div><div class="line">g_value = Value(&apos;i&apos;,0)</div><div class="line">g_array = Array(&apos;i&apos;,range(10))</div><div class="line">manager = Manager()</div><div class="line">g_dict = manager.dict()                                                #返回一个dict类型的字典</div><div class="line"> </div><div class="line">print(&quot;init g_value=&#123;0&#125;,g_array=&#123;1&#125;,g_dict=&#123;2&#125;&quot;.format(g_value.value,g_array[:],g_dict))</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        p = Process(target=child_func, args=(g_value,g_array,g_dict,i))</div><div class="line">        p.start()</div><div class="line">        listp.append(p)</div><div class="line"> </div><div class="line">for i in range(10):</div><div class="line">        listp[i].join()</div><div class="line"> </div><div class="line">print(&quot;init g_value=&#123;0&#125;,g_array=&#123;1&#125;,g_dict=&#123;2&#125;&quot;.format(g_value.value,g_array[:],g_dict))</div><div class="line"></div><div class="line"></div><div class="line">-------------------------------------------------------------</div><div class="line">#执行结果</div><div class="line">[root@backup python]# python manager.py</div><div class="line">init g_value=0,g_array=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9],g_dict=&#123;&#125;</div><div class="line">init g_value=8,g_array=[0, 1, 4, 9, 16, 25, 36, 49, 64, 81],g_dict=&#123;0: 0, 1: 2, 2: 4, 3: 6, 4: 8, 5: 10, 6: 12, 7: 14, 8: 16, 9: 18&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/python进程之进程基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/python进程之进程基本概念/" itemprop="url">
                  python进程之进程基本概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>进程：存储在磁盘上的程序被读取到内存的一次执行</li>
<li>进程是一个实体，每个进程都会有自己的地址空间，内存、数据栈</li>
<li>进程之间的数据不能共享，通过进程间通讯进行交互</li>
<li>python进程机制基于系统机制实现</li>
<li>Linux进程调度：<br>  通过合理的调度，最大限度的利用处理器时间和系统资源，如果进程数大于处理器个数，某一时刻调度不到的进程会等待运行，调度程序会在这些等待运行的进程中选择一个合适的来执行。</li>
<li><p>python进程：<br>  基于系统进程实现，启动一个进程相当于启动一个python虚拟机<br>  每创建一个进程，就相当于复制一个python虚拟机</p>
</li>
<li><p>有两种方式来实现并发性，一种方式是让每个“任务”或“进程”在单独的内在空间中工作，每个都有自已的工作内存区域。不过，虽然进程可在单独的内存空间中执行，但除非这些进程在单独的处理器上执行，否则，<font color="red">实际并不是“同时”运行的。是由操作系统把处理器的时间片分配给一个进程，用完时间片后就需退出处理器等待另一个时间片的到来</font>。另一种方式是在在程序中指定多个“执行线程”，让它们在相同的内存空间中工作。这称为“多线程处理”</p>
</li>
<li><p>子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间，它们之间共享的存储空间只有代码段。</p>
</li>
<li>python程序运行的状态： <ul>
<li>运行</li>
<li>休眠</li>
<li>等待</li>
<li>僵尸进程</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/python进程之创建子进程及进程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/python进程之创建子进程及进程池/" itemprop="url">
                  python进程之创建子进程及进程池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-python创建进程"><a href="#1-python创建进程" class="headerlink" title="1.python创建进程"></a>1.python创建进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">ret = os.fork()        #创建进程,返回两个值,(如果是子进程,那么返回0,如果是父进程,那么返回子进程的pid)</div><div class="line">if(ret == 0):</div><div class="line">    print &quot;child process&quot;</div><div class="line">    print os.getpid()        #子进程的pid</div><div class="line">else:</div><div class="line">    print &quot;Parent process ret=%d&quot; % ret</div><div class="line">    print os.getpid()</div><div class="line"></div><div class="line">print os.getpid()        #父进程和子进程都执行的代码</div></pre></td></tr></table></figure>
<ul>
<li>父进程创建子进程后，子进程会继承父进程的代码段，数据空间、堆和栈</li>
<li>通过fork()函数的返回值区分父进程和子进程</li>
<li>如果父进程没有回收子进程，那么当父进程退出后，由系统回收子进程资源</li>
</ul>
<h1 id="2-子进程回收函数：os-wait"><a href="#2-子进程回收函数：os-wait" class="headerlink" title="2.子进程回收函数：os.wait()"></a>2.子进程回收函数：os.wait()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">ret = os.fork()        #创建进程,返回两个值,(如果是子进程,那么返回0,如果是父进程,那么返回子进程的pid)</div><div class="line">if(ret == 0):</div><div class="line">    print &quot;child process&quot;</div><div class="line">    print os.getpid()        #子进程的pid</div><div class="line">else:</div><div class="line">    print &quot;Parent process ret=%d&quot; % ret</div><div class="line">    print os.getpid()</div><div class="line">    os.wait()        #父进程等待子进程退出</div><div class="line"></div><div class="line">print os.getpid()        #父进程和子进程都执行的代码</div></pre></td></tr></table></figure>
<ol>
<li>父进程不显示调用os.wait()，当父进程退出，系统的第一个进程会把子进程回收</li>
<li>父进程显示的调用os.wait()，子进程退出后，就会被父进程回收</li>
<li>父进程没有显示调用os.wait()，而且父进程是一个守护或者死循环（如果父进程退出，那么子进程会由系统进程回收，但是此时父进程没有退出，所以系统就不会管理子进程），那么他创建的子进程退出后，就会成为僵尸进程，当父进程不断的创建进程的时候，就会出现错误</li>
<li>如果父进程先于子进程退出，那么守护进程init会将子进程回收，但是如果父进程在子进程的后面退出，并且此时在父进程中没有os.wait()，那么就会使子进程成为僵尸进程，即子进程的内存将不会被回收。<br>os.wait函数用于等待子进程结束(只适用于UNIX兼容系统)。该函数返回包含两个元素的元组，包括已完成的子进程号pid，以及子进程的退出状态，返回状态为0，表明子进程成功完成。返回状态为正整数表明子进程终止时出错。如没有子进程，会引发OSError错误。os.wait要求父进程等待它的任何一个子进程结束执行，然后唤醒父进程。</li>
</ol>
<p>要指示父进程等候一个指定的子进程终止，可在父进程中使用os.waitpid函数(只适用于unix兼容系统)。它可等候一个指定进程结束，然后返回一个双元素元组，其中包括子进程的pid和子进程的退出状态。函数调用将pid作为第一个参数传递，并将一个选项作为第二个选项，如果第一个参数大于 0，则waitpid会等待该pid结束，如果第一个参数是-1，则会等候所有子进程，也就和os.wait一样</p>
<h1 id="3-图形展示父进程和子进程的执行过程"><a href="#3-图形展示父进程和子进程的执行过程" class="headerlink" title="3.图形展示父进程和子进程的执行过程"></a>3.图形展示父进程和子进程的执行过程</h1><p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/process/3.png" alt=""></p>
<h1 id="4-multiprocessing-方式创建子进程"><a href="#4-multiprocessing-方式创建子进程" class="headerlink" title="4.multiprocessing 方式创建子进程"></a>4.multiprocessing 方式创建子进程</h1><p>fork 方式是仅在linux 下才有的接口， 在windows下并没有， 那么在windows下如何实现多进程呢， 这就用到了multiprocessing<br>multiprocessing 模块的Process 对象表示的是一个进程对象， 可以创建子进程并执行制定的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from multiprocessing import Process</div><div class="line">import os</div><div class="line"> </div><div class="line">def pro_do(name, func):</div><div class="line">    print &quot;This is child process %d from parent process %d, and name is  %s which is used for %s&quot; %(os.getpid(), os.getppid(), name, func)</div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    print &quot;Parent process id %d&quot; %(os.getpid())</div><div class="line">    #process 对象指定子进程将要执行的操作方法(pro_do), 以及该函数的对象列表args(必须是tuple格式， 且元素与pro_do的参数一一对应)</div><div class="line">    pro = Process(target=pro_do, args=(&quot;test&quot;, &quot;dev&quot;))</div><div class="line">    print &quot;start child process&quot;</div><div class="line">    #启动子进程</div><div class="line">    pro.start()</div><div class="line">    #是否阻塞方式执行， 如果有， 则阻塞方式， 否则非阻塞</div><div class="line">    pro.join() #if has this, it&apos;s synchronous operation or asynchronous operation</div><div class="line">    print &quot;Process end&quot;</div></pre></td></tr></table></figure>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Parent process id 4878</div><div class="line">start child process</div><div class="line">This is child process 4879 from parent process 4878, and name is  test which is used for dev</div><div class="line">Process end</div></pre></td></tr></table></figure></p>
<p>如果没有pro.join()， 则表示非阻塞方式运行， 那么最终的Process end的输出位置就有可能出现在pro_do 方法执行之前了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Parent process id 4903</div><div class="line">start child process</div><div class="line">Process end</div><div class="line">This is child process 4904 from parent process 4903, and name is  test which is used for dev</div></pre></td></tr></table></figure></p>
<p>通过multiprocessing 的process对象创建多进程， 还可以从主进程中向子进程传递参数， 例如上面例子中的pro_do的参数</p>
<h1 id="5-Pool-进程池"><a href="#5-Pool-进程池" class="headerlink" title="5.Pool 进程池"></a>5.Pool 进程池</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">from multiprocessing import Pool</div><div class="line">import os, time</div><div class="line"> </div><div class="line">def pro_do(process_num):</div><div class="line">    print &quot;child process id is %d&quot; %(os.getpid())</div><div class="line">    time.sleep(6 - process_num)</div><div class="line">    print &quot;this is process %d&quot; %(process_num)</div><div class="line"> </div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    print &quot;Current process is %d&quot; %(os.getpid())</div><div class="line">    p = Pool()</div><div class="line">    for i in range(5):</div><div class="line">        p.apply_async(pro_do, (i,))  #增加新的进程</div><div class="line">    p.close() # 禁止在增加新的进程</div><div class="line">    p.join()</div><div class="line">    print &quot;pool process done&quot;</div></pre></td></tr></table></figure>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Current process is 19138</div><div class="line">child process id is 19139</div><div class="line">child process id is 19140</div><div class="line">this is process 1</div><div class="line">child process id is 19140</div><div class="line">this is process 0</div><div class="line">child process id is 19139</div><div class="line">this is process 2</div><div class="line">child process id is 19140</div><div class="line">this is process 3</div><div class="line">this is process 4</div><div class="line">pool process done</div></pre></td></tr></table></figure></p>
<p>其中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">child process id is 19139</div><div class="line">child process id is 19140</div></pre></td></tr></table></figure></p>
<p>是立即输出的， 后面的依次在等待了sleep的时间后输出 ， 之所以立即输出了上面两个是因为诶Pool 进程池默认是按照cpu的数量开启子进程的， 我是在虚拟机中运行， 只分配了两核， 所以先立即启动两个子进程， 剩下的进程要等到前面的进程执行完成后才能启动。 不过也可以在p=Poo() 中使用Pool(5)来指定启动的子进程数量， 这样输出就是下面的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Current process is 19184</div><div class="line">child process id is 19185</div><div class="line">child process id is 19186</div><div class="line">child process id is 19188</div><div class="line">child process id is 19189</div><div class="line">child process id is 19187</div><div class="line">this is process 4</div><div class="line">this is process 3</div><div class="line">this is process 2</div><div class="line">this is process 1</div><div class="line">this is process 0</div><div class="line">pool process done</div></pre></td></tr></table></figure>
<p>且<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Current process is 19184</div><div class="line">child process id is 19185</div><div class="line">child process id is 19186</div><div class="line">child process id is 19188</div><div class="line">child process id is 19189</div><div class="line">child process id is 19187</div></pre></td></tr></table></figure></p>
<p>都是立即输出的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/python进程之IPC-管道(pipe)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/python进程之IPC-管道(pipe)/" itemprop="url">
                  python进程之IPC-管道(pipe)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Unix中的进程间通信方式之一是通过管道实现的，管道分为有名管道和无名管道，<font color="red">对于有名管道FIFO，可以实现没有亲缘关系的进程间通信，而对于无名管道，可以实现父子进程间的通信</font></li>
<li><p>管道这种IPC存在的意义是为了实现进程间消息的传递。无名管道是Unix最初的IPC形式，但是由于无名管道的局限性，<font color="red">后来出现了有名管道FIFO，这种管道由于可以在文件系统中创建一个名字，所以可以被没有亲缘关系的进程访问</font></p>
</li>
<li><p>管道打开后的标识是以<font color="red">文件描述符的形式提供的，可以使用Unix系统中的read和write系统调用访问</font></p>
</li>
<li><p>管道的实现形式有多种，在一些系统中，管道被实现为全双工的，在管道的一端既可以读也可以写，但是Posix.1和Unix 98只要求半双工管道，在Linux系统中，管道是半双工的。</p>
</li>
</ul>
<p>Unix中的无名管道是通过 pipe 函数创建的，该函数创建了一个半双工的管道。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">int pipe(int fd[2]);</div><div class="line"></div><div class="line">返回值：成功返回0，出错返回-1</div></pre></td></tr></table></figure></p>
<p>函数通过参数fd[2]返回两个描述符，<font color="red">fd[0]表示管道的读端，fd[1]表示管道的写端</font></p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/IPC_PIPE/1.png" alt=""></p>
<p>管道一般是由一个父进程创建，然后被用来在父子进程间进行通信：</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/IPC_PIPE/2.png" alt=""></p>
<p> 在父子进程通过管道进行通信的程序中，一般在父进程中先创建一个管道，然后 fork 出一个子进程，然后在两个进程中关闭不写和不读的两端。</p>
<font color="red">由于Unix中的管道默认实现是单向的，为了实现双向的，可以用两个单向的管道模拟</font>

<p> <img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/IPC_PIPE/3.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/python语法之迭代器和解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/python语法之迭代器和解析/" itemprop="url">
                  python语法之迭代器和解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-迭代器-Iterator-和可迭代对象-Iterable"><a href="#1-迭代器-Iterator-和可迭代对象-Iterable" class="headerlink" title="1.迭代器(Iterator)和可迭代对象(Iterable)"></a>1.迭代器(Iterator)和可迭代对象(Iterable)</h1><h2 id="1-1判断对象是否可迭代"><a href="#1-1判断对象是否可迭代" class="headerlink" title="1.1判断对象是否可迭代"></a>1.1判断对象是否可迭代</h2><p>可以使用isinstance()判断一个对象是否是Iterator对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from collections import Iterator</div><div class="line">&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; isinstance([], Iterator)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)</div><div class="line">False</div><div class="line">&gt;&gt;&gt; isinstance(&apos;abc&apos;, Iterator)</div><div class="line">False</div></pre></td></tr></table></figure></p>
<h2 id="1-2-Iterator-和Iterable区别"><a href="#1-2-Iterator-和Iterable区别" class="headerlink" title="1.2.Iterator 和Iterable区别"></a>1.2.Iterator 和Iterable区别</h2><ul>
<li>凡是可作用于for循环的对象都是Iterable类型；</li>
<li>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</li>
<li>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</li>
<li>Python的for循环本质上就是通过不断调用next()函数实现的</li>
</ul>
<h1 id="2-迭代器原理"><a href="#2-迭代器原理" class="headerlink" title="2.迭代器原理"></a>2.迭代器原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;L = [1,2,3]</div><div class="line">&gt;&gt;I = iter(L)                                    #第一步：使用iter()函数将可迭代的对象转化成为一个迭代器</div><div class="line">&gt;&gt;I.next()</div><div class="line">1</div><div class="line">&gt;&gt;I.next()                                        #第二部：使用迭代器的next()方法( 或者_next_()方法 )进行迭代</div><div class="line">2</div><div class="line">&gt;&gt;I.next()</div><div class="line">3</div><div class="line">&gt;&gt;I.next()</div><div class="line">....more ommitted</div><div class="line">StopIteration                                    #第三部：在迭代过程中遇到StopItreation 异常就结束迭代</div></pre></td></tr></table></figure>
<h1 id="3-迭代器原理举例"><a href="#3-迭代器原理举例" class="headerlink" title="3.迭代器原理举例"></a>3.迭代器原理举例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">#Example1（列表迭代的过程）</div><div class="line">&gt;&gt;L = [1,2,3]</div><div class="line">&gt;&gt;for x in L:</div><div class="line">    print(x, end=&apos; &apos;)</div><div class="line">.......</div><div class="line">1 2 3</div><div class="line"></div><div class="line"></div><div class="line">#等价于</div><div class="line">&gt;&gt;L = [1,2,3]</div><div class="line">&gt;&gt;I = iter(L)                                       #获取迭代器</div><div class="line">while True:</div><div class="line">    try:</div><div class="line">        x = next(I)                                  #进行迭代</div><div class="line">    except StopIteration:                      #迭代结束</div><div class="line">        break</div><div class="line">    print(x , end=&apos; &apos;)</div><div class="line">.......</div><div class="line">1 2 3</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#Example2（字典迭代）</div><div class="line">&gt;&gt;D = &#123;&apos;a&apos;:1, &apos;b&apos;:2&#125;</div><div class="line">&gt;&gt;for key in D:</div><div class="line">    print(key, D[key])</div><div class="line"></div><div class="line">#等价于</div><div class="line">&gt;&gt;D = &#123;&apos;a&apos;:1, &apos;b&apos;:2&#125;</div><div class="line">&gt;&gt;I = iter(D)</div><div class="line">&gt;&gt;next(I)                                #对字典的迭代取出的是字典中的key</div><div class="line">&apos;a&apos;</div><div class="line">&gt;&gt;next(I)</div><div class="line">&apos;b&apos;</div><div class="line">&gt;&gt;next(I)</div><div class="line">Traceback </div><div class="line">......more omitted...</div><div class="line">StopIteration                            #迭代结束</div><div class="line"></div><div class="line"></div><div class="line">#Example3（enumerate迭代）</div><div class="line">&gt;&gt;E = enumerate(&apos;spam&apos;)</div><div class="line">&gt;&gt;I = iter(E)                        #得到迭代器</div><div class="line">&gt;&gt;next(I)</div><div class="line">(0,&apos;s&apos;)</div><div class="line">&gt;&gt;next(I)</div><div class="line">(1,&apos;p&apos;)</div><div class="line">......</div><div class="line"></div><div class="line">&gt;&gt;list( enumerate(&apos;spam&apos;))</div><div class="line">[(0,&apos;s&apos;) ,(1,&apos;p&apos;) ,(2,&apos;a&apos;) ,(3,&apos;m&apos;)]</div></pre></td></tr></table></figure>
<h1 id="4-列表解析"><a href="#4-列表解析" class="headerlink" title="4.列表解析"></a>4.列表解析</h1><h2 id="4-1基本格式"><a href="#4-1基本格式" class="headerlink" title="4.1基本格式"></a>4.1基本格式</h2><p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/python/iterable/1.png" alt=""></p>
<h2 id="4-2举例"><a href="#4-2举例" class="headerlink" title="4.2举例"></a>4.2举例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#Example1</div><div class="line">L = [x + 1  for x in L]</div><div class="line"></div><div class="line">#Example2</div><div class="line">lines = [line.rstrip()   for line in lines]            #去掉每一行后面的\n</div><div class="line"></div><div class="line">#Example3</div><div class="line">[line.upper()  for line in opne(&apos;data.txt&apos;)]      #将每一行转成大写</div><div class="line">[&apos;AAA&apos;, &apos;BBB&apos;, &apos;CCC&apos;]</div><div class="line"></div><div class="line"></div><div class="line">#Example4（if条件）</div><div class="line">lines = [line.rstrip()  for line in open(&apos;data.txt&apos;)  if line[0] == &apos;p&apos; ]        #在列表中只留下以‘p&apos;开头的行</div><div class="line"></div><div class="line"></div><div class="line">#Example5（多个for）</div><div class="line">[x +y for x in &apos;abc&apos;  for y in &apos;123&apos;]</div><div class="line">[&apos;a1&apos;, &apos;b2&apos;, &apos;c3&apos;]</div><div class="line"></div><div class="line"></div><div class="line">#Example6(生成字典)</div><div class="line">&#123;ix:line  for ix,line in enumerate(open(&apos;data.txt&apos;))&#125;</div><div class="line">&#123;0:&apos;AAA&apos;, 1:&apos;BBB&apos;, 2:&apos;CCC&apos;&#125;</div></pre></td></tr></table></figure>
<h1 id="5-支持可迭代协议的函数"><a href="#5-支持可迭代协议的函数" class="headerlink" title="5.支持可迭代协议的函数"></a>5.支持可迭代协议的函数</h1><p><font color="red">这样的函数会在内部调用itre（可迭代对象）进行循环</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">#list</div><div class="line">list(open(&apos;data.txt&apos;))            #循环可迭代对象的每一行</div><div class="line">[&apos;AAA&apos;, &apos;BBB&apos;, &apos;CCC&apos;]</div><div class="line"></div><div class="line">#sorted                        #返回的是list</div><div class="line">sorted(open(&apos;data.txt&apos;))</div><div class="line">[&apos;AAA&apos;, &apos;BBB&apos;, &apos;CCC&apos;]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#sum</div><div class="line">sum( [1,3,4,18] )            #循环可迭代对象list，求sum</div><div class="line">26</div><div class="line"></div><div class="line">#max/min                     #循环可迭代对象list，找出max</div><div class="line">max( [1,3,4,18] )    </div><div class="line">18</div><div class="line"></div><div class="line"></div><div class="line">#any                     #如果一个迭代对象中的任何或所有项都为真，返回True  ?</div><div class="line">any([2,3,4])</div><div class="line">True</div><div class="line"></div><div class="line"></div><div class="line">#tuple</div><div class="line">tuple(open(&apos;data.txt&apos;))                 #tuple循环可迭代对象</div><div class="line">(&apos;AAA&apos;, &apos;BBB&apos;, &apos;CCC&apos;)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#join</div><div class="line">&quot;&amp;&amp;&quot;.join(open(&apos;data.txt&apos;))        #join循环可迭代对象,然后在其中加入“&amp;&amp;”</div><div class="line">’AAA&amp;&amp;BBB&amp;&amp;CCC‘</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#set</div><div class="line"></div><div class="line">#zip</div><div class="line">zip([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1,2,3])                         #返回的是可迭代对象</div><div class="line">list( zip([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1,2,3]) )                #在list中进行循环迭代，生成list列表</div><div class="line">[(&apos;a&apos;, 1) ,(&apos;b&apos;, 2), (&apos;c&apos;, 3)]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#enumerate</div><div class="line">enumerate(open(&apos;data.txt&apos;))                    #返回的是可迭代对象</div><div class="line">list( enumerate(open(&apos;data.txt&apos;)) )            #在list中进行循环迭代，生成list列表</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#range</div></pre></td></tr></table></figure></p>
<h1 id="6-多个迭代器VS单个迭代器"><a href="#6-多个迭代器VS单个迭代器" class="headerlink" title="6.多个迭代器VS单个迭代器"></a>6.多个迭代器VS单个迭代器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#range 产生的多个迭代器</div><div class="line">&gt;&gt;R = range(3)</div><div class="line">&gt;&gt;next(R)</div><div class="line">TypeError: range object is not an iterator</div><div class="line"></div><div class="line">&gt;&gt;I1 = iter(R)</div><div class="line">&gt;&gt;I2 = iter(R)                    #可以产生多个互不影响的迭代器</div><div class="line">&gt;&gt;next(I1)                         #遍历迭代器1</div><div class="line">0</div><div class="line">&gt;&gt;next(I1)</div><div class="line">1</div><div class="line">&gt;&gt;next(I2)                          #迭代器2</div><div class="line">0</div><div class="line">&gt;&gt;next(I2)</div><div class="line">1</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#zip 、map、filter 产生的单迭代器</div><div class="line">&gt;&gt;Z = zip([1,2,3], [10,11,12])</div><div class="line">&gt;&gt;I1 = iter(Z)</div><div class="line">&gt;&gt;I2 = iter(Z) </div><div class="line">&gt;&gt;next(I1)</div><div class="line">(1,10)</div><div class="line">&gt;&gt;next(I1)</div><div class="line">(2,11)</div><div class="line">&gt;&gt;next(I2)                        #他会接着上一个迭代器循环</div><div class="line">(3,12)</div></pre></td></tr></table></figure>
<h1 id="7-字典视图迭代器"><a href="#7-字典视图迭代器" class="headerlink" title="7.字典视图迭代器"></a>7.字典视图迭代器</h1><p>字典有针对key的迭代器，keys、values、items返回都是可迭代的视图对象（可迭代对象）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;D = &#123;&apos;a&apos;:1, &apos;b&apos;:2 , &apos;c&apos;:3&#125;</div><div class="line">&gt;&gt;K = D.keys()</div><div class="line">&gt;&gt;next(K)</div><div class="line">TypeError:dict_key object is not an iterator</div><div class="line">.....</div><div class="line"></div><div class="line">&gt;&gt;I = iter(K)</div><div class="line">&gt;&gt;next(I)</div><div class="line">&apos;a&apos;</div><div class="line">&gt;&gt;next(I)</div><div class="line">&apos;b&apos;</div><div class="line"></div><div class="line">for key in D.keys():</div><div class="line">    print(key,D[key])</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#因为字典也是可迭代对象</div><div class="line">&gt;&gt;D = &#123;&apos;a&apos;:1, &apos;b&apos;:2 , &apos;c&apos;:3&#125;</div><div class="line">&gt;&gt;I = iter(D)                     #返回对key的迭代器</div><div class="line">&gt;&gt;next(I)</div><div class="line">&apos;a&apos;</div><div class="line"></div><div class="line">for key in D:                  #迭代字典的key</div><div class="line">    print(key,D[key])</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/header.jpg"
               alt="Mr. Chen" />
          <p class="site-author-name" itemprop="name">Mr. Chen</p>
           
              <p class="site-description motion-element" itemprop="description">一个技术渣的自说自话</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">555</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr. Chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
