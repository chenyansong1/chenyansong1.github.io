<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Chen&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个技术渣的自说自话">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen's Blog">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="Chen's Blog">
<meta property="og:description" content="一个技术渣的自说自话">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen's Blog">
<meta name="twitter:description" content="一个技术渣的自说自话">
  
    <link rel="alternate" href="/atom.xml" title="Chen&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chen&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个技术渣的自说自话</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-scala编程/第十九章 类型参数化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第十九章 类型参数化/" class="article-date">
  <time datetime="2017-04-16T04:47:25.907Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第十九章 类型参数化/">第十九章 类型参数化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-queue函数式队列"><a href="#1-queue函数式队列" class="headerlink" title="1.queue函数式队列"></a>1.queue函数式队列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//函数式队列是一种具有以下三种操作方式的数据结构</div><div class="line">head     //返回队列的第一个元素</div><div class="line">tail    //返回除第一个元素之外的队列</div><div class="line">append    //返回尾部添加了指定元素的新队列</div><div class="line"></div><div class="line">//不像可变队列,函数式队列在添加元素的时候不会改变其内容,而是返回包含了这个元素的新队列</div><div class="line">scala&gt; import scala.collection.immutable.Queue</div><div class="line">scala&gt; val q = Queue(1,2,3)</div><div class="line">scala&gt; val q1 = q append 4</div></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/04/16/scala编程/第十九章 类型参数化/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第十九章 类型参数化/" data-id="cj290sb9t007vssqq9rx9eaf9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/第十三章 包和引用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第十三章 包和引用/" class="article-date">
  <time datetime="2017-04-16T04:47:25.906Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第十三章 包和引用/">第十三章 包和引用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;做程序的时候,尤其是很大的程序,使耦合最小化是很重要的,低耦合能降低程序一部分的细微改变影响到另一部分的正常执行这样的风险,减少耦合的方式之一是使用模块化风格编写代码,把程序分解成若干比较小的模块,把每块分成内部和外部,在模块的内部(即:模块的实现部分) 工作时,你只需要和同样工作于这个模块的程序员交互,只有当你必须改变模块的外部(即模块的接口)时,才需要和工作于其他模块的开发人员交互</p>
        
          <p class="article-more-link">
            <a href="/2017/04/16/scala编程/第十三章 包和引用/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第十三章 包和引用/" data-id="cj290sb9q007rssqqep27l5pi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/第十七章 集合类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第十七章 集合类型/" class="article-date">
  <time datetime="2017-04-16T04:47:25.904Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第十七章 集合类型/">第十七章 集合类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-集合库概览"><a href="#1-集合库概览" class="headerlink" title="1.集合库概览"></a>1.集合库概览</h1><p> <img src="http://ols7leonh.bkt.clouddn.com//assert/img/scala_programming/17/1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">Iterable是主要特质,他同时还是可变和不可变序列(Seq) , 集(Set), 以及映射(Map)的超特质,序列是有序的集合,例如:数组和列表,集可以通过==方法确定对每个对象最多只包含一个,映射则包含了键值映射关系的额集合</div><div class="line"></div><div class="line">命名为Iterable是为了说明集合对象可以通过名为elements的方法产生Iterator(枚举器),</div><div class="line">*/</div><div class="line">def elements: Iterator[A]</div><div class="line"></div><div class="line">/*</div><div class="line">例子中的A是Iterator的类型参数,他指代集合中包含的元素的类型, elements返回的Iterator被参数化为同样的类型,,例如:Iterable[Int] 的elements方法将创建Iterator[Int]</div><div class="line"></div><div class="line">Iterable包含几十个有用的具体方法,所有这些方法都是使用了elements返回的Iterator实现的,而elements是Iterable唯一的抽象方法,Iterable定义的方法中,许多是高阶方法,多数都已经在前面的章节中出现过,其中包含map, flatMap,filter, exists及find </div><div class="line"></div><div class="line">Iterator有许多与Iterable相同的方法,包括哪些高阶方法,但他们不属于同一层级,如图</div><div class="line">*/</div></pre></td></tr></table></figure>
<p> <img src="http://ols7leonh.bkt.clouddn.com//assert/img/scala_programming/17/2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">特质Iterator扩展了AnyRef,Iterable与Iterator之间的差异在于特质Iterable指代的是可以被枚举的类型(如集合类型),而特质Iterator是用来执行枚举操作的机制,尽管Iterable可以被枚举若干次,但Iterator仅能使用一次,一旦你使用Iterator枚举遍历了集合对象,你就不能再使用它了,如果你需要再次枚举该集合对象,你需要对他调用elements方法获得新的Iterator</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">Iterator提供的具体方法都使用了next和hasNext抽象方法实现</div><div class="line">*/</div><div class="line"></div><div class="line">def hasNext: Boolean</div><div class="line">def next: A</div></pre></td></tr></table></figure>
<h1 id="2-序列"><a href="#2-序列" class="headerlink" title="2.序列"></a>2.序列</h1><p>&emsp;序列是继承自特质Seq的类,他可以让你处理一组线性分布的数据,因为元素是有序的,所以你可以请求第一个元素,第二个元素,…第n个元素</p>
<p> 列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; val colors = List(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)</div><div class="line">colors: List[String] = List(red, blue, green)</div><div class="line"></div><div class="line">scala&gt; colors.head</div><div class="line">res42: String = red</div><div class="line"></div><div class="line">scala&gt; colors.tail</div><div class="line">res43: List[String] = List(blue, green)</div></pre></td></tr></table></figure></p>
<p> 数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">数组能够让你保留一组元素序列并可以基于零的索引高效访问(无论是获取还是添加)处于任意位置的元素,下列代码说明了如何创建长度已知但内容未知的数组</div><div class="line">*/</div><div class="line">scala&gt; val fiveInts = new Array[Int](5)</div><div class="line">fiveInts: Array[Int] = Array(0, 0, 0, 0, 0)</div><div class="line"></div><div class="line">scala&gt; val fiveToOne = Array(5,4,3,2,1)</div><div class="line">fiveToOne: Array[Int] = Array(5, 4, 3, 2, 1)</div><div class="line"></div><div class="line">//正如之前提到的,scala中数组的访问方式是通过把索引值放在圆括号里,而不是像java里那样放在方括号里,下面的例子和更新了数组元素:</div><div class="line"></div><div class="line">scala&gt; fiveInts(0) = fiveToOne(4)</div><div class="line"></div><div class="line">scala&gt; fiveInts</div><div class="line">res45: Array[Int] = Array(1, 0, 0, 0, 0)</div></pre></td></tr></table></figure></p>
<p> 列表缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">List类能够提供对列表头部,而非尾部的快速访问,因此,如果需要通过向结尾添加对象的方式建造列表,你应该考虑先以对表头前缀元素的方式反向构造列表,完成之后再调用reverse使得元素反转为你需要的顺序</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">另一种方式是使用ListBuffer, 这可以避免reverse操作,ListBuffer是可变对象(包含在scala.collection.mutable包中),他可以更高效的通过添加元素的方式构建列表,ListBuffer能够支持常量的添加和前缀操作,元素的添加使用+= 操作符,前缀使用+: 操作符,完成之后,可以通过对ListBuffer调用toList方法获得List,举例如下:</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; import scala.collection.mutable.ListBuffer</div><div class="line">import scala.collection.mutable.ListBuffer</div><div class="line"></div><div class="line">scala&gt; val buf = new ListBuffer[Int]</div><div class="line">buf: scala.collection.mutable.ListBuffer[Int] = ListBuffer()</div><div class="line"></div><div class="line">scala&gt; buf += 1</div><div class="line">res46: buf.type = ListBuffer(1)</div><div class="line"></div><div class="line">scala&gt; buf += 2    //向ListBuffer的后面添加元素</div><div class="line">res47: buf.type = ListBuffer(1, 2)</div><div class="line"></div><div class="line">scala&gt; buf</div><div class="line">res48: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2)</div><div class="line"></div><div class="line">scala&gt; 3 +: buf        //在前面添加新的元素,生成新的ListBuffer</div><div class="line">res49: scala.collection.mutable.ListBuffer[Int] = ListBuffer(3, 1, 2)</div><div class="line"></div><div class="line">scala&gt; buf</div><div class="line">res50: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2)</div><div class="line"></div><div class="line">scala&gt; buf.toList</div><div class="line">res51: List[Int] = List(1, 2)</div><div class="line"></div><div class="line">/*</div><div class="line">使用ListBuffer替代List的另一个理由是为了避免栈溢出的风险,即使你能够使用前缀的方式以正确的次序构建列表,但是所需的递归算法不是尾递归,那么你也可以使用for表达式或while循环及ListBuffer做替代</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p> 数组缓存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">ArrayBuffer与数组类似,只是额外还允许你在序列的开始或结束的地方添加和删除元素,所有的Array操作都被保留,只是由于实现中的包装层导致执行的稍微有些慢,</div><div class="line">*/</div><div class="line">//在使用ArrayBuffer之前,你必须首先从可变集合包中引用它</div><div class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</div><div class="line"></div><div class="line">//创建ArrayBuffer的时候,你必须指定他的类型参数,但可以不用指定长度,ArrayBuffer可以自动调整分配的空间:</div><div class="line"></div><div class="line">scala&gt; val buf = new ArrayBuffer[Int]()</div><div class="line">buf: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()</div><div class="line"></div><div class="line">//ArrayBuffer还能使用 += 操作添加元素</div><div class="line">scala&gt; buf += 12    </div><div class="line">res0: buf.type = ArrayBuffer(12)</div><div class="line"></div><div class="line">scala&gt; buf += 15</div><div class="line">res1: buf.type = ArrayBuffer(12, 15)</div><div class="line"></div><div class="line">scala&gt; buf.length    //获得数组的长度</div><div class="line">res2: Int = 2</div><div class="line"></div><div class="line">scala&gt; buf(0)    //通过索引访问元素</div><div class="line">res3: Int = 12</div></pre></td></tr></table></figure></p>
<p> 队列(Queue)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">如果你需要先进先出序列,可以使用Queue,scala的集合库提供了可变和不可变的Queue</div><div class="line">*/</div><div class="line">import scala.collection.immutable.Queue</div><div class="line">val empty = new Queue[Int]</div><div class="line"></div><div class="line">//你可以使用enqueue为不可变队列添加元素</div><div class="line">val has1 = empty.enqueue(1)</div><div class="line"></div><div class="line">//如果要添加多个元素的话,可以把集合当做enqueue调用的参数</div><div class="line">val has123 =has1.enqueue(List(2,3))</div><div class="line"></div><div class="line">//从队列的头部移除元素,可以使用dequeue</div><div class="line">val (element, has23) = has123.dequeue        //element =1   has23 = Queue(2,3)</div><div class="line"></div><div class="line"></div><div class="line">//对于不可变队列来说,dequeue方法将返回由队列头部元素和移除该元素之后的剩余队列组成的对偶(Tuple2)</div><div class="line"></div><div class="line"></div><div class="line">//可变队列的使用方式与不可变队列一样,只是代之以enqueue方法,你可以使用 += ,及 ++= 操作符添加元素,还有,对于可变队列来说,dequeue方法将只从队列移除元素头并返回</div><div class="line"></div><div class="line">scala&gt; import scala.collection.mutable.Queue</div><div class="line">import scala.collection.mutable.Queue</div><div class="line"></div><div class="line">scala&gt; val queue = new Queue[String]</div><div class="line">queue: scala.collection.mutable.Queue[String] = Queue()</div><div class="line"></div><div class="line">//添加元素</div><div class="line">scala&gt; queue += &quot;a&quot;</div><div class="line">res4: queue.type = Queue(a)</div><div class="line"></div><div class="line">//添加List</div><div class="line">scala&gt; queue ++= List(&quot;b&quot;, &quot;c&quot;)</div><div class="line">res5: queue.type = Queue(a, b, c)</div><div class="line"></div><div class="line">//返回头部</div><div class="line">scala&gt; queue.dequeue</div><div class="line">res6: String = a</div><div class="line"></div><div class="line">scala&gt; queue</div><div class="line">res7: scala.collection.mutable.Queue[String] = Queue(b, c)</div></pre></td></tr></table></figure></p>
<p> 栈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">//如果需要的是先进后出的序列,你可以使用Stack,他同样在scala的集合库中也有可变和不可变版本,元素的推入使用push,弹出使用pop,只获取栈顶的元素而不移除可以使用top,下面是使用的可变栈的例子</div><div class="line"></div><div class="line">scala&gt; import scala.collection.mutable.Stack</div><div class="line">import scala.collection.mutable.Stack</div><div class="line"></div><div class="line">scala&gt; val stack = new Stack[Int]</div><div class="line">stack: scala.collection.mutable.Stack[Int] = Stack()</div><div class="line"></div><div class="line">scala&gt; stack.push(1)</div><div class="line">res8: stack.type = Stack(1)</div><div class="line"></div><div class="line">scala&gt; stack</div><div class="line">res9: scala.collection.mutable.Stack[Int] = Stack(1)</div><div class="line"></div><div class="line">scala&gt; stack.push(2)</div><div class="line">res10: stack.type = Stack(2, 1)</div><div class="line"></div><div class="line">scala&gt; stack</div><div class="line">res11: scala.collection.mutable.Stack[Int] = Stack(2, 1)</div><div class="line"></div><div class="line">scala&gt; stack.top</div><div class="line">res12: Int = 2</div><div class="line"></div><div class="line">scala&gt; stack</div><div class="line">res13: scala.collection.mutable.Stack[Int] = Stack(2, 1)</div><div class="line"></div><div class="line">scala&gt; stack.pop</div><div class="line">res14: Int = 2</div><div class="line"></div><div class="line">scala&gt; stack</div><div class="line">res15: scala.collection.mutable.Stack[Int] = Stack(1)</div></pre></td></tr></table></figure></p>
<p> 字符串(经RichString隐式转换)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">RichString也是应该知道的序列,他的类型是Seq[Char] ,因为Predef包含了从String到RichString的隐式转换,所以你可以把任何字符串字符当做Seq[Char],举例如下:</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; def hasUpperCase(s: String) = s.exists(_.isUpperCase)</div><div class="line">&lt;console&gt;:12: error: value isUpperCase is not a member of Char</div><div class="line">       def hasUpperCase(s: String) = s.exists(_.isUpperCase)</div><div class="line">                                                ^</div><div class="line"></div><div class="line">scala&gt; def hasUpperCase(s: String) = s.exists(_.isUpperCase)    </div><div class="line"></div><div class="line">scala&gt; hasUpperCase(&quot;Robert Frost&quot;)    // true</div><div class="line"></div><div class="line">scala&gt; hasUpperCase(&quot;e e cummings&quot;)    // false</div><div class="line"></div><div class="line">/*</div><div class="line">本例中的hasUpperCase方法体中,字符串s调用了exists方法,而String类本身并没有定义名为&quot;exists&quot;的方法,因此scala编译器会把s隐式转换为含有这个方法的RichString类,exists方法把字符串看做Seq[Char] ,并且如果所有的字符都是大写字母则返回值</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h1 id="3-集-set-和映射-map"><a href="#3-集-set-和映射-map" class="headerlink" title="3.集(set)和映射(map)"></a>3.集(set)和映射(map)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">默认情况下在你使用&quot;Set&quot; 或&quot; Map&quot; 的时候,获得的都是不可变对象,如果需要的是可变版本,你需要首先写明引用,scala让你更易于使用不可变的版本,期望能够以此方式而并非相对的可变版本,这种访问易于来自Predef对象的支持,他被每个scala源文件隐含引用</div><div class="line">*/</div><div class="line"></div><div class="line">object Predef &#123;</div><div class="line">    type Set[T] = scala.collection.immutable.Set[T]</div><div class="line">    type Map[K,V] = scala.collection.immutable.Map[K, V]</div><div class="line">    type Set  = scala.collection.immutable.Set    //默认</div><div class="line">    type Map = scala.collection.immutable.Map        //默认</div><div class="line">///.....</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//如果同一个源文件中既要用到可变版本,也要用到不可变版本的集合或映射,方式之一是引用包含了可变版本的包名</div><div class="line"></div><div class="line">scala&gt; import scala.collection.mutable</div><div class="line">import scala.collection.mutable</div><div class="line"></div><div class="line">scala&gt; val mutaSet = mutable.Set(1,2,3)</div><div class="line">mutaSet: scala.collection.mutable.Set[Int] = Set(1, 2, 3)</div></pre></td></tr></table></figure>
<p> 使用集<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">集的关键特性在于他可以使用对象的==操作检查,确保任何时候每个对象只在集中保留最多一个副本,</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; val text = &quot;See Spot run, Run, Spot, Run!&quot;</div><div class="line"></div><div class="line">scala&gt; val wordsArray = text.split(&quot;[!,. ]+&quot;)</div><div class="line">wordsArray: Array[String] = Array(See, Spot, run, Run, Spot, Run)</div><div class="line"></div><div class="line">scala&gt; for(word &lt;- wordsArray)</div><div class="line">     words += word.toLowerCase</div></pre></td></tr></table></figure></p>
<p> 集的常用操作</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">val nums = Set(1,2,3)</td>
<td style="text-align:left">创建不可变集(nums.toString) 返回Set(1,2,3)</td>
</tr>
<tr>
<td style="text-align:left">nums += 5</td>
<td style="text-align:left">添加元素(返回Set(1,2,3,5))</td>
</tr>
<tr>
<td style="text-align:left">nums -= 3</td>
<td style="text-align:left">删除元素(返回Set(1,2))</td>
</tr>
<tr>
<td style="text-align:left">nums ++ List(5,6)</td>
<td style="text-align:left">添加多个元素(返回Set(1,2,3,5,6)</td>
</tr>
<tr>
<td style="text-align:left">nums – List(1,2)</td>
<td style="text-align:left">删除多个元素(返回Set(3))</td>
</tr>
<tr>
<td style="text-align:left">nums ** Set(1,3,5,7)</td>
<td style="text-align:left">获得交集(返回Set(1,3))</td>
</tr>
<tr>
<td style="text-align:left">nums.size</td>
<td style="text-align:left">返回集中包含的对象数量(返回3)</td>
</tr>
<tr>
<td style="text-align:left">nums.contains(3)</td>
<td style="text-align:left">检查是否包含(返回true)</td>
</tr>
<tr>
<td style="text-align:left">import scala.collection.mutable</td>
<td style="text-align:left">引用可变集合类型</td>
</tr>
<tr>
<td style="text-align:left">val words = mutable.Set.empty[String]</td>
<td style="text-align:left">创建空可变集(words.toString, 返回Set())</td>
</tr>
<tr>
<td style="text-align:left">words += “the”</td>
<td style="text-align:left">添加元素(words.toString返回Set(the))</td>
</tr>
<tr>
<td style="text-align:left">words -= “the”</td>
<td style="text-align:left">如果存在元素,则删除(words.toString 返回Set())</td>
</tr>
<tr>
<td style="text-align:left">words ++= List(“do”, “re”, “md”)</td>
<td style="text-align:left">添加多个元素(words.toString ,返回Set(do,re,md)</td>
</tr>
<tr>
<td style="text-align:left">words –= List(“do”, “re”)</td>
<td style="text-align:left">删除多个元素(words.toString 返回Set(md))</td>
</tr>
<tr>
<td style="text-align:left">words.clear</td>
<td style="text-align:left">删除所有元素(words.toString 返回Set())</td>
</tr>
</tbody>
</table>
<p>使用映射</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">scala&gt; val map = scala.collection.mutable.Map.empty[String, Int]</div><div class="line">map: scala.collection.mutable.Map[String,Int] = Map()</div><div class="line">/*</div><div class="line">在创建映射的时候,你必须指定两个类型,第一个类型是用来定义映射的键(key) , 第二个用来定义值(value), 在这个例子中,键是字符串,值是整数</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">scala&gt; map(&quot;hello&quot;) = 1</div><div class="line">scala&gt; map(&quot;there&quot;) = 2</div><div class="line"></div><div class="line">scala&gt; map</div><div class="line">res5: scala.collection.mutable.Map[String,Int] = Map(hello -&gt; 1, there -&gt; 2)</div><div class="line"></div><div class="line"></div><div class="line">scala&gt; map(&quot;hello&quot;)</div><div class="line">res6: Int = 1</div></pre></td></tr></table></figure>
<p> 映射的常用操作</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">val nums = Map(“i” -&gt; 1, “ii” -&gt; 2)</td>
<td style="text-align:left">创建不可变映射</td>
</tr>
<tr>
<td style="text-align:left">nums + (“vi” -&gt; 6)</td>
<td style="text-align:left">添加条目(返回Map(i-&gt;1, II-&gt;2, vi-&gt;6)</td>
</tr>
<tr>
<td style="text-align:left">nums - “ii”</td>
<td style="text-align:left">删除条目(返回Map(i-&gt;1))</td>
</tr>
<tr>
<td style="text-align:left">nums += List(“iii” -&gt; 3, “v”-&gt;5)</td>
<td style="text-align:left">添加多个条目</td>
</tr>
<tr>
<td style="text-align:left">nums – List(“i”, “ii”)</td>
<td style="text-align:left">删除多个条目</td>
</tr>
<tr>
<td style="text-align:left">nums.size</td>
<td style="text-align:left">返回映射的条目的数量</td>
</tr>
<tr>
<td style="text-align:left">nums(“ii”)</td>
<td style="text-align:left">获取指定键的关联值(返回2)</td>
</tr>
<tr>
<td style="text-align:left">nums.key</td>
<td style="text-align:left">返回键枚举器(返回字符串”i”, 和”ii”的Iterator)</td>
</tr>
<tr>
<td style="text-align:left">nums.keySet</td>
<td style="text-align:left">返回键集</td>
</tr>
<tr>
<td style="text-align:left">nums.values</td>
<td style="text-align:left">返回值枚举器(返回整数1,2 的Iterator)</td>
</tr>
<tr>
<td style="text-align:left">nums.isEmpty</td>
<td style="text-align:left">指明映射是否为空(返回false)</td>
</tr>
<tr>
<td style="text-align:left">import scala.collection.mutable</td>
<td style="text-align:left">引用可变集合类型</td>
</tr>
<tr>
<td style="text-align:left">val words = mutable.Map.empty[String,Int]</td>
<td style="text-align:left">创建空的可变集合</td>
</tr>
<tr>
<td style="text-align:left">words += (“one”-&gt;1)</td>
<td style="text-align:left">添加一条映射</td>
</tr>
<tr>
<td style="text-align:left">words -= “one”</td>
<td style="text-align:left">若存在映射条目,则删除</td>
</tr>
<tr>
<td style="text-align:left">words ++= List(“one” -&gt;1, “two”-&gt;2, “three”-&gt;3)</td>
<td style="text-align:left">添加多个映射条目</td>
</tr>
<tr>
<td style="text-align:left">words –= List(“one”, “two”)</td>
<td style="text-align:left">删除多个对象</td>
</tr>
</tbody>
</table>
<p> 默认的(Default)集和映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">工厂方法提供的实现都使用了快速查找算法,通常都涉及哈希表,因此他们能够快速反应对象是否存在于集合中,</div><div class="line">如scala.collection.mutable.Set() 工厂方法返回scala.collection.mutable.HashSet,则其在内部使用了哈希表</div><div class="line">类似的,scala.collection.mutable.Map() 工厂方法返回了scala.collection.mutable.HashMap</div><div class="line"></div><div class="line"></div><div class="line">不可变集和映射的情况更为复杂一些,例如:scala.collection.immutable.Set() 工厂方法返回的类,取决于你传递给他的元素, 具体说明参加下表,对于少于5个元素的集,类型完全取决于他的元素数量,以获得最优的性能,然而一旦你请求的集包含了5个元素以上,工厂方法返回的将是不可变的HashSet</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/scala_programming/17/3.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">类似的,scala.collection.immutable.Map()工厂方法返回的类取决于传递进去的键值对数量,参见下表,对于少于5个元素的不可变映射,类型完全取决于其键值对数量,以获得最优的性能,但如果包含了5个或以上的键值对,则使用的是不可变的HashMap</div></pre></td></tr></table></figure>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/scala_programming/17/4.png" alt=""></p>
<p> 有序的(Sorted) 集和映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">有时,可能你需要集或映射的枚举器能够返回那特定顺序排序的元素,为此,scala的集合库提供了SortedSet和SortedMap特质,这两个特质分别有类TreeSet和TreeMap实现,他们都使用了红黑树有序的保存元素(TreeSet类) 或键(TreeMap)类,具体的顺序取决于Ordered特质,集的元素类型或映射的键类型要么混入,要么能够隐式的转换成Ordered的特质,这些类只有不可变类型的版本</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; import scala.collection.immutable.TreeSet</div><div class="line">import scala.collection.immutable.TreeSet</div><div class="line"></div><div class="line">scala&gt; val ts = TreeSet(1,2,3,8,9)</div><div class="line">ts: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 2, 3, 8, 9)</div><div class="line"></div><div class="line">scala&gt; val cs = TreeSet(&apos;t&apos;,&apos;u&apos;,&apos;n&apos;)</div><div class="line">cs: scala.collection.immutable.TreeSet[Char] = TreeSet(n, t, u)</div><div class="line"></div><div class="line">scala&gt; import scala.collection.immutable.TreeMap</div><div class="line">import scala.collection.immutable.TreeMap</div><div class="line"></div><div class="line">scala&gt; val tm = TreeMap(3-&gt;&apos;x&apos;, 1-&gt;&apos;x&apos;, 4-&gt;&apos;x&apos;)</div><div class="line">tm: scala.collection.immutable.TreeMap[Int,Char] = Map(1 -&gt; x, 3 -&gt; x, 4 -&gt; x)</div><div class="line"></div><div class="line">scala&gt; tm</div><div class="line">res12: scala.collection.immutable.TreeMap[Int,Char] = Map(1 -&gt; x, 3 -&gt; x, 4 -&gt; x)</div></pre></td></tr></table></figure></p>
<p> 同步的集和映射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">我们曾经提到过如果需要线程安全的映射,可以把SynchronizedMap特质混入到你想要的特定类实现中,例如,把SynchronizedMap混入HashMap,</div><div class="line">*/</div><div class="line"></div><div class="line">import scala.collection.mutable</div><div class="line">import scala.collection.mutable.&#123;HashMap, Map, SynchronizedMap&#125;</div><div class="line">object MapMaker &#123;</div><div class="line">  def makMap:Map[String,String] = &#123;</div><div class="line">    new HashMap[String,String] with SynchronizedMap[String,String] &#123;</div><div class="line">      override def default(key: String): String = &quot;why do you want to know?&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">scala编译器将产生混入了SynchronizedMap的HashMap合成子类,并创建他的返回实例,这个合成子类还重载了名为default的方法</div><div class="line"></div><div class="line">如果你请求映射返回与特定键关联的值,而该键的映射实际不存在,默认你将得到NoSuchElementException,然而如果你定义了新的映射类并重载了default方法,那么这个新的映射将在查询不存在的键时返回default方法的返回值,这里是返回&quot;why do you want to know?&quot;</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">由于makeMap方法返回的可变映射混入了SynchronizedMap特质,因此可以立即用于多线程环境,每次对映射的访问都被同步操作,下面是单线程访问映射的情况:</div><div class="line">*/</div><div class="line">val capital = MapMaker.makeMap</div><div class="line">capital ++ List(&quot;us&quot;-&gt;&quot;Washington&quot;, &quot;paris&quot;-&gt;&quot;France&quot;,&quot;Japan&quot;-&gt;&quot;Tokyo&quot;)</div><div class="line">capital(&quot;Japan&quot;)    // Tokyo</div><div class="line">capital(&quot;New Zealand&quot;)    //why do you want to know?</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">对于同步的Set,同理可以创建SynchronizedSet特质创建同步的HashSet</div><div class="line">*/</div><div class="line">import scala.collection.mutable</div><div class="line">val synchroSet = new mutable.HashSet[Int] with mutable.SynchronizedSet[Int]</div><div class="line"></div><div class="line">/*</div><div class="line">对于同步,你也可以考虑使用java.util.concurrent的并发集合,又或者,还可以使用非同步的集合及scala的actor</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h1 id="4-可变-mutable-集合vs不可变-immutable-集合"><a href="#4-可变-mutable-集合vs不可变-immutable-集合" class="headerlink" title="4.可变(mutable)集合vs不可变(immutable)集合"></a>4.可变(mutable)集合vs不可变(immutable)集合</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">不可变集合比可变集合更为紧促,节省大量的空间</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; val people = Set(&quot;Nancy&quot;, &quot;Jane&quot;)</div><div class="line">people: scala.collection.immutable.Set[String] = Set(Nancy, Jane)</div><div class="line"></div><div class="line">scala&gt; people += &quot;Bob&quot;</div><div class="line">&lt;console&gt;:11: error: value += is not a member of scala.collection.immutable.Set[String]</div><div class="line">              people += &quot;Bob&quot;    //因为是val的,所以不能重新赋值</div><div class="line">                     ^</div><div class="line"></div><div class="line">scala&gt; var people = Set(&quot;Nancy&quot;, &quot;Jane&quot;)</div><div class="line">people: scala.collection.immutable.Set[String] = Set(Nancy, Jane)</div><div class="line"></div><div class="line">scala&gt; people += &quot;Bob&quot;</div><div class="line"></div><div class="line">scala&gt; people</div><div class="line">res15: scala.collection.immutable.Set[String] = Set(Nancy, Jane, Bob)</div><div class="line"></div><div class="line">/*</div><div class="line">尽管集合是不可变类型的,过程是:首先,创建集合,然后,people将被重新赋值为新集合</div><div class="line">经过一系列操作之后,people变量现在指向新的不可变集合,其中包含了添加的字符串&quot;Bob&quot;,同样的理念可以应用于以=结尾的方法,而不仅是+=方法,</div><div class="line">*/</div><div class="line">people -= &quot;Jane&quot;</div><div class="line">people ++= List(&quot;Tom&quot;, &quot;Harry&quot;)</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">如果你想使用可变集合,仅需要引用可变版本的Map即可,这样就可以重写对不可变Map的默认引用</div><div class="line">*/</div><div class="line"></div><div class="line">import scala.collection.mutable.Map   //唯一的改变</div><div class="line">var capital = Map(&quot;Us&quot;-&gt;&quot;Washington&quot;, &quot;France&quot;-&gt;&quot;Paris&quot;)</div><div class="line">capital += (&quot;Japan&quot;-&gt;&quot;Tokyo&quot;)</div></pre></td></tr></table></figure>
<h1 id="5-初始化集合"><a href="#5-初始化集合" class="headerlink" title="5.初始化集合"></a>5.初始化集合</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">最常见的创建和初始化集合的办法是把初始值传递给要用的集合类型的伴生对象的工厂方法,你只需把元素放在伴生对象名后面的括号中,scala编译器就会把它转化为该伴生对象的apply方法调用</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; List (1,2,3)</div><div class="line">res16: List[Int] = List(1, 2, 3)</div><div class="line"></div><div class="line">scala&gt; Set(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)</div><div class="line">res17: scala.collection.immutable.Set[Char] = Set(a, b, c)</div><div class="line"></div><div class="line">scala&gt; import scala.collection.mutable</div><div class="line">import scala.collection.mutable</div><div class="line"></div><div class="line">scala&gt; mutable.Map(&quot;hi&quot;-&gt;2,&quot;there&quot;-&gt;5)</div><div class="line">res19: scala.collection.mutable.Map[String,Int] = Map(hi -&gt; 2, there -&gt; 5)</div><div class="line"></div><div class="line">scala&gt; Array(1.0, 2.0, 3.0)</div><div class="line">res20: Array[Double] = Array(1.0, 2.0, 3.0)</div><div class="line"></div><div class="line">/*</div><div class="line">尽管通常都可以让scala编译器从传递给工厂方法的元素推断集合的元素类型,但有些时候或许你会希望指定以不同于编译器所选的类型创建集合,尤其对于可变集合来说更为如此</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; import scala.collection.mutable</div><div class="line">import scala.collection.mutable</div><div class="line"></div><div class="line">scala&gt; val stuff = mutable.Set(42)</div><div class="line">stuff: scala.collection.mutable.Set[Int] = Set(42)</div><div class="line"></div><div class="line">scala&gt; stuff += &quot;abcde&quot;</div><div class="line">&lt;console&gt;:14: error: type mismatch;</div><div class="line"> found   : String(&quot;abcde&quot;)</div><div class="line"> required: Int</div><div class="line">              stuff += &quot;abcde&quot;</div><div class="line">                       ^</div><div class="line"></div><div class="line">/*</div><div class="line">上面的问题在于stuff被指定元素类型为Int,如果想要让他的类型为Any,你需要明确的说明,把元素类型放在方括号中</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; val stuff = mutable.Set[Any](42)</div><div class="line">stuff: scala.collection.mutable.Set[Any] = Set(42)</div><div class="line"></div><div class="line">/*</div><div class="line">另一种特殊情况是,你想要把集合初始化为指定类型,例如:设想你要把列表中的元素保存在TreeSet中</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; val colors = List(&quot;blue&quot;, &quot;yellow&quot;,&quot;red&quot;)</div><div class="line">colors: List[String] = List(blue, yellow, red)</div><div class="line"></div><div class="line">//你不能把colors列表传递给TreeSet工厂方法</div><div class="line">scala&gt; import scala.collection.immutable.TreeSet</div><div class="line">import scala.collection.immutable.TreeSet</div><div class="line"></div><div class="line">scala&gt; val treeSet = TreeSet(colors)</div><div class="line">&lt;console&gt;:14: error: No implicit Ordering defined for List[String].</div><div class="line">       val treeSet = TreeSet(colors)</div><div class="line">                            ^</div><div class="line">//需要创建空的TreeSet[String] 对象并使用TreeSet的++ 操作符把列表元素加入其中</div><div class="line">scala&gt; val treeSet = TreeSet[String]() ++ colors</div><div class="line">treeSet: scala.collection.immutable.TreeSet[String] = TreeSet(blue, red, yellow)</div></pre></td></tr></table></figure>
<p> 数组与列表之间的互转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">如果你需要用集合初始化列表或数组,使用集合初始化列表,只需对集合调用toList方法</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; treeSet</div><div class="line">res22: scala.collection.immutable.TreeSet[String] = TreeSet(blue, red, yellow)</div><div class="line"></div><div class="line">scala&gt; treeSet.toList</div><div class="line">res23: List[String] = List(blue, red, yellow)</div><div class="line"></div><div class="line"></div><div class="line">//或者你需要的是数组</div><div class="line">scala&gt; treeSet.toArray</div><div class="line">res24: Array[String] = Array(blue, red, yellow)</div><div class="line"></div><div class="line">/*</div><div class="line">对TreeSet调用toList产生的列表元素是按照字母顺序排列的,如下</div><div class="line">*/.</div><div class="line">scala&gt; val test = TreeSet(&quot;ff&quot;, &quot;bb&quot;, &quot;ee&quot;, &quot;cc&quot;)</div><div class="line">test: scala.collection.immutable.TreeSet[String] = TreeSet(bb, cc, ee, ff)</div><div class="line"></div><div class="line">scala&gt; test.toList</div><div class="line">res25: List[String] = List(bb, cc, ee, ff)</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">请牢记:转变为列表或数组同样需要复制集合的所有元素,因此对于大型集合来说可能比较慢,所以toList和toArray对于小的Set转成List或者Array还是可以的</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p> 集和映射的可变与不可变互转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">另一种偶尔发生的情况是:把可变集或映射转换成不可变类型,或者反向转换,</div><div class="line">可以先创建空不可变集合,然后把可变集合的元素用++操作符添加进去</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; import scala.collection.mutable</div><div class="line">import scala.collection.mutable</div><div class="line"></div><div class="line">scala&gt; treeSet</div><div class="line">res26: scala.collection.immutable.TreeSet[String] = TreeSet(blue, red, yellow)</div><div class="line"></div><div class="line">scala&gt; val mutaSet = mutable.Set.empty ++ treeSet</div><div class="line">mutaSet: scala.collection.mutable.Set[String] = Set(red, blue, yellow)</div><div class="line"></div><div class="line">scala&gt; val immutaSet = Set.empty ++ mutaSet</div><div class="line">immutaSet: scala.collection.immutable.Set[String] = Set(red, blue, yellow)</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">使用同样的技巧实现可变映射与不可变映射之间的转换</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; val muta = mutable.Map(&apos;i&apos;-&gt;1, &quot;ii&quot;-&gt;2)</div><div class="line">muta: scala.collection.mutable.Map[Any,Int] = Map(ii -&gt; 2, i -&gt; 1)</div><div class="line"></div><div class="line">scala&gt; val immu = Map.empty ++ muta</div><div class="line">immu: scala.collection.immutable.Map[Any,Int] = Map(ii -&gt; 2, i -&gt; 1)</div></pre></td></tr></table></figure></p>
<h1 id="6-元组"><a href="#6-元组" class="headerlink" title="6.元组"></a>6.元组</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">元组可以把固定数量的条目组合在一起以便于作为整体传送,不像数组或列表,元组可以保存不同类型的对象,下面是可以作为整体保存整数,字符串,和控制台的元组</div><div class="line">*/</div><div class="line">(1, &quot;hello&quot;, Console)</div><div class="line"></div><div class="line">/*</div><div class="line">由于元组可以组合不同类型的对象,因此他不能继承自Iterator,如果你发现自己想要的是把&quot;一个&quot;整数和&quot;一个&quot;字符串组合在一起,那么你需要的就是元组,不是List,也不是Array</div><div class="line">*/</div><div class="line"></div><div class="line">//元组常用来返回方法的多个值,如:下面的方法找到集合中的最长单词并返回他的索引</div><div class="line">def longestWord(words: Array[String]) = &#123;</div><div class="line">  var word = words(0)</div><div class="line">  var idx = 0</div><div class="line">  for (i &lt;- 1 until words.length)</div><div class="line">    if (words(i).length &gt; word.length)</div><div class="line">      word = words(i)</div><div class="line">      idx = 1</div><div class="line">  (word,idx)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用</div><div class="line">scala&gt; val longest = longestWord(&quot;the quick brown fox&quot; split(&quot; &quot;))</div><div class="line">longest: (String, Int) = (quick,1)</div><div class="line"></div><div class="line"></div><div class="line">//访问元组的元素</div><div class="line">scala&gt; longest._1</div><div class="line">res27: String = quick</div><div class="line"></div><div class="line">scala&gt; longest._2</div><div class="line">res28: Int = 1</div><div class="line"></div><div class="line"></div><div class="line">//而且,你可以把元组的每个元素赋值给他自己的变量(这种模式实际上是模式匹配的特例)</div><div class="line">scala&gt; val (word, idx) = longest</div><div class="line">word: String = quick</div><div class="line">idx: Int = 1</div><div class="line"></div><div class="line">scala&gt; val word, idx = longest        //相当于为每个变量赋值</div><div class="line">word: (String, Int) = (quick,1)</div><div class="line">idx: (String, Int) = (quick,1)</div><div class="line">//每个变量被初始化为右侧表达式的单次执行结果</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第十七章 集合类型/" data-id="cj290sb9p007ossqq17jgum1v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/第十一章 scala的层级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第十一章 scala的层级/" class="article-date">
  <time datetime="2017-04-16T04:47:25.902Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第十一章 scala的层级/">第十一章 scala的层级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;在scala里,每个类都继承自通用的名为Any的超类,因为所有的类都是Any的子类,所以定义在Any中的方法就是”共同”的方法,他们可以被任何对象调用,scala还在层级的底端定义了一些有趣的类,如:Null,和Nothing,来扮演通用的子类,例如:如同Any是所有其他类的超类,Nothing是所有其他类的子类</p>
        
          <p class="article-more-link">
            <a href="/2017/04/16/scala编程/第十一章 scala的层级/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第十一章 scala的层级/" data-id="cj290sb9l007kssqqy06ynew4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/第六章 函数式对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第六章 函数式对象/" class="article-date">
  <time datetime="2017-04-16T04:47:25.901Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第六章 函数式对象/">第六章 函数式对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-类ration的规格说明书"><a href="#1-类ration的规格说明书" class="headerlink" title="1.类ration的规格说明书"></a>1.类ration的规格说明书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">有理数是一种可以表达式比率 n/d 的数字,这里n和d是数字,其中d不能为零,n被称为分子,d被称为分母</div></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/04/16/scala编程/第六章 函数式对象/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第六章 函数式对象/" data-id="cj290sb9i007hssqqh64xbx96" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/第八章 函数和闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第八章 函数和闭包/" class="article-date">
  <time datetime="2017-04-16T04:47:25.899Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第八章 函数和闭包/">第八章 函数和闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">作为某个对象的成员的函数,被称之为方法(method),</div><div class="line">*/</div><div class="line">import scala.io.Source</div><div class="line">object LongLines&#123;</div><div class="line">  def processFile(fileName: String, width: Int): Unit =&#123;</div><div class="line">    val source = Source.fromFile(fileName)</div><div class="line">    for (line &lt;- source.getLines())</div><div class="line">      processLine(fileName, width, line)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private def processLine(fileName: String, width: Int, line: String): Unit =&#123;</div><div class="line">    if (line.length&gt;width)</div><div class="line">      println(fileName + &quot;: &quot; + line.trim)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/04/16/scala编程/第八章 函数和闭包/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第八章 函数和闭包/" data-id="cj290sb9e007dssqqb8z0d193" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/第五章 基本类型和操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第五章 基本类型和操作/" class="article-date">
  <time datetime="2017-04-16T04:47:25.897Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第五章 基本类型和操作/">第五章 基本类型和操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">在scala中有如下的基本类型:Byte,Short,Int,Long,Char,String, Float, Double, Boolean,除了String归于java.lang包之外,其余所有的基本类型都是包scala的成员,如,Int的全名是scala.Int,然而,由于包scala和Java.lang的所有成员都被每个scala源文件自动引用,因此可以在任何地方只用简化名(也就是说,直接写成Boolean,Char或String)</div><div class="line"></div><div class="line">目前实际上scala值类型可以使用与Java的原始类型一致的小写化名称,比如,scala程序里可以用int替代Int,但请记住他们都是一回事,scala.Int, scala的社区实践提出的推荐风格是一直使用大写形式,这也是本书推荐的,将来scala的版本可能不再支持乃至移除小写化名称,因此跟随社区的趋势,在scala代码中使用Int而非int才是明智之举</div><div class="line">*/</div></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2017/04/16/scala编程/第五章 基本类型和操作/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第五章 基本类型和操作/" data-id="cj290sb9c007assqqx58zrkwb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/第二十章 抽象成员" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第二十章 抽象成员/" class="article-date">
  <time datetime="2017-04-16T04:47:25.895Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第二十章 抽象成员/">第二十章 抽象成员</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-抽象成员的快速浏览"><a href="#1-抽象成员的快速浏览" class="headerlink" title="1.抽象成员的快速浏览"></a>1.抽象成员的快速浏览</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">我们称不完全定义的类或特质的成员为抽象成员,抽象成员将被声明类的子类实现</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">下面的特质对每种抽象成员各声明了一个例子,他们分别是:类型(T), 方法(transform), val(initial) , 以及var(current):</div><div class="line">*/</div><div class="line">trait Abstrant &#123;</div><div class="line">  type T</div><div class="line">  def transform(x: T): T</div><div class="line">  val initial: T</div><div class="line">  val current: T</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Abstract的具体实现需要对每种抽象成员填入定义,下面的例子是提供这些定义的实现</div><div class="line">class Concrete extends Abstrant&#123;</div><div class="line">  type T = String</div><div class="line">  override def transform(x: String) = x + x</div><div class="line">  val initial= &quot;hi&quot;</div><div class="line">  override var current = initial</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">这个实现为类型T提供了具体的含义,他被定义为类型String的别名,transform被定义为参数字符串与其自身连接的操作,而initial和current值都被设置为&quot;hi&quot;</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="2-类型成员"><a href="#2-类型成员" class="headerlink" title="2.类型成员"></a>2.类型成员</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">抽象类型这个术语在scala中是指不带具体定义的,由&quot;type&quot;关键字声明为类或特质的成员的类型,类本身可以是抽象的,而特质本来就是抽象的,但不论哪种都不是scala中所指的抽象类型,scala的抽象乐行永远都是某个类或者特质的成员,就好像特质Abstract里的类型T那样</div><div class="line"></div><div class="line"></div><div class="line">你可以把非抽象的类型成员,如Concrete类里的类型T,想象成是类型定义新的名称,或别名的方式,例如Concrete类中,类型String被指定了别名T,因此,任何出现在Concrete定义中的T指的都是String,这也包含了transform的参数和结果类型initial,以及current,这些在Abstract超特质中声明的时候提到的T的成员,因此当Concrete类实现这些抽象成员的时候,所有的T都被解释为String</div><div class="line"></div><div class="line"></div><div class="line">使用类型成员的理由之一是为类型定义短小的,具有说明性的别名,因为类型的实际名称可能比别名更冗长,或语义不清,这种类型成员有助于净化类或特质的代码,类型成员的另一种主要用途是声明必须被定义为子类的抽象类型</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="3-抽象val"><a href="#3-抽象val" class="headerlink" title="3.抽象val"></a>3.抽象val</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//抽象val以如下形式定义</div><div class="line">val initial: String </div><div class="line"></div><div class="line">//他指明了val的名称和类型,但不指定值,该值必须由子类的具体val定义提供,例如:Concrete类以如下方式实现了val:</div><div class="line">val initial    = &quot;hi&quot;</div><div class="line"></div><div class="line">//抽象的val声明类似于抽象的无参数方法声明,如:</div><div class="line">def    initial: String</div><div class="line">/*</div><div class="line">如果initial是抽象val,那么客户就获得了保证,每次引用都将得到同样的值,如果initial是抽象方法,就不会获得这样的保证,因为在这种情况下initial可以实现为每次调用时都返回不同值的具体方法</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">abstract class Fruit&#123;</div><div class="line">  val v: String //&apos;v&apos;代表value(值)</div><div class="line">  def m: String //&apos;m&apos;代表method方法</div><div class="line">&#125;</div><div class="line">abstract class Apple extends Fruit&#123;</div><div class="line">  val v: String</div><div class="line">  val m: String //可以用&quot;val&quot; 重写def</div><div class="line">&#125;</div><div class="line">abstract class BadApple extends Fruit&#123;</div><div class="line">  def v: String //error , 不能用&quot;def&quot;重写val</div><div class="line">  def m: String</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">换句话说,抽象的val限制了合法的实现方式,任何实现都必须是val类型的定义,不可以是var或def,另一方面,抽象方法声明可以被实现为具体的方法定义或具体的val定义,</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="4-抽象var"><a href="#4-抽象var" class="headerlink" title="4.抽象var"></a>4.抽象var</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//与抽象val类似,抽象var只声明名称和类型,没有初始值,如下:</div><div class="line">trait AbstractTime&#123;</div><div class="line">  var hour: Int</div><div class="line">  var minute: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">类似于hour和minute这样的抽象var表达的是什么意思呢?在18.2节看到声明为类成员的var实际配备了getter和setter方法,对于抽象var来说也是如此,比如如果你声明了名为hour的抽象var,实际上是隐式声明了抽象getter方法,hour及抽象setter方法(hour_=) </div><div class="line">*/</div><div class="line">trait AbstractTime&#123;</div><div class="line">  def hour: Int //&apos;hour&apos; 的getter方法</div><div class="line">  def hour_=(x:Int) //&quot;hour&quot; 的setter方法</div><div class="line">  def minute: Int //&quot;minute&quot;的getter方法</div><div class="line">  def minute_=(x:Int) //&apos;minute&apos;的setter方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-初始化抽象val"><a href="#5-初始化抽象val" class="headerlink" title="5.初始化抽象val"></a>5.初始化抽象val</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">抽象val有时会扮演类似于超类的参数这样的角色:他们能够让你在子类中提供超类缺少的细节信息,这对于特质来说尤其重要,因为特质缺少能够用来传递参数的构造器,因此通常参数化特质的方式就是通过需要在子类中实现的抽闲val完成</div><div class="line">*/</div><div class="line">trait RationalTrait &#123;</div><div class="line">  val numerArg: Int</div><div class="line">  val denomArg: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">//实现</div><div class="line">new RationalTrait &#123;</div><div class="line">  override val denomArg: Int = 1</div><div class="line">  override val numerArg: Int = 1</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">这里关键字new出现在特质名称(RationalTrait)之前,然后是花括号包围的类结构体,这个表达式可以产生混入了特质并被结构体定义的匿名类实例,这种特使的匿名类实例化结果与使用new Rational(1,2)的方式创建的实例具有类似的效果,不过这种类比并非完美,两者在表达式的初始化顺序方面存在着微妙的差别</div><div class="line">*/ </div><div class="line">//当你写下:</div><div class="line">new Rational(expr1, expr2)</div><div class="line"></div><div class="line">//两个表达式,expr1和expr2会在类Rational初始化之前计算,因此在执行类的初始化操作是expr1和expr2的值已经可用,然而对于特质来说,情况正好相反,当你写下:</div><div class="line">new RationalTrait&#123;</div><div class="line">    val numerArg = expr1</div><div class="line">    val denomArg = expr2</div><div class="line">&#125;</div><div class="line">//表达式expr1和expr2被作为匿名初始化的一部分计算,但匿名类的初始化在RationalTrait之后,因此numerArg和denomArg的值在RationalTrait初始化期间还没有主备好(更为精确的说,选用任何值都将得到Int类型的默认值,0),对于之前的RationalTrait定义来说,这不是问题,因为特质的初始化没有用到numerArg和denomArg的值,但是对于下面的代码来说就成为一个问题,因为其中定义了经过约分的分子和分母</div><div class="line">trait RationalTrait&#123;</div><div class="line">  val numerArg: Int</div><div class="line">  val denomArg: Int</div><div class="line">  require(denomArg != 0)</div><div class="line"></div><div class="line">  private val g = gcd(numerArg, denomArg)</div><div class="line"></div><div class="line">  val number = numerArg / g</div><div class="line">  val denom = denomArg / g</div><div class="line"></div><div class="line">  private def gcd(a:Int, b:Int): Int =</div><div class="line">    if (b == 0) a else gcd(b, a%b)</div><div class="line"></div><div class="line">  override def toString = number + &quot;/&quot; + denom</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试</div><div class="line"></div><div class="line">scala&gt; new RationalTrait&#123;</div><div class="line">     | val numerArg = 1*x</div><div class="line">     | val denomArg = 2*x</div><div class="line">     | &#125;</div><div class="line">java.lang.IllegalArgumentException: requirement failed</div><div class="line">        at scala.Predef$.require(Predef.scala:221)</div><div class="line">        at RationalTrait$class.$init$(&lt;console&gt;:10)</div><div class="line">        at $anon$1.&lt;init&gt;(&lt;console&gt;:10)</div><div class="line">        at .&lt;init&gt;(&lt;console&gt;:10)</div><div class="line">        at .&lt;clinit&gt;(&lt;console&gt;)</div><div class="line">        at .&lt;init&gt;(&lt;console&gt;:7)</div><div class="line"></div><div class="line">/*</div><div class="line">出错的原因是:当类RationalTrait初始化的时候,denomArg仍然为他的默认值0,使得require调用失败</div><div class="line">上述例子演示了类参数和抽象字段的初始化顺序并不一致,类参数在被传递给构造器之前计算(除非参数是传名的),相反子类对于val定义的实现,是在超类完成了初始化之后执行的</div><div class="line">*/</div></pre></td></tr></table></figure>
<blockquote>
<p>fields预初始化字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">第一种解决方案,预初始化字段,可以让你在调用超类之前初始化子类的字段,操作的方式是把字段加上花括号,放在超类构造器调用之前,</div><div class="line">*/</div><div class="line">new &#123;</div><div class="line">  val numerArg = 1*x</div><div class="line">  val denomArg = 2*x</div><div class="line">&#125; with RationalTrait</div><div class="line"></div><div class="line"></div><div class="line">//预初始化字段不仅限于匿名类,他们还可以被用于对象或有名称的子类</div><div class="line"></div><div class="line">//预初始化段落在每个例子中都被定义的对象或类的extends关键字之后</div><div class="line">object twoThirds extends &#123;</div><div class="line">  val numerArg = 2</div><div class="line">  val denomArg = 3</div><div class="line">&#125; with RationalTrait</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">由于预初始化的字段在超类构造器调用之前被初始化,因此他们的初始化器不能引用正被构造的对象,相应的结果是,如果有引用this的这种初始化器,那么实际指向的是包含了正被构造的类或对象的对象,而不是被构造对象本身</div><div class="line">*/</div><div class="line">scala&gt; new &#123;</div><div class="line">     | val numerArg = 1</div><div class="line">     | val denomArg = this.numerArg*2</div><div class="line">     | &#125; with RationalTrait</div><div class="line">&lt;console&gt;:11: error: value numerArg is not a member of object $iw</div><div class="line">              val denomArg = this.numerArg*2</div><div class="line">                                  ^</div><div class="line">/*</div><div class="line">上述例子编译通过的原因在于this.numerArg引用是在包含new的对象中numerArg字段(这个例子中是指名为$iw的合成对象,解释器会把用户输出的语句放在这个对象中)</div><div class="line">*/</div><div class="line"></div><div class="line">//示例了如何在超特质的初始化过程中使用类参数的通用模式</div><div class="line">class RationalClass(n: Int, d:Int) extends &#123;</div><div class="line">  val numerArg = n</div><div class="line">  val denomArg = d</div><div class="line">&#125;with RationalTrait&#123;</div><div class="line">  def + (that: RationalClass) = new RationalClass(</div><div class="line">    number * that.denom + that.number*denom, denom * that.denom</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>懒加载val<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">如果你把lazy修饰符前缀val定义上,那么右侧的初始化表达式直到val第一次被使用的时候才计算</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">scala&gt; object Demo&#123;</div><div class="line">     | val x = &#123;println(&quot;initializing x&quot;); &quot;done&quot;&#125;</div><div class="line">     | &#125;</div><div class="line">defined module Demo</div><div class="line"></div><div class="line">scala&gt; Demo</div><div class="line">initializing x</div><div class="line">res6: Demo.type = Demo$@3d0035d2</div><div class="line"></div><div class="line"></div><div class="line">scala&gt; Demo.x</div><div class="line">res7: String = done</div><div class="line">/*</div><div class="line">发现,用到Demo的时候,他的x字段就完成了初始化,x的初始化成为了Demo初始化的一部分</div><div class="line">*/</div><div class="line"></div><div class="line">//将x字段定义为lazy</div><div class="line"></div><div class="line">scala&gt; object Demo&#123;</div><div class="line">     | lazy val x = &#123;println(&quot;initialing x&quot;); &quot;done&quot;&#125;</div><div class="line">     | &#125;</div><div class="line">defined module Demo</div><div class="line"></div><div class="line">scala&gt; Demo</div><div class="line">res8: Demo.type = Demo$@3c78e551</div><div class="line"></div><div class="line">scala&gt; Demo.x</div><div class="line">initialing x</div><div class="line">res9: String = done</div><div class="line"></div><div class="line">scala&gt; Demo.x</div><div class="line">res10: String = done</div><div class="line"></div><div class="line">/*</div><div class="line">初始化Demo不会执行初始化x的调用,x的初始化将延迟到第一次使用x的时候</div><div class="line">第一次计算懒加载val的时候结果就被保存了下来,以备同样的val后续使用</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">trait RationalTrait&#123;</div><div class="line">  val numerArg: Int</div><div class="line">  val denomArg: Int</div><div class="line"></div><div class="line">  private lazy val g = &#123;</div><div class="line">    require(denomArg != 0)</div><div class="line">    gcd(numerArg, denomArg)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  lazy val numer = numerArg / g</div><div class="line">  lazy val denom = denomArg / g</div><div class="line"></div><div class="line">  override def toString = numer + &quot;/&quot; + denom</div><div class="line"></div><div class="line">  private def gcd(a:Int, b:Int): Int =</div><div class="line">    if (b == 0) a else gcd(b, a%b)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试</div><div class="line">scala&gt; val x = 2</div><div class="line">x: Int = 2</div><div class="line"></div><div class="line">scala&gt; new RationalTrait&#123;</div><div class="line">     | val numerArg = 1*x</div><div class="line">     | val denomArg = 2*x</div><div class="line">     | &#125;</div><div class="line">res13: RationalTrait = 1/2</div><div class="line"></div><div class="line">//执行过程</div><div class="line">/*</div><div class="line">1.首先,RationalTrait的新实例被创建出来,特质的初始化代码被运行,该初始化代码为空,没有任何字段被初始化</div><div class="line">2.之后,有new表达式定义的匿名子类的主构造器被执行,他把numerArg初始化为2,把denomArg初始化为4</div><div class="line">3.之后,解释器调用了构造器对象的toString方法,结果值被打印出来</div><div class="line">4.之后,numer字段被特质RationalTrait的toString方法首次访问,因此它的初始化器执行计算</div><div class="line">5.numer的初始化器访问了私有字段g,因此g接下来被初始化计算,这次计算访问了numerArg和denomArg,他们定义在第二步</div><div class="line">6.之后,toString方法访问了denom值,引发denom的计算,这次访问计算了denomArg和g的值,g字段的初始化器不再重新计算,因为他已经在第五步执行过</div><div class="line">7.最终,结果字符串&quot;1/2&quot;被构造出来并被打印</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">请注意,在RationalTrait类中,g的定义在代码文本中处于numer和denom定义之后,尽管如此,因为所有的三个值都是懒加载的,所以g将在numer和denom完成初始化之前被初始化,这说明了懒加载val的一个很重要的属性,定义的文本顺序不用多加考虑,因为初始化是按需的,从而,懒加载val可以免去你作为程序员不得不认真考虑的问题,及如何安排val定义顺序,以确保所有东西在需要的时候已经完成定义</div><div class="line">*/</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="6-抽象类型"><a href="#6-抽象类型" class="headerlink" title="6.抽象类型"></a>6.抽象类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">与所有其他抽象声明一样,抽象类型声明也是将在子类中具体定义的事务的占位符,这里,他是将在之后的类层次中定义的类型,因此上文的T是对在声明点尚不可知的类型的引用,不同的子类可以提供不同的T实现</div><div class="line">*/</div><div class="line"></div><div class="line">//假设给了你一个为动物饮食习惯建模的任务,你或许会以Food类和带有eat方法的Animal类开始工作</div><div class="line">class Food</div><div class="line">abstract class Animal &#123;</div><div class="line">  def eat(food: Food)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//然后你或许尝试把这两个类特化为Cow类吃Grass类(牛吃草)</div><div class="line">class Grass extends Food</div><div class="line">class Cow extends Animal&#123;</div><div class="line">  override def eat(food: Grass) = &#123;&#125;//不能编译</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">这里的情况是Cow类的eat方法不能重写Animal类的eat方法,因为参数类型不同---Cow类里是Grass, 而Animal类里是Food</div><div class="line">*/</div><div class="line"></div><div class="line">//为什么要做这样的限制?</div><div class="line">class Food</div><div class="line">abstract class Animal &#123;</div><div class="line">  def eat(food: Food)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Grass extends Food</div><div class="line">class Cow extends Animal&#123;</div><div class="line">  override def eat(food: Grass) = &#123;&#125;//不能编译,不过如果能够编译通过的话,...</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Fish extends Food</div><div class="line">val bessy: Animal = new Cow</div><div class="line">bessy eat (new Fish)  //.....你将能用鱼喂牛</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">你应该做的是采用更为精确的建模方式,Animal的确吃Food,但Animal具体吃什么类型的Food取决于Animal,这可以使用抽象类型干净的表示出来</div><div class="line">*/</div><div class="line">class Food</div><div class="line">abstract class Animal&#123;</div><div class="line">  type SuitableFood &lt;: Food</div><div class="line">  def eat(food: SuitableFood)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">有了新的定义,Animal就可以只吃适合的食物了,不过到底什么食物合适,这并不在Animal类的层面决定,这也就是SuitableFood被建模为抽象类型的原因,具体具有上界约束:Food,表达为&quot; &lt;:Food &quot; 子句,说明任何(Animal子类中的)SuitableFood的具体实例化结果都必须是Food的子类</div><div class="line">*/</div><div class="line">class Grass extends Food</div><div class="line">class Cow extends Animal&#123;</div><div class="line">  type SuitableFood = Grass</div><div class="line">  def eat(food: Grass)&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="7-路径依赖类型"><a href="#7-路径依赖类型" class="headerlink" title="7.路径依赖类型"></a>7.路径依赖类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">通常情况下,不同的路径将产生不同的依赖</div><div class="line">*/</div><div class="line">class DogFood extends Food</div><div class="line">class Dog extends Animal&#123;</div><div class="line">  override type SuitableFood = DogFood</div><div class="line">  override def eat(food: DogFood) = &#123;&#125;</div><div class="line">&#125;</div><div class="line">//如果你尝试把牛的饲料用来喂狗,你的代码将无法通过编译</div><div class="line"></div><div class="line">scala&gt; val bessy = new Cow</div><div class="line">bessy: Cow = Cow@59edb4f5</div><div class="line"></div><div class="line">scala&gt; val lassie = new Dog</div><div class="line">lassie: Dog = Dog@7ea2412c</div><div class="line"></div><div class="line">scala&gt; lassie eat (new bessy.SuitableFood)</div><div class="line">&lt;console&gt;:16: error: type mismatch;</div><div class="line"> found   : Grass</div><div class="line"> required: DogFood</div><div class="line">              lassie eat (new bessy.SuitableFood)</div><div class="line">                          ^</div><div class="line">/*</div><div class="line">问题在于传递给eat方法的SuitableFood对象的类型(bessy.SuitableFood), 不能匹配eat的参数类型,lassie.SuitableFood,然而如果同样是Dog的话,情况会不一样,因为Dog的SuitableFood类型被定义为DogFood类的别名,所以对于两条Dog来说,他们的SuitableFood类型实际上是一样的,</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; val bootsie = new Dog</div><div class="line">bootsie: Dog = Dog@11381415</div><div class="line"></div><div class="line">scala&gt; lassie eat (new bootsie.SuitableFood)</div><div class="line"></div><div class="line">scala&gt;</div><div class="line"></div><div class="line">/*</div><div class="line">路径依赖类型会让我们想起java中的内部类语法,但两者有决定性的差别:路径依赖类型表达了外在的对象,而内部类表达了外在的类</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">class Outer&#123;</div><div class="line">  class Inner</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">scala中,内部类的表达形式为Outer#Inner, 而不是java的Outer.Inner ,&quot;.&quot; 语法保留给对象使用,例如,假设你实例化了类型Outer的两个对象</div><div class="line">*/</div><div class="line">val o1 = new Outer</div><div class="line">val o2 = new Outer</div><div class="line">/*</div><div class="line">这里o1.Inner和o2.Inner是两个路径依赖类型,o1.Inner类型是指特定(o1引用的)外部对象的Inner类</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">//实例化内部类</div><div class="line">new o1.Inner   //因为o1.Inner是属于o1对象的内部类,所以new o1.Inner是new出来的对象</div><div class="line">//返回的内部对象将包含其外部对象的引用,即o1的对象引用,相反Outer#Inner没有指明任何特定Outer实例,因此你不能创建他的实例</div><div class="line">new Outer#Inner    //error</div></pre></td></tr></table></figure>
<h1 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">scala中如果想要创建新的枚举,只需要定义扩展scala.&apos;Enumeration这个类的对象即可</div><div class="line">*/</div><div class="line"></div><div class="line">object Color extends Enumeration&#123;</div><div class="line">  val Red = Value</div><div class="line">  val Green = Value</div><div class="line">  val Blue = Value</div><div class="line">&#125;</div><div class="line">//等价于</div><div class="line">object Color extends Enumeration&#123;</div><div class="line">  val Red, Green, Blue = Value</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">这个对象定义提供了三个值:Color.Red, Color.Green, Color.Blue,你可以引用Color的全部内容:</div><div class="line">*/</div><div class="line">import Color._</div><div class="line">//然后简单写成Red, Green, 和Blue ,但这些值的类型是什么?Enumeration定义了内部类,名为Value,以及同名的无参方法Value返回该类的新对象,也就是说诸如Color.Red类的值类型是Color.Value,而Color.Value也正是定义在对象Color中的所有枚举值的类型,他是路径依赖类型,其中Color是路径,Value是依赖类型,这里很重要的一点是他是全新的类型,与其他所有的类型都不一样</div><div class="line"></div><div class="line">object Direction extends Enumeration&#123;</div><div class="line">  val North, East, South, West = Value</div><div class="line">&#125;</div><div class="line">//Direction.Value与Color.Value不同,因为两种类型的路径部分不同</div><div class="line"></div><div class="line"></div><div class="line">//scala的Enumeration类还提供了其他语言的枚举设计中所拥有的许多其他特质,你可以通过使用Value方法不同的重载变体把名称与枚举值联系起来</div><div class="line">object Direction extends Enumeration&#123;</div><div class="line">  val North = Value(&quot;North&quot;)</div><div class="line">  val East = Value(&quot;East&quot;)</div><div class="line">  val South = Value(&quot;South&quot;)</div><div class="line">  val West = Value(&quot;West&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//遍历枚举的所有值</div><div class="line">for(d &lt;-Direction) print(d+&quot; &quot;)    //North East South West</div><div class="line"></div><div class="line">//枚举值从0开始计数,你可以用枚举值的id方法获得他的计数值</div><div class="line">scala&gt; Direction.East.id</div><div class="line">res20: Int = 1</div><div class="line"></div><div class="line">//也可以反过来,通过非零的整数获得id为该数的枚举值</div><div class="line">scala&gt; Direction(1)</div><div class="line">res19: Direction.Value = East</div></pre></td></tr></table></figure>
<h1 id="9-案例研究-货币"><a href="#9-案例研究-货币" class="headerlink" title="9.案例研究:货币"></a>9.案例研究:货币</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line">//本章的剩余部分提供了一个解释scala中如何使用抽象类型的案例研究,任务是设计Currency类,典型的Currency实例可以代表美元,欧元,日元,或其他货币种类的一笔金额,而且还有可能需要一些关于货币方面的计算,比方说,相同货币的两笔金额应该能够相加,或金额应该能够乘上代表利率的因子</div><div class="line"></div><div class="line">abstract class Currency&#123;</div><div class="line">  val amount: Long    //金额大小</div><div class="line">  def designation: String    //标识货币的字符串</div><div class="line"></div><div class="line">  override def toString: String = amount + &quot; &quot; + designation</div><div class="line">  def +(that: Currency): Currency =     ...</div><div class="line">  def *(x:Double): Currency =   ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">//产生的结果如下:</div><div class="line">79 USD</div><div class="line">11000 Yen</div><div class="line">99 Euro</div><div class="line"></div><div class="line">//抽象的实现</div><div class="line">new Currency &#123;</div><div class="line">  override val amount: Long = 79L</div><div class="line">  override def designation = &quot;USD&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//如果我们仅仅是对单一货币建模,那么这种设计不存在问题,可是一旦我们需要处理若干货币种类,这样做就不行了,假设你对美元和欧元建模为货币类的两个子类</div><div class="line">abstract class Dollar extends Currency&#123;</div><div class="line">  override def designation = &quot;USD&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class Euro extends Currency&#123;</div><div class="line">  override def designation = &quot;Euro&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">上面的做法看上去很有道理,但是在执行加法的时候将两种货币放在一起感觉古怪,你要的应该是+方法更具体化的版本,实现在Dollar类中的时候,他应该带Dollar参数并产生Dollar结果,实现在Euro类中的时候,应该带Euro参数并产生Euro结果,因此加法的类型应该依赖于所在类而改变,尽管如此,你还是希望方法只写一次即可,而不是每次定义新的货币都要重写</div><div class="line">*/</div><div class="line">//第二版</div><div class="line">abstract class AbstractCurrency&#123;</div><div class="line">  type Currncy &lt;:AbstractCurrency</div><div class="line">  val amount: Long</div><div class="line">  def designation: String</div><div class="line">  override def toString: String = amount + &quot; &quot; + designation</div><div class="line">  def +(that: Currency): Currency =   ...</div><div class="line">  def *(x: Double): Currency =   ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">//第二版与前面的一版的却别在于:类现在成为AbstractCurrency,并且包含了抽象类型Currency,代表未知的真实货币种类,每种AbstractCurrency的具体子类将需要把Currency类型修改为这个类本身,从而能够把两者结合在一起</div><div class="line">//使用</div><div class="line">abstract class Dollar extends AbstractCurrency&#123;</div><div class="line">  override type Currncy = Dollar</div><div class="line">  override def designation = &quot;USD&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">这个设计仍不完美,问题之一是隐藏在AbstractCurrency类省略号中的方法定义+和* 如何具体化? 像下面这样吗?</div><div class="line">*/</div><div class="line">def +(that: Currency): Currency = new Currency &#123;</div><div class="line">  val amount = this.amount + that.amount</div><div class="line">&#125;</div><div class="line">//编译不通过,因为scala对待抽象类型的一种限制是你既不能创建抽象类型的实例,也不能把抽象类型当做其他类的超类型,因此编译器将拒绝上面例子的代码实例化Currency的尝试</div><div class="line">//解决的方法是通过工厂方法</div><div class="line">abstract  class CurrencyZone&#123;</div><div class="line">  type Currency &lt;: AbstractCurrency</div><div class="line">  def make(x: Long): Currency</div><div class="line">  abstract class AbstractCurrency&#123;</div><div class="line">    val amount: Long</div><div class="line">    def designation: String</div><div class="line">    override def toString: String = amount + &quot; &quot; + designation</div><div class="line">    def +(that: Currency): Currency = new Currency &#123;</div><div class="line">      make((this.amount + that.amount))</div><div class="line">    &#125;</div><div class="line">    def *(x: Double): Currency =</div><div class="line">      make((this.amount*x).toLong)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//实现</div><div class="line">object US extends Currency&#123;</div><div class="line">  abstract class Dollar extends AbstractCurrency&#123;</div><div class="line">    def designation = &quot;USD&quot;</div><div class="line">  &#125;</div><div class="line">  type Currency = Dollar</div><div class="line">  def make(x:Long) = new Dollar &#123;val amount = x&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">上面的情况是:每种货币都仅用一个测量单位:美元,欧元,或日元,然而大多数货币都有子单位,例如:在美国有美元和美分,下面将引入CurrencyUnit字段,以包含货币一个标准单位的金额</div><div class="line">*/</div><div class="line">//实现2</div><div class="line">object US extends Currency&#123;</div><div class="line">  abstract class Dollar extends AbstractCurrency&#123;</div><div class="line">    def designation = &quot;USD&quot;</div><div class="line">  &#125;</div><div class="line">  type Currency = Dollar</div><div class="line">  def make(cents:Long) = new Dollar &#123;val amount = cents&#125;</div><div class="line">  val Cent = make(1)  //美分</div><div class="line">  val Dollar = make(100)  //美元</div><div class="line">  val CurrencyUnit = Dollar</div><div class="line">&#125;</div><div class="line"></div><div class="line">//改进toString方法,例如:10美元与23美分的总和应该打印成小数:10.23USD</div><div class="line">override def toString: String = ((amount.toDouble/CurrencyUnit.amount.toDouble) formatted (</div><div class="line">  &quot;%.&quot;+decimals(CurrencyUnit.amount) + &quot;f&quot;))</div><div class="line"></div><div class="line">private def decimals(n: Long): Int =</div><div class="line">  if (n == 1) 0 else 1+decimals(n/10)</div><div class="line"></div><div class="line"></div><div class="line">//改进:添加货币特征转换,首先,你可以编写Converter对象,以包含适用的货币汇率</div><div class="line">object Converter&#123;</div><div class="line">  var exchangeRate = Map&#123;</div><div class="line">    &quot;USD&quot; -&gt; Map(&quot;USD&quot;-&gt;1.0, &quot;EUR&quot;-&gt;0.7596, &quot;JPY&quot;-&gt;1.211, &quot;CHF&quot;-&gt;1.223)</div><div class="line">    &quot;EUR&quot;-&gt; Map(&quot;USD&quot;-&gt;1.316, &quot;EUR&quot;-&gt;1.0, &quot;JPY&quot;-&gt;1.594, &quot;CHF&quot;-&gt;1.623)</div><div class="line">    &quot;JPY&quot;-&gt; Map(&quot;USD&quot;-&gt;0.8257, &quot;EUR&quot;-&gt;0.6272, &quot;JPY&quot;-&gt;1.0, &quot;CHF&quot;-&gt;1.018)</div><div class="line">    &quot;CHF&quot;-&gt; Map(&quot;USD&quot;-&gt;0.8108, &quot;EUR&quot;-&gt;0.6160, &quot;JPY&quot;-&gt;0.982, &quot;CHF&quot;-&gt;1.0)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">def from(other: CurrencyZone#AbstractCurrency): Currency =</div><div class="line">  make(Math.round(</div><div class="line">    other.amount.toDouble * Converter.exchangeRate(other.designation)(this.designation)</div><div class="line">  ))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//总代码</div><div class="line"></div><div class="line">abstract  class CurrencyZone&#123;</div><div class="line">  type Currency &lt;: AbstractCurrency</div><div class="line">  def make(x: Long): Currency</div><div class="line">  abstract class AbstractCurrency&#123;</div><div class="line">    val amount: Long</div><div class="line">    def designation: String</div><div class="line">    override def toString: String = amount + &quot; &quot; + designation</div><div class="line">    def +(that: Currency): Currency = new Currency &#123;</div><div class="line">      make((this.amount + that.amount))</div><div class="line">    &#125;</div><div class="line">    def *(x: Double): Currency =</div><div class="line">      make((this.amount*x).toLong)</div><div class="line">  &#125;</div><div class="line">  def from(other: CurrencyZone#AbstractCurrency): Currency =</div><div class="line">    make(Math.round(</div><div class="line">      other.amount.toDouble * Converter.exchangeRate(other.designation)(this.designation)</div><div class="line">    ))</div><div class="line">  private def decimals(n: Long): Int =</div><div class="line">    if (n == 1) 0 else 1+decimals(n/10)</div><div class="line"></div><div class="line">  override def toString: String = ((amount.toDouble/CurrencyUnit.amount.toDouble) formatted (</div><div class="line">    &quot;%.&quot;+decimals(CurrencyUnit.amount) + &quot;f&quot;</div><div class="line">    ))</div><div class="line">  val CurrencyUnit: Currency</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第二十章 抽象成员/" data-id="cj290sb990076ssqq0jgdutj4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/第九章 控制抽象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第九章 控制抽象/" class="article-date">
  <time datetime="2017-04-16T04:47:25.893Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第九章 控制抽象/">第九章 控制抽象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-减少代码重复"><a href="#1-减少代码重复" class="headerlink" title="1.减少代码重复"></a>1.减少代码重复</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">//需求:查询当前路径下的所有的文件,找到指定字符结束的文件或目录</div><div class="line">object FileMatcher&#123;</div><div class="line">  private def fileHere = (new java.io.File(&quot;.&quot;)).listFiles</div><div class="line"></div><div class="line">  def filesEnding(query: String) =</div><div class="line">    for (file &lt;-fileHere if file.getName.endsWith(query))</div><div class="line">      yield file</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">由于fileHere是私有的,filesEnding方法是定义在提供用户的API,FileMatcher中唯一可以访问的方法</div><div class="line">*/</div><div class="line"></div><div class="line">//需求:查询当前路径下的所有的文件,找到指定字符的文件或目录(并不一定是文件结尾)</div><div class="line">def filesContaining(query: String) =</div><div class="line">  for (file &lt;-fileHere if file.getName.contains(query))</div><div class="line">    yield file</div><div class="line"></div><div class="line"></div><div class="line">//后来客户又有了一个需求:他们要求基本正则表达式匹配文件,为了支持他们,于是你,写了下面的代码:</div><div class="line">def filesRegex(query: String) =</div><div class="line">  for (file &lt;-fileHere if file.getName.matches(query))</div><div class="line">    yield file</div><div class="line"></div><div class="line">/*</div><div class="line">综合上面的三个需求,他们之间唯一的不同就是最后匹配文件的方法不同,第一个是endsWith,第二个是contains,第三个是matches,所以你或许希望有这样的代码:</div><div class="line">*/</div><div class="line">def filesMatching(query: String, method) =</div><div class="line">  for (file &lt;-fileHere if file.getName.method(query))</div><div class="line">    yield file</div><div class="line"></div><div class="line">//具体实现如下:</div><div class="line">def filesMatching(query: String, matcher: (String, String)=&gt;Boolean) =</div><div class="line">  for (file &lt;-fileHere if matcher(file.getName, query))</div><div class="line">    yield file</div><div class="line"></div><div class="line">//有了新的filesMatching帮助方法,上面的三个搜索方法可以简化成如下:</div><div class="line">def filesEnding(query: String) =</div><div class="line">  filesMatching(query,_.endsWith(_))</div><div class="line"></div><div class="line">def filesContaining(query: String) =</div><div class="line">  filesMatching(query, _.contains(_))</div><div class="line"></div><div class="line">def filesRegex(query: String) =</div><div class="line">  filesMatching(query, _.matches(_))</div><div class="line"></div><div class="line">/*</div><div class="line">其实像_.endsWith(_)这样的函数是使用了占位符语法,原函数可以写成如下的形式:</div><div class="line">*/</div><div class="line">(fileName: String, query: String) =&gt; fileName.endsWith(query)</div><div class="line">//filesMatching函数需要一个参数,这个参数是函数,类型为(String, String)=&gt;Boolean,所以我们在传参的时候可以不用指定参数类型,因此写成下面的样子:</div><div class="line">(fileName, query) =&gt; fileName.endsWith(query)</div><div class="line"></div><div class="line">//在传参的过程中,第一个参数fileName在方法体重被第一个使用,第二个参数query被第二个使用,因此你可以使用占位符语法:</div><div class="line">_.endsWith(_)</div><div class="line"></div><div class="line"></div><div class="line">//更加简化的形式</div><div class="line">object FileMatcher&#123;</div><div class="line">  private def fileHere = (new java.io.File(&quot;.&quot;)).listFiles</div><div class="line"></div><div class="line">  def filesMatching( matcher: (String)=&gt;Boolean) =</div><div class="line">    for (file &lt;-fileHere if matcher(file.getName))</div><div class="line">      yield file</div><div class="line">  def filesEnding(query: String) =</div><div class="line">    filesMatching(_.endsWith(query))</div><div class="line"></div><div class="line">  def filesContaining(query: String) =</div><div class="line">    filesMatching(_.contains(query))</div><div class="line"></div><div class="line">  def filesRegex(query: String) =</div><div class="line">    filesMatching(_.matches(query))</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">以上代码就使用了闭包的特性,其中的query就是一个自由变量</div><div class="line">在Java中的做法就是将公共的部分抽取出来形成接口,然后对接口进行实现</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="2-简化客户代码"><a href="#2-简化客户代码" class="headerlink" title="2.简化客户代码"></a>2.简化客户代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//一个判断传入的值是否包含在集合中的方法:</div><div class="line">#指令式编程的做法</div><div class="line">def containsNeg(nums: List[Int]): Boolean=&#123;</div><div class="line">  var exists = false</div><div class="line">  for (num &lt;- nums)&#123;</div><div class="line">    if (num&lt;0)</div><div class="line">      exists = true</div><div class="line">  &#125;</div><div class="line">  exists</div><div class="line">&#125;</div><div class="line">//调用</div><div class="line">containsNeg(List(1, 2, 3, 4))</div><div class="line"></div><div class="line">//函数式编程</div><div class="line">def containsNeg2(nums: List[Int]) = nums.exists(_ &lt; 0)</div><div class="line">containsNeg2(List(1, 2, 3, 4))</div><div class="line"></div><div class="line">/*</div><div class="line">传过去的是一个函数: _&lt;0, 该函数值需要一个参数,</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="3-柯里化"><a href="#3-柯里化" class="headerlink" title="3.柯里化"></a>3.柯里化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">柯里化的函数被应用于多个参数列表,而不仅仅一个</div><div class="line">*/</div><div class="line">//未被柯里化的函数</div><div class="line">def plainOldSum(x: Int, y:Int) = x + y</div><div class="line">//调用</div><div class="line">plainOldSum(1, 2)</div><div class="line"></div><div class="line"></div><div class="line">//被柯里化的函数,把这个函数应用于连个列表的各一个参数</div><div class="line">def curriedSum(x: Int)(y: Int) = x + y</div><div class="line">//调用</div><div class="line">curriedSum(1)(2)</div><div class="line"></div><div class="line">/*</div><div class="line">这里发生的事情是当你调用curriedSum时,实际上连接调用了两个传统函数,第一个函数调用带单个的名为x的Int参数,并返回第二个函数的函数值,第二个函数带Int参数y,下面的名为first的函数实质上执行了curriedSum的第一个传统函数调用会做的事情:</div><div class="line">*/</div><div class="line">def first(x: Int) = (y: Int)=&gt;x+y</div><div class="line">//在第一个函数上应用1,会产生第二个函数</div><div class="line">val second = first(1)</div><div class="line">//执行第二个函数</div><div class="line">second(2)</div><div class="line"></div><div class="line">/*</div><div class="line">first和second函数只是柯里化过程的一个演示,他们并不直接连接在curriedSum函数上,可以使用下面的函数来获取第二个参数的参考</div><div class="line">*/</div><div class="line">val onePlus = curriedSum(1) _</div><div class="line">//调用</div><div class="line">onePlus(2) //curriedSum(1)_里的下划线是第二个参数列表的占位符,结果及时指向一个函数的参考</div></pre></td></tr></table></figure>
<h1 id="4-编写新的控制结构"><a href="#4-编写新的控制结构" class="headerlink" title="4.编写新的控制结构"></a>4.编写新的控制结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">在拥有头等函数的语言中,即使语言的语法是固定的,你也可以有效的制作新的控制结构,所有你需要做的就是创建带函数做参数的方法</div><div class="line">*/</div><div class="line">//下面是&quot;双倍&quot;控制结构,能够重复一个操作两次并返回结果</div><div class="line">def twice(op: Double=&gt;Double, x:Double) = op(op(x))</div><div class="line">twice(_ + 1, 5) //7</div><div class="line">//在这个例子里op的类型是Double=&gt;Double,就是说他是带一个Double做参数并返回另一个Double的函数,而 _+1就是这个函数的实现,而下划线就是参数(用占位符表示)</div><div class="line"></div><div class="line"></div><div class="line">//需求:打开一个资源,对他进行操作,然后关闭资源,如下的代码:</div><div class="line">def withPrintWriter(file: java.io.File, op: PrintWriter =&gt;Unit): Unit =&#123;</div><div class="line">  val writer = new PrintWriter(file)</div><div class="line">  try &#123;</div><div class="line">    op(writer)</div><div class="line">  &#125; finally &#123;</div><div class="line">    writer.close()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//在客户端调用方法</div><div class="line">withPrintWriter(</div><div class="line">  new java.io.File(&quot;data.txt&quot;),</div><div class="line">  writer =&gt; writer.println(new java.util.Date)   //客户端只需要去提供方法,并不需要去关心文件流的关闭与否</div><div class="line">)</div><div class="line"></div><div class="line">/*</div><div class="line">这个方法的好处就是:由withPrintWriter而并非客户端代码,去确认文件在结尾被关闭,因此忘记关闭文件是不可能的,这个技巧被称为借贷模式,因为控制抽象函数,如:withPrintWriter,打开了资源并&quot;借贷&quot;出函数,例如,前面例子里的withPrintWriter把PrintWriter借给函数op,当函数完成的时候,他发送信号说明他不在需要&quot;借&quot;的资源,于是资源被关闭在finally块中,以确认其确实被关闭,而忽略函数是正常结束还是抛出了异常</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">让客户端看上去更像内建控制结构的另一种方式是:使用花括号代替小括号包围参数列表,scala的任何方法调用,如果你确实之传入一个参数,就能可选的使用花括号替代小括号包围参数</div><div class="line">*/</div><div class="line"></div><div class="line">println(&quot;hello, world!&quot;)</div><div class="line">//替换为</div><div class="line">println&#123;&quot;hello, world!&quot;&#125;    //仅在一个参数的时候有效</div><div class="line"></div><div class="line"></div><div class="line">//在多个参数时,可以使用柯里化的方式来使用花括号构建控制抽象</div><div class="line">val file = new File(&quot;data.txt&quot;)</div><div class="line">withPrintWriter(file)&#123;</div><div class="line">  writer =&gt; writer.println(new java.util.Date)</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">在上述代码中,第一个参数列表包含了一个File参数,被写成包围在小括号中,第二个参数列表包含了一个函数列表,被包围在花括号中</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="5-传名参数-by-name-parameter"><a href="#5-传名参数-by-name-parameter" class="headerlink" title="5.传名参数(by-name parameter)"></a>5.传名参数(by-name parameter)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">上面的描述中可以自花括号中使用参数,但是如果传入的函数的没有参数的情况下,该如何呢?</div><div class="line">*/</div><div class="line">var assertionsEnabled = true</div><div class="line">def myAssert(predicate: ()=&gt;Boolean) =</div><div class="line">  if (assertionsEnabled &amp;&amp; !predicate())</div><div class="line">    throw new AssertionError</div><div class="line"></div><div class="line">//使用</div><div class="line">myAssert(()=&gt; 5&gt;3)  //看上去有点难看,或许你想写成下面的样子</div><div class="line">myAssert(5&gt;3) //不会有效,因为缺少()=&gt;</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">传名函数恰好就是为了实现上述愿望而出现的,要实现一个传名函数,要定义参数的类型开始于 =&gt;,而不是()=&gt; ,例如:上述代码&quot; ()=&gt;Boolean &quot; 变为 &quot;=&gt;Boolean&quot; </div><div class="line">*/</div><div class="line">var assertionsEnabled = true</div><div class="line">def myAssert(predicate: =&gt;Boolean) =    //因为没有参数,所以就不写()</div><div class="line">  if (assertionsEnabled &amp;&amp; !predicate)</div><div class="line">    throw new AssertionError</div><div class="line"></div><div class="line">//使用</div><div class="line">myAssert(5&gt;3) </div><div class="line"></div><div class="line">//或许你想对上述的函数还进一步的简化,如下:</div><div class="line">def boolAssert(predicate: Boolean) =</div><div class="line">  if (assertionsEnabled &amp;&amp; !predicate)</div><div class="line">    throw new AssertionError</div><div class="line"></div><div class="line">//调用</div><div class="line">boolAssert(5&gt;3) </div><div class="line"></div><div class="line">/*</div><div class="line">虽然可以使用上述的方式,但是: &quot; predicate:=&gt;Boolean &quot; 和 &quot; predicate:Boolean &quot;是两种不同的方式</div><div class="line">因为boolAssert的参数类型是Boolean,在boolAssert(5&gt;3)里括号中的表达式先于boolAssert的调用被评估,表达式5&gt;3产生true,被传给boolAssert</div><div class="line">而在myAssert的predicate参数的类型是  =&gt;Boolean,  myAssert(5&gt;3) 里括号中的表达式不是先于myAssert的调用被评估的,而是代之以先创建一个函数值,其apply方法将被评估 5&gt;3 ,而这个函数值将被传递给myAssert</div><div class="line">*/</div><div class="line">//如果断言被禁用</div><div class="line">var assertionsEnabled = false</div><div class="line"></div><div class="line">myAssert(x/0 == 0)</div><div class="line">boolAssert(x/0 == 0)//抛出异常(被0除),因为其中的表达式是先于函数被评估的,所以会先抛出异常</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第九章 控制抽象/" data-id="cj290sb980073ssqq7lv9399w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-scala编程/第七章 内建控制结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第七章 内建控制结构/" class="article-date">
  <time datetime="2017-04-16T04:47:25.891Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/scala编程/第七章 内建控制结构/">第七章 内建控制结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;scala的几乎所有的控制结构都会产生某个值,这是函数式语言所采用的方式scala的if可以向Java的三元操作符一样产生值,同样for, try, match也产生值, 程序员能够用结果值来简化代码,就如同用函数的返回值那样,如果没有这种机制,程序员就必须创建零时变量来保存控制结构中的计算结果</p>
        
          <p class="article-more-link">
            <a href="/2017/04/16/scala编程/第七章 内建控制结构/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第七章 内建控制结构/" data-id="cj290sb95006zssqqf3wz36gp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/58/">58</a><a class="extend next" rel="next" href="/page/10/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IDEA/">IDEA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NFS/">NFS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tachyon/">Tachyon</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/azkaban/">azkaban</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/echarts/">echarts</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hbase/">hbase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hive/">hive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/inotify/">inotify</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/logstash/">logstash</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rsync/">rsync</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/socket/">socket</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sqoop/">sqoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storm/">storm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux基础命令/">Linux基础命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux重要配置文件/">Linux重要配置文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NFS/">NFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/azkaban/">azkaban</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echarts/">echarts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hbase/">hbase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inotify/">inotify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logstash/">logstash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mapreduce/">mapreduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcached/">memcached</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rpc/">rpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rsync/">rsync</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala/">scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala函数式编程/">scala函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala编程/">scala编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqoop/">sqoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storm/">storm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Linux基础命令/" style="font-size: 19.52px;">Linux基础命令</a> <a href="/tags/Linux重要配置文件/" style="font-size: 14.76px;">Linux重要配置文件</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/NIO/" style="font-size: 11.43px;">NIO</a> <a href="/tags/azkaban/" style="font-size: 10.48px;">azkaban</a> <a href="/tags/echarts/" style="font-size: 10.95px;">echarts</a> <a href="/tags/flume/" style="font-size: 10.95px;">flume</a> <a href="/tags/hadoop/" style="font-size: 18.57px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 13.33px;">hbase</a> <a href="/tags/hive/" style="font-size: 18.1px;">hive</a> <a href="/tags/inotify/" style="font-size: 10px;">inotify</a> <a href="/tags/java/" style="font-size: 12.38px;">java</a> <a href="/tags/kafka/" style="font-size: 12.86px;">kafka</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/logstash/" style="font-size: 10.48px;">logstash</a> <a href="/tags/mapreduce/" style="font-size: 16.67px;">mapreduce</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/memcached/" style="font-size: 13.81px;">memcached</a> <a href="/tags/mongodb/" style="font-size: 14.76px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 17.14px;">mysql</a> <a href="/tags/netty/" style="font-size: 10.95px;">netty</a> <a href="/tags/nginx/" style="font-size: 14.29px;">nginx</a> <a href="/tags/project/" style="font-size: 10.48px;">project</a> <a href="/tags/python/" style="font-size: 19.05px;">python</a> <a href="/tags/redis/" style="font-size: 17.14px;">redis</a> <a href="/tags/rpc/" style="font-size: 10.48px;">rpc</a> <a href="/tags/rsync/" style="font-size: 10px;">rsync</a> <a href="/tags/scala/" style="font-size: 17.62px;">scala</a> <a href="/tags/scala函数式编程/" style="font-size: 11.9px;">scala函数式编程</a> <a href="/tags/scala编程/" style="font-size: 15.71px;">scala编程</a> <a href="/tags/shell/" style="font-size: 17.62px;">shell</a> <a href="/tags/socket/" style="font-size: 11.9px;">socket</a> <a href="/tags/spark/" style="font-size: 20px;">spark</a> <a href="/tags/sqoop/" style="font-size: 10.95px;">sqoop</a> <a href="/tags/storm/" style="font-size: 15.24px;">storm</a> <a href="/tags/zookeeper/" style="font-size: 16.19px;">zookeeper</a> <a href="/tags/数据仓库/" style="font-size: 11.43px;">数据仓库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/02/bigdata/spark从入门到精通_笔记/Tachyon/">Tachyon</a>
          </li>
        
          <li>
            <a href="/2017/04/30/数据仓库/数据仓库2/">数据仓库</a>
          </li>
        
          <li>
            <a href="/2017/04/29/IDEA/IDEA/">IDEA</a>
          </li>
        
          <li>
            <a href="/2017/04/29/数据仓库/ETL/">ETL</a>
          </li>
        
          <li>
            <a href="/2017/04/28/数据仓库/PowderDesigner/">PowderDesigner的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Mr. Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>