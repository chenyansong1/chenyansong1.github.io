<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一个技术渣的自说自话">
<meta property="og:type" content="website">
<meta property="og:title" content="Chen's Blog">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Chen's Blog">
<meta property="og:description" content="一个技术渣的自说自话">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chen's Blog">
<meta name="twitter:description" content="一个技术渣的自说自话">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title> Chen's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个技术渣的自说自话</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/scala编程/第十一章 scala的层级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/scala编程/第十一章 scala的层级/" itemprop="url">
                  第十一章 scala的层级
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>&emsp;在scala里,每个类都继承自通用的名为Any的超类,因为所有的类都是Any的子类,所以定义在Any中的方法就是”共同”的方法,他们可以被任何对象调用,scala还在层级的底端定义了一些有趣的类,如:Null,和Nothing,来扮演通用的子类,例如:如同Any是所有其他类的超类,Nothing是所有其他类的子类</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/16/scala编程/第十一章 scala的层级/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/scala编程/第六章 函数式对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/scala编程/第六章 函数式对象/" itemprop="url">
                  第六章 函数式对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="1-类ration的规格说明书"><a href="#1-类ration的规格说明书" class="headerlink" title="1.类ration的规格说明书"></a>1.类ration的规格说明书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">有理数是一种可以表达式比率 n/d 的数字,这里n和d是数字,其中d不能为零,n被称为分子,d被称为分母</div></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/16/scala编程/第六章 函数式对象/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/scala编程/第八章 函数和闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/scala编程/第八章 函数和闭包/" itemprop="url">
                  第八章 函数和闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">作为某个对象的成员的函数,被称之为方法(method),</div><div class="line">*/</div><div class="line">import scala.io.Source</div><div class="line">object LongLines&#123;</div><div class="line">  def processFile(fileName: String, width: Int): Unit =&#123;</div><div class="line">    val source = Source.fromFile(fileName)</div><div class="line">    for (line &lt;- source.getLines())</div><div class="line">      processLine(fileName, width, line)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private def processLine(fileName: String, width: Int, line: String): Unit =&#123;</div><div class="line">    if (line.length&gt;width)</div><div class="line">      println(fileName + &quot;: &quot; + line.trim)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/16/scala编程/第八章 函数和闭包/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/scala编程/第五章 基本类型和操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/scala编程/第五章 基本类型和操作/" itemprop="url">
                  第五章 基本类型和操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">在scala中有如下的基本类型:Byte,Short,Int,Long,Char,String, Float, Double, Boolean,除了String归于java.lang包之外,其余所有的基本类型都是包scala的成员,如,Int的全名是scala.Int,然而,由于包scala和Java.lang的所有成员都被每个scala源文件自动引用,因此可以在任何地方只用简化名(也就是说,直接写成Boolean,Char或String)</div><div class="line"></div><div class="line">目前实际上scala值类型可以使用与Java的原始类型一致的小写化名称,比如,scala程序里可以用int替代Int,但请记住他们都是一回事,scala.Int, scala的社区实践提出的推荐风格是一直使用大写形式,这也是本书推荐的,将来scala的版本可能不再支持乃至移除小写化名称,因此跟随社区的趋势,在scala代码中使用Int而非int才是明智之举</div><div class="line">*/</div></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/16/scala编程/第五章 基本类型和操作/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/scala编程/第二十章 抽象成员/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/scala编程/第二十章 抽象成员/" itemprop="url">
                  第二十章 抽象成员
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-抽象成员的快速浏览"><a href="#1-抽象成员的快速浏览" class="headerlink" title="1.抽象成员的快速浏览"></a>1.抽象成员的快速浏览</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">我们称不完全定义的类或特质的成员为抽象成员,抽象成员将被声明类的子类实现</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">下面的特质对每种抽象成员各声明了一个例子,他们分别是:类型(T), 方法(transform), val(initial) , 以及var(current):</div><div class="line">*/</div><div class="line">trait Abstrant &#123;</div><div class="line">  type T</div><div class="line">  def transform(x: T): T</div><div class="line">  val initial: T</div><div class="line">  val current: T</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Abstract的具体实现需要对每种抽象成员填入定义,下面的例子是提供这些定义的实现</div><div class="line">class Concrete extends Abstrant&#123;</div><div class="line">  type T = String</div><div class="line">  override def transform(x: String) = x + x</div><div class="line">  val initial= &quot;hi&quot;</div><div class="line">  override var current = initial</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">这个实现为类型T提供了具体的含义,他被定义为类型String的别名,transform被定义为参数字符串与其自身连接的操作,而initial和current值都被设置为&quot;hi&quot;</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="2-类型成员"><a href="#2-类型成员" class="headerlink" title="2.类型成员"></a>2.类型成员</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">抽象类型这个术语在scala中是指不带具体定义的,由&quot;type&quot;关键字声明为类或特质的成员的类型,类本身可以是抽象的,而特质本来就是抽象的,但不论哪种都不是scala中所指的抽象类型,scala的抽象乐行永远都是某个类或者特质的成员,就好像特质Abstract里的类型T那样</div><div class="line"></div><div class="line"></div><div class="line">你可以把非抽象的类型成员,如Concrete类里的类型T,想象成是类型定义新的名称,或别名的方式,例如Concrete类中,类型String被指定了别名T,因此,任何出现在Concrete定义中的T指的都是String,这也包含了transform的参数和结果类型initial,以及current,这些在Abstract超特质中声明的时候提到的T的成员,因此当Concrete类实现这些抽象成员的时候,所有的T都被解释为String</div><div class="line"></div><div class="line"></div><div class="line">使用类型成员的理由之一是为类型定义短小的,具有说明性的别名,因为类型的实际名称可能比别名更冗长,或语义不清,这种类型成员有助于净化类或特质的代码,类型成员的另一种主要用途是声明必须被定义为子类的抽象类型</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="3-抽象val"><a href="#3-抽象val" class="headerlink" title="3.抽象val"></a>3.抽象val</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//抽象val以如下形式定义</div><div class="line">val initial: String </div><div class="line"></div><div class="line">//他指明了val的名称和类型,但不指定值,该值必须由子类的具体val定义提供,例如:Concrete类以如下方式实现了val:</div><div class="line">val initial    = &quot;hi&quot;</div><div class="line"></div><div class="line">//抽象的val声明类似于抽象的无参数方法声明,如:</div><div class="line">def    initial: String</div><div class="line">/*</div><div class="line">如果initial是抽象val,那么客户就获得了保证,每次引用都将得到同样的值,如果initial是抽象方法,就不会获得这样的保证,因为在这种情况下initial可以实现为每次调用时都返回不同值的具体方法</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">abstract class Fruit&#123;</div><div class="line">  val v: String //&apos;v&apos;代表value(值)</div><div class="line">  def m: String //&apos;m&apos;代表method方法</div><div class="line">&#125;</div><div class="line">abstract class Apple extends Fruit&#123;</div><div class="line">  val v: String</div><div class="line">  val m: String //可以用&quot;val&quot; 重写def</div><div class="line">&#125;</div><div class="line">abstract class BadApple extends Fruit&#123;</div><div class="line">  def v: String //error , 不能用&quot;def&quot;重写val</div><div class="line">  def m: String</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">换句话说,抽象的val限制了合法的实现方式,任何实现都必须是val类型的定义,不可以是var或def,另一方面,抽象方法声明可以被实现为具体的方法定义或具体的val定义,</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="4-抽象var"><a href="#4-抽象var" class="headerlink" title="4.抽象var"></a>4.抽象var</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//与抽象val类似,抽象var只声明名称和类型,没有初始值,如下:</div><div class="line">trait AbstractTime&#123;</div><div class="line">  var hour: Int</div><div class="line">  var minute: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">类似于hour和minute这样的抽象var表达的是什么意思呢?在18.2节看到声明为类成员的var实际配备了getter和setter方法,对于抽象var来说也是如此,比如如果你声明了名为hour的抽象var,实际上是隐式声明了抽象getter方法,hour及抽象setter方法(hour_=) </div><div class="line">*/</div><div class="line">trait AbstractTime&#123;</div><div class="line">  def hour: Int //&apos;hour&apos; 的getter方法</div><div class="line">  def hour_=(x:Int) //&quot;hour&quot; 的setter方法</div><div class="line">  def minute: Int //&quot;minute&quot;的getter方法</div><div class="line">  def minute_=(x:Int) //&apos;minute&apos;的setter方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-初始化抽象val"><a href="#5-初始化抽象val" class="headerlink" title="5.初始化抽象val"></a>5.初始化抽象val</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">抽象val有时会扮演类似于超类的参数这样的角色:他们能够让你在子类中提供超类缺少的细节信息,这对于特质来说尤其重要,因为特质缺少能够用来传递参数的构造器,因此通常参数化特质的方式就是通过需要在子类中实现的抽闲val完成</div><div class="line">*/</div><div class="line">trait RationalTrait &#123;</div><div class="line">  val numerArg: Int</div><div class="line">  val denomArg: Int</div><div class="line">&#125;</div><div class="line"></div><div class="line">//实现</div><div class="line">new RationalTrait &#123;</div><div class="line">  override val denomArg: Int = 1</div><div class="line">  override val numerArg: Int = 1</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">这里关键字new出现在特质名称(RationalTrait)之前,然后是花括号包围的类结构体,这个表达式可以产生混入了特质并被结构体定义的匿名类实例,这种特使的匿名类实例化结果与使用new Rational(1,2)的方式创建的实例具有类似的效果,不过这种类比并非完美,两者在表达式的初始化顺序方面存在着微妙的差别</div><div class="line">*/ </div><div class="line">//当你写下:</div><div class="line">new Rational(expr1, expr2)</div><div class="line"></div><div class="line">//两个表达式,expr1和expr2会在类Rational初始化之前计算,因此在执行类的初始化操作是expr1和expr2的值已经可用,然而对于特质来说,情况正好相反,当你写下:</div><div class="line">new RationalTrait&#123;</div><div class="line">    val numerArg = expr1</div><div class="line">    val denomArg = expr2</div><div class="line">&#125;</div><div class="line">//表达式expr1和expr2被作为匿名初始化的一部分计算,但匿名类的初始化在RationalTrait之后,因此numerArg和denomArg的值在RationalTrait初始化期间还没有主备好(更为精确的说,选用任何值都将得到Int类型的默认值,0),对于之前的RationalTrait定义来说,这不是问题,因为特质的初始化没有用到numerArg和denomArg的值,但是对于下面的代码来说就成为一个问题,因为其中定义了经过约分的分子和分母</div><div class="line">trait RationalTrait&#123;</div><div class="line">  val numerArg: Int</div><div class="line">  val denomArg: Int</div><div class="line">  require(denomArg != 0)</div><div class="line"></div><div class="line">  private val g = gcd(numerArg, denomArg)</div><div class="line"></div><div class="line">  val number = numerArg / g</div><div class="line">  val denom = denomArg / g</div><div class="line"></div><div class="line">  private def gcd(a:Int, b:Int): Int =</div><div class="line">    if (b == 0) a else gcd(b, a%b)</div><div class="line"></div><div class="line">  override def toString = number + &quot;/&quot; + denom</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试</div><div class="line"></div><div class="line">scala&gt; new RationalTrait&#123;</div><div class="line">     | val numerArg = 1*x</div><div class="line">     | val denomArg = 2*x</div><div class="line">     | &#125;</div><div class="line">java.lang.IllegalArgumentException: requirement failed</div><div class="line">        at scala.Predef$.require(Predef.scala:221)</div><div class="line">        at RationalTrait$class.$init$(&lt;console&gt;:10)</div><div class="line">        at $anon$1.&lt;init&gt;(&lt;console&gt;:10)</div><div class="line">        at .&lt;init&gt;(&lt;console&gt;:10)</div><div class="line">        at .&lt;clinit&gt;(&lt;console&gt;)</div><div class="line">        at .&lt;init&gt;(&lt;console&gt;:7)</div><div class="line"></div><div class="line">/*</div><div class="line">出错的原因是:当类RationalTrait初始化的时候,denomArg仍然为他的默认值0,使得require调用失败</div><div class="line">上述例子演示了类参数和抽象字段的初始化顺序并不一致,类参数在被传递给构造器之前计算(除非参数是传名的),相反子类对于val定义的实现,是在超类完成了初始化之后执行的</div><div class="line">*/</div></pre></td></tr></table></figure>
<blockquote>
<p>fields预初始化字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">第一种解决方案,预初始化字段,可以让你在调用超类之前初始化子类的字段,操作的方式是把字段加上花括号,放在超类构造器调用之前,</div><div class="line">*/</div><div class="line">new &#123;</div><div class="line">  val numerArg = 1*x</div><div class="line">  val denomArg = 2*x</div><div class="line">&#125; with RationalTrait</div><div class="line"></div><div class="line"></div><div class="line">//预初始化字段不仅限于匿名类,他们还可以被用于对象或有名称的子类</div><div class="line"></div><div class="line">//预初始化段落在每个例子中都被定义的对象或类的extends关键字之后</div><div class="line">object twoThirds extends &#123;</div><div class="line">  val numerArg = 2</div><div class="line">  val denomArg = 3</div><div class="line">&#125; with RationalTrait</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">由于预初始化的字段在超类构造器调用之前被初始化,因此他们的初始化器不能引用正被构造的对象,相应的结果是,如果有引用this的这种初始化器,那么实际指向的是包含了正被构造的类或对象的对象,而不是被构造对象本身</div><div class="line">*/</div><div class="line">scala&gt; new &#123;</div><div class="line">     | val numerArg = 1</div><div class="line">     | val denomArg = this.numerArg*2</div><div class="line">     | &#125; with RationalTrait</div><div class="line">&lt;console&gt;:11: error: value numerArg is not a member of object $iw</div><div class="line">              val denomArg = this.numerArg*2</div><div class="line">                                  ^</div><div class="line">/*</div><div class="line">上述例子编译通过的原因在于this.numerArg引用是在包含new的对象中numerArg字段(这个例子中是指名为$iw的合成对象,解释器会把用户输出的语句放在这个对象中)</div><div class="line">*/</div><div class="line"></div><div class="line">//示例了如何在超特质的初始化过程中使用类参数的通用模式</div><div class="line">class RationalClass(n: Int, d:Int) extends &#123;</div><div class="line">  val numerArg = n</div><div class="line">  val denomArg = d</div><div class="line">&#125;with RationalTrait&#123;</div><div class="line">  def + (that: RationalClass) = new RationalClass(</div><div class="line">    number * that.denom + that.number*denom, denom * that.denom</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>懒加载val<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">如果你把lazy修饰符前缀val定义上,那么右侧的初始化表达式直到val第一次被使用的时候才计算</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">scala&gt; object Demo&#123;</div><div class="line">     | val x = &#123;println(&quot;initializing x&quot;); &quot;done&quot;&#125;</div><div class="line">     | &#125;</div><div class="line">defined module Demo</div><div class="line"></div><div class="line">scala&gt; Demo</div><div class="line">initializing x</div><div class="line">res6: Demo.type = Demo$@3d0035d2</div><div class="line"></div><div class="line"></div><div class="line">scala&gt; Demo.x</div><div class="line">res7: String = done</div><div class="line">/*</div><div class="line">发现,用到Demo的时候,他的x字段就完成了初始化,x的初始化成为了Demo初始化的一部分</div><div class="line">*/</div><div class="line"></div><div class="line">//将x字段定义为lazy</div><div class="line"></div><div class="line">scala&gt; object Demo&#123;</div><div class="line">     | lazy val x = &#123;println(&quot;initialing x&quot;); &quot;done&quot;&#125;</div><div class="line">     | &#125;</div><div class="line">defined module Demo</div><div class="line"></div><div class="line">scala&gt; Demo</div><div class="line">res8: Demo.type = Demo$@3c78e551</div><div class="line"></div><div class="line">scala&gt; Demo.x</div><div class="line">initialing x</div><div class="line">res9: String = done</div><div class="line"></div><div class="line">scala&gt; Demo.x</div><div class="line">res10: String = done</div><div class="line"></div><div class="line">/*</div><div class="line">初始化Demo不会执行初始化x的调用,x的初始化将延迟到第一次使用x的时候</div><div class="line">第一次计算懒加载val的时候结果就被保存了下来,以备同样的val后续使用</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">trait RationalTrait&#123;</div><div class="line">  val numerArg: Int</div><div class="line">  val denomArg: Int</div><div class="line"></div><div class="line">  private lazy val g = &#123;</div><div class="line">    require(denomArg != 0)</div><div class="line">    gcd(numerArg, denomArg)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  lazy val numer = numerArg / g</div><div class="line">  lazy val denom = denomArg / g</div><div class="line"></div><div class="line">  override def toString = numer + &quot;/&quot; + denom</div><div class="line"></div><div class="line">  private def gcd(a:Int, b:Int): Int =</div><div class="line">    if (b == 0) a else gcd(b, a%b)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试</div><div class="line">scala&gt; val x = 2</div><div class="line">x: Int = 2</div><div class="line"></div><div class="line">scala&gt; new RationalTrait&#123;</div><div class="line">     | val numerArg = 1*x</div><div class="line">     | val denomArg = 2*x</div><div class="line">     | &#125;</div><div class="line">res13: RationalTrait = 1/2</div><div class="line"></div><div class="line">//执行过程</div><div class="line">/*</div><div class="line">1.首先,RationalTrait的新实例被创建出来,特质的初始化代码被运行,该初始化代码为空,没有任何字段被初始化</div><div class="line">2.之后,有new表达式定义的匿名子类的主构造器被执行,他把numerArg初始化为2,把denomArg初始化为4</div><div class="line">3.之后,解释器调用了构造器对象的toString方法,结果值被打印出来</div><div class="line">4.之后,numer字段被特质RationalTrait的toString方法首次访问,因此它的初始化器执行计算</div><div class="line">5.numer的初始化器访问了私有字段g,因此g接下来被初始化计算,这次计算访问了numerArg和denomArg,他们定义在第二步</div><div class="line">6.之后,toString方法访问了denom值,引发denom的计算,这次访问计算了denomArg和g的值,g字段的初始化器不再重新计算,因为他已经在第五步执行过</div><div class="line">7.最终,结果字符串&quot;1/2&quot;被构造出来并被打印</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">请注意,在RationalTrait类中,g的定义在代码文本中处于numer和denom定义之后,尽管如此,因为所有的三个值都是懒加载的,所以g将在numer和denom完成初始化之前被初始化,这说明了懒加载val的一个很重要的属性,定义的文本顺序不用多加考虑,因为初始化是按需的,从而,懒加载val可以免去你作为程序员不得不认真考虑的问题,及如何安排val定义顺序,以确保所有东西在需要的时候已经完成定义</div><div class="line">*/</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="6-抽象类型"><a href="#6-抽象类型" class="headerlink" title="6.抽象类型"></a>6.抽象类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">与所有其他抽象声明一样,抽象类型声明也是将在子类中具体定义的事务的占位符,这里,他是将在之后的类层次中定义的类型,因此上文的T是对在声明点尚不可知的类型的引用,不同的子类可以提供不同的T实现</div><div class="line">*/</div><div class="line"></div><div class="line">//假设给了你一个为动物饮食习惯建模的任务,你或许会以Food类和带有eat方法的Animal类开始工作</div><div class="line">class Food</div><div class="line">abstract class Animal &#123;</div><div class="line">  def eat(food: Food)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//然后你或许尝试把这两个类特化为Cow类吃Grass类(牛吃草)</div><div class="line">class Grass extends Food</div><div class="line">class Cow extends Animal&#123;</div><div class="line">  override def eat(food: Grass) = &#123;&#125;//不能编译</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">这里的情况是Cow类的eat方法不能重写Animal类的eat方法,因为参数类型不同---Cow类里是Grass, 而Animal类里是Food</div><div class="line">*/</div><div class="line"></div><div class="line">//为什么要做这样的限制?</div><div class="line">class Food</div><div class="line">abstract class Animal &#123;</div><div class="line">  def eat(food: Food)</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Grass extends Food</div><div class="line">class Cow extends Animal&#123;</div><div class="line">  override def eat(food: Grass) = &#123;&#125;//不能编译,不过如果能够编译通过的话,...</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Fish extends Food</div><div class="line">val bessy: Animal = new Cow</div><div class="line">bessy eat (new Fish)  //.....你将能用鱼喂牛</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">你应该做的是采用更为精确的建模方式,Animal的确吃Food,但Animal具体吃什么类型的Food取决于Animal,这可以使用抽象类型干净的表示出来</div><div class="line">*/</div><div class="line">class Food</div><div class="line">abstract class Animal&#123;</div><div class="line">  type SuitableFood &lt;: Food</div><div class="line">  def eat(food: SuitableFood)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">有了新的定义,Animal就可以只吃适合的食物了,不过到底什么食物合适,这并不在Animal类的层面决定,这也就是SuitableFood被建模为抽象类型的原因,具体具有上界约束:Food,表达为&quot; &lt;:Food &quot; 子句,说明任何(Animal子类中的)SuitableFood的具体实例化结果都必须是Food的子类</div><div class="line">*/</div><div class="line">class Grass extends Food</div><div class="line">class Cow extends Animal&#123;</div><div class="line">  type SuitableFood = Grass</div><div class="line">  def eat(food: Grass)&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="7-路径依赖类型"><a href="#7-路径依赖类型" class="headerlink" title="7.路径依赖类型"></a>7.路径依赖类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">通常情况下,不同的路径将产生不同的依赖</div><div class="line">*/</div><div class="line">class DogFood extends Food</div><div class="line">class Dog extends Animal&#123;</div><div class="line">  override type SuitableFood = DogFood</div><div class="line">  override def eat(food: DogFood) = &#123;&#125;</div><div class="line">&#125;</div><div class="line">//如果你尝试把牛的饲料用来喂狗,你的代码将无法通过编译</div><div class="line"></div><div class="line">scala&gt; val bessy = new Cow</div><div class="line">bessy: Cow = Cow@59edb4f5</div><div class="line"></div><div class="line">scala&gt; val lassie = new Dog</div><div class="line">lassie: Dog = Dog@7ea2412c</div><div class="line"></div><div class="line">scala&gt; lassie eat (new bessy.SuitableFood)</div><div class="line">&lt;console&gt;:16: error: type mismatch;</div><div class="line"> found   : Grass</div><div class="line"> required: DogFood</div><div class="line">              lassie eat (new bessy.SuitableFood)</div><div class="line">                          ^</div><div class="line">/*</div><div class="line">问题在于传递给eat方法的SuitableFood对象的类型(bessy.SuitableFood), 不能匹配eat的参数类型,lassie.SuitableFood,然而如果同样是Dog的话,情况会不一样,因为Dog的SuitableFood类型被定义为DogFood类的别名,所以对于两条Dog来说,他们的SuitableFood类型实际上是一样的,</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; val bootsie = new Dog</div><div class="line">bootsie: Dog = Dog@11381415</div><div class="line"></div><div class="line">scala&gt; lassie eat (new bootsie.SuitableFood)</div><div class="line"></div><div class="line">scala&gt;</div><div class="line"></div><div class="line">/*</div><div class="line">路径依赖类型会让我们想起java中的内部类语法,但两者有决定性的差别:路径依赖类型表达了外在的对象,而内部类表达了外在的类</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">class Outer&#123;</div><div class="line">  class Inner</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">scala中,内部类的表达形式为Outer#Inner, 而不是java的Outer.Inner ,&quot;.&quot; 语法保留给对象使用,例如,假设你实例化了类型Outer的两个对象</div><div class="line">*/</div><div class="line">val o1 = new Outer</div><div class="line">val o2 = new Outer</div><div class="line">/*</div><div class="line">这里o1.Inner和o2.Inner是两个路径依赖类型,o1.Inner类型是指特定(o1引用的)外部对象的Inner类</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">//实例化内部类</div><div class="line">new o1.Inner   //因为o1.Inner是属于o1对象的内部类,所以new o1.Inner是new出来的对象</div><div class="line">//返回的内部对象将包含其外部对象的引用,即o1的对象引用,相反Outer#Inner没有指明任何特定Outer实例,因此你不能创建他的实例</div><div class="line">new Outer#Inner    //error</div></pre></td></tr></table></figure>
<h1 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8.枚举"></a>8.枚举</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">scala中如果想要创建新的枚举,只需要定义扩展scala.&apos;Enumeration这个类的对象即可</div><div class="line">*/</div><div class="line"></div><div class="line">object Color extends Enumeration&#123;</div><div class="line">  val Red = Value</div><div class="line">  val Green = Value</div><div class="line">  val Blue = Value</div><div class="line">&#125;</div><div class="line">//等价于</div><div class="line">object Color extends Enumeration&#123;</div><div class="line">  val Red, Green, Blue = Value</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">这个对象定义提供了三个值:Color.Red, Color.Green, Color.Blue,你可以引用Color的全部内容:</div><div class="line">*/</div><div class="line">import Color._</div><div class="line">//然后简单写成Red, Green, 和Blue ,但这些值的类型是什么?Enumeration定义了内部类,名为Value,以及同名的无参方法Value返回该类的新对象,也就是说诸如Color.Red类的值类型是Color.Value,而Color.Value也正是定义在对象Color中的所有枚举值的类型,他是路径依赖类型,其中Color是路径,Value是依赖类型,这里很重要的一点是他是全新的类型,与其他所有的类型都不一样</div><div class="line"></div><div class="line">object Direction extends Enumeration&#123;</div><div class="line">  val North, East, South, West = Value</div><div class="line">&#125;</div><div class="line">//Direction.Value与Color.Value不同,因为两种类型的路径部分不同</div><div class="line"></div><div class="line"></div><div class="line">//scala的Enumeration类还提供了其他语言的枚举设计中所拥有的许多其他特质,你可以通过使用Value方法不同的重载变体把名称与枚举值联系起来</div><div class="line">object Direction extends Enumeration&#123;</div><div class="line">  val North = Value(&quot;North&quot;)</div><div class="line">  val East = Value(&quot;East&quot;)</div><div class="line">  val South = Value(&quot;South&quot;)</div><div class="line">  val West = Value(&quot;West&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//遍历枚举的所有值</div><div class="line">for(d &lt;-Direction) print(d+&quot; &quot;)    //North East South West</div><div class="line"></div><div class="line">//枚举值从0开始计数,你可以用枚举值的id方法获得他的计数值</div><div class="line">scala&gt; Direction.East.id</div><div class="line">res20: Int = 1</div><div class="line"></div><div class="line">//也可以反过来,通过非零的整数获得id为该数的枚举值</div><div class="line">scala&gt; Direction(1)</div><div class="line">res19: Direction.Value = East</div></pre></td></tr></table></figure>
<h1 id="9-案例研究-货币"><a href="#9-案例研究-货币" class="headerlink" title="9.案例研究:货币"></a>9.案例研究:货币</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line">//本章的剩余部分提供了一个解释scala中如何使用抽象类型的案例研究,任务是设计Currency类,典型的Currency实例可以代表美元,欧元,日元,或其他货币种类的一笔金额,而且还有可能需要一些关于货币方面的计算,比方说,相同货币的两笔金额应该能够相加,或金额应该能够乘上代表利率的因子</div><div class="line"></div><div class="line">abstract class Currency&#123;</div><div class="line">  val amount: Long    //金额大小</div><div class="line">  def designation: String    //标识货币的字符串</div><div class="line"></div><div class="line">  override def toString: String = amount + &quot; &quot; + designation</div><div class="line">  def +(that: Currency): Currency =     ...</div><div class="line">  def *(x:Double): Currency =   ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">//产生的结果如下:</div><div class="line">79 USD</div><div class="line">11000 Yen</div><div class="line">99 Euro</div><div class="line"></div><div class="line">//抽象的实现</div><div class="line">new Currency &#123;</div><div class="line">  override val amount: Long = 79L</div><div class="line">  override def designation = &quot;USD&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//如果我们仅仅是对单一货币建模,那么这种设计不存在问题,可是一旦我们需要处理若干货币种类,这样做就不行了,假设你对美元和欧元建模为货币类的两个子类</div><div class="line">abstract class Dollar extends Currency&#123;</div><div class="line">  override def designation = &quot;USD&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">abstract class Euro extends Currency&#123;</div><div class="line">  override def designation = &quot;Euro&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">上面的做法看上去很有道理,但是在执行加法的时候将两种货币放在一起感觉古怪,你要的应该是+方法更具体化的版本,实现在Dollar类中的时候,他应该带Dollar参数并产生Dollar结果,实现在Euro类中的时候,应该带Euro参数并产生Euro结果,因此加法的类型应该依赖于所在类而改变,尽管如此,你还是希望方法只写一次即可,而不是每次定义新的货币都要重写</div><div class="line">*/</div><div class="line">//第二版</div><div class="line">abstract class AbstractCurrency&#123;</div><div class="line">  type Currncy &lt;:AbstractCurrency</div><div class="line">  val amount: Long</div><div class="line">  def designation: String</div><div class="line">  override def toString: String = amount + &quot; &quot; + designation</div><div class="line">  def +(that: Currency): Currency =   ...</div><div class="line">  def *(x: Double): Currency =   ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">//第二版与前面的一版的却别在于:类现在成为AbstractCurrency,并且包含了抽象类型Currency,代表未知的真实货币种类,每种AbstractCurrency的具体子类将需要把Currency类型修改为这个类本身,从而能够把两者结合在一起</div><div class="line">//使用</div><div class="line">abstract class Dollar extends AbstractCurrency&#123;</div><div class="line">  override type Currncy = Dollar</div><div class="line">  override def designation = &quot;USD&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">这个设计仍不完美,问题之一是隐藏在AbstractCurrency类省略号中的方法定义+和* 如何具体化? 像下面这样吗?</div><div class="line">*/</div><div class="line">def +(that: Currency): Currency = new Currency &#123;</div><div class="line">  val amount = this.amount + that.amount</div><div class="line">&#125;</div><div class="line">//编译不通过,因为scala对待抽象类型的一种限制是你既不能创建抽象类型的实例,也不能把抽象类型当做其他类的超类型,因此编译器将拒绝上面例子的代码实例化Currency的尝试</div><div class="line">//解决的方法是通过工厂方法</div><div class="line">abstract  class CurrencyZone&#123;</div><div class="line">  type Currency &lt;: AbstractCurrency</div><div class="line">  def make(x: Long): Currency</div><div class="line">  abstract class AbstractCurrency&#123;</div><div class="line">    val amount: Long</div><div class="line">    def designation: String</div><div class="line">    override def toString: String = amount + &quot; &quot; + designation</div><div class="line">    def +(that: Currency): Currency = new Currency &#123;</div><div class="line">      make((this.amount + that.amount))</div><div class="line">    &#125;</div><div class="line">    def *(x: Double): Currency =</div><div class="line">      make((this.amount*x).toLong)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//实现</div><div class="line">object US extends Currency&#123;</div><div class="line">  abstract class Dollar extends AbstractCurrency&#123;</div><div class="line">    def designation = &quot;USD&quot;</div><div class="line">  &#125;</div><div class="line">  type Currency = Dollar</div><div class="line">  def make(x:Long) = new Dollar &#123;val amount = x&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">上面的情况是:每种货币都仅用一个测量单位:美元,欧元,或日元,然而大多数货币都有子单位,例如:在美国有美元和美分,下面将引入CurrencyUnit字段,以包含货币一个标准单位的金额</div><div class="line">*/</div><div class="line">//实现2</div><div class="line">object US extends Currency&#123;</div><div class="line">  abstract class Dollar extends AbstractCurrency&#123;</div><div class="line">    def designation = &quot;USD&quot;</div><div class="line">  &#125;</div><div class="line">  type Currency = Dollar</div><div class="line">  def make(cents:Long) = new Dollar &#123;val amount = cents&#125;</div><div class="line">  val Cent = make(1)  //美分</div><div class="line">  val Dollar = make(100)  //美元</div><div class="line">  val CurrencyUnit = Dollar</div><div class="line">&#125;</div><div class="line"></div><div class="line">//改进toString方法,例如:10美元与23美分的总和应该打印成小数:10.23USD</div><div class="line">override def toString: String = ((amount.toDouble/CurrencyUnit.amount.toDouble) formatted (</div><div class="line">  &quot;%.&quot;+decimals(CurrencyUnit.amount) + &quot;f&quot;))</div><div class="line"></div><div class="line">private def decimals(n: Long): Int =</div><div class="line">  if (n == 1) 0 else 1+decimals(n/10)</div><div class="line"></div><div class="line"></div><div class="line">//改进:添加货币特征转换,首先,你可以编写Converter对象,以包含适用的货币汇率</div><div class="line">object Converter&#123;</div><div class="line">  var exchangeRate = Map&#123;</div><div class="line">    &quot;USD&quot; -&gt; Map(&quot;USD&quot;-&gt;1.0, &quot;EUR&quot;-&gt;0.7596, &quot;JPY&quot;-&gt;1.211, &quot;CHF&quot;-&gt;1.223)</div><div class="line">    &quot;EUR&quot;-&gt; Map(&quot;USD&quot;-&gt;1.316, &quot;EUR&quot;-&gt;1.0, &quot;JPY&quot;-&gt;1.594, &quot;CHF&quot;-&gt;1.623)</div><div class="line">    &quot;JPY&quot;-&gt; Map(&quot;USD&quot;-&gt;0.8257, &quot;EUR&quot;-&gt;0.6272, &quot;JPY&quot;-&gt;1.0, &quot;CHF&quot;-&gt;1.018)</div><div class="line">    &quot;CHF&quot;-&gt; Map(&quot;USD&quot;-&gt;0.8108, &quot;EUR&quot;-&gt;0.6160, &quot;JPY&quot;-&gt;0.982, &quot;CHF&quot;-&gt;1.0)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">def from(other: CurrencyZone#AbstractCurrency): Currency =</div><div class="line">  make(Math.round(</div><div class="line">    other.amount.toDouble * Converter.exchangeRate(other.designation)(this.designation)</div><div class="line">  ))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//总代码</div><div class="line"></div><div class="line">abstract  class CurrencyZone&#123;</div><div class="line">  type Currency &lt;: AbstractCurrency</div><div class="line">  def make(x: Long): Currency</div><div class="line">  abstract class AbstractCurrency&#123;</div><div class="line">    val amount: Long</div><div class="line">    def designation: String</div><div class="line">    override def toString: String = amount + &quot; &quot; + designation</div><div class="line">    def +(that: Currency): Currency = new Currency &#123;</div><div class="line">      make((this.amount + that.amount))</div><div class="line">    &#125;</div><div class="line">    def *(x: Double): Currency =</div><div class="line">      make((this.amount*x).toLong)</div><div class="line">  &#125;</div><div class="line">  def from(other: CurrencyZone#AbstractCurrency): Currency =</div><div class="line">    make(Math.round(</div><div class="line">      other.amount.toDouble * Converter.exchangeRate(other.designation)(this.designation)</div><div class="line">    ))</div><div class="line">  private def decimals(n: Long): Int =</div><div class="line">    if (n == 1) 0 else 1+decimals(n/10)</div><div class="line"></div><div class="line">  override def toString: String = ((amount.toDouble/CurrencyUnit.amount.toDouble) formatted (</div><div class="line">    &quot;%.&quot;+decimals(CurrencyUnit.amount) + &quot;f&quot;</div><div class="line">    ))</div><div class="line">  val CurrencyUnit: Currency</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/scala编程/第九章 控制抽象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/scala编程/第九章 控制抽象/" itemprop="url">
                  第九章 控制抽象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-减少代码重复"><a href="#1-减少代码重复" class="headerlink" title="1.减少代码重复"></a>1.减少代码重复</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">//需求:查询当前路径下的所有的文件,找到指定字符结束的文件或目录</div><div class="line">object FileMatcher&#123;</div><div class="line">  private def fileHere = (new java.io.File(&quot;.&quot;)).listFiles</div><div class="line"></div><div class="line">  def filesEnding(query: String) =</div><div class="line">    for (file &lt;-fileHere if file.getName.endsWith(query))</div><div class="line">      yield file</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">由于fileHere是私有的,filesEnding方法是定义在提供用户的API,FileMatcher中唯一可以访问的方法</div><div class="line">*/</div><div class="line"></div><div class="line">//需求:查询当前路径下的所有的文件,找到指定字符的文件或目录(并不一定是文件结尾)</div><div class="line">def filesContaining(query: String) =</div><div class="line">  for (file &lt;-fileHere if file.getName.contains(query))</div><div class="line">    yield file</div><div class="line"></div><div class="line"></div><div class="line">//后来客户又有了一个需求:他们要求基本正则表达式匹配文件,为了支持他们,于是你,写了下面的代码:</div><div class="line">def filesRegex(query: String) =</div><div class="line">  for (file &lt;-fileHere if file.getName.matches(query))</div><div class="line">    yield file</div><div class="line"></div><div class="line">/*</div><div class="line">综合上面的三个需求,他们之间唯一的不同就是最后匹配文件的方法不同,第一个是endsWith,第二个是contains,第三个是matches,所以你或许希望有这样的代码:</div><div class="line">*/</div><div class="line">def filesMatching(query: String, method) =</div><div class="line">  for (file &lt;-fileHere if file.getName.method(query))</div><div class="line">    yield file</div><div class="line"></div><div class="line">//具体实现如下:</div><div class="line">def filesMatching(query: String, matcher: (String, String)=&gt;Boolean) =</div><div class="line">  for (file &lt;-fileHere if matcher(file.getName, query))</div><div class="line">    yield file</div><div class="line"></div><div class="line">//有了新的filesMatching帮助方法,上面的三个搜索方法可以简化成如下:</div><div class="line">def filesEnding(query: String) =</div><div class="line">  filesMatching(query,_.endsWith(_))</div><div class="line"></div><div class="line">def filesContaining(query: String) =</div><div class="line">  filesMatching(query, _.contains(_))</div><div class="line"></div><div class="line">def filesRegex(query: String) =</div><div class="line">  filesMatching(query, _.matches(_))</div><div class="line"></div><div class="line">/*</div><div class="line">其实像_.endsWith(_)这样的函数是使用了占位符语法,原函数可以写成如下的形式:</div><div class="line">*/</div><div class="line">(fileName: String, query: String) =&gt; fileName.endsWith(query)</div><div class="line">//filesMatching函数需要一个参数,这个参数是函数,类型为(String, String)=&gt;Boolean,所以我们在传参的时候可以不用指定参数类型,因此写成下面的样子:</div><div class="line">(fileName, query) =&gt; fileName.endsWith(query)</div><div class="line"></div><div class="line">//在传参的过程中,第一个参数fileName在方法体重被第一个使用,第二个参数query被第二个使用,因此你可以使用占位符语法:</div><div class="line">_.endsWith(_)</div><div class="line"></div><div class="line"></div><div class="line">//更加简化的形式</div><div class="line">object FileMatcher&#123;</div><div class="line">  private def fileHere = (new java.io.File(&quot;.&quot;)).listFiles</div><div class="line"></div><div class="line">  def filesMatching( matcher: (String)=&gt;Boolean) =</div><div class="line">    for (file &lt;-fileHere if matcher(file.getName))</div><div class="line">      yield file</div><div class="line">  def filesEnding(query: String) =</div><div class="line">    filesMatching(_.endsWith(query))</div><div class="line"></div><div class="line">  def filesContaining(query: String) =</div><div class="line">    filesMatching(_.contains(query))</div><div class="line"></div><div class="line">  def filesRegex(query: String) =</div><div class="line">    filesMatching(_.matches(query))</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">以上代码就使用了闭包的特性,其中的query就是一个自由变量</div><div class="line">在Java中的做法就是将公共的部分抽取出来形成接口,然后对接口进行实现</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="2-简化客户代码"><a href="#2-简化客户代码" class="headerlink" title="2.简化客户代码"></a>2.简化客户代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//一个判断传入的值是否包含在集合中的方法:</div><div class="line">#指令式编程的做法</div><div class="line">def containsNeg(nums: List[Int]): Boolean=&#123;</div><div class="line">  var exists = false</div><div class="line">  for (num &lt;- nums)&#123;</div><div class="line">    if (num&lt;0)</div><div class="line">      exists = true</div><div class="line">  &#125;</div><div class="line">  exists</div><div class="line">&#125;</div><div class="line">//调用</div><div class="line">containsNeg(List(1, 2, 3, 4))</div><div class="line"></div><div class="line">//函数式编程</div><div class="line">def containsNeg2(nums: List[Int]) = nums.exists(_ &lt; 0)</div><div class="line">containsNeg2(List(1, 2, 3, 4))</div><div class="line"></div><div class="line">/*</div><div class="line">传过去的是一个函数: _&lt;0, 该函数值需要一个参数,</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="3-柯里化"><a href="#3-柯里化" class="headerlink" title="3.柯里化"></a>3.柯里化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">柯里化的函数被应用于多个参数列表,而不仅仅一个</div><div class="line">*/</div><div class="line">//未被柯里化的函数</div><div class="line">def plainOldSum(x: Int, y:Int) = x + y</div><div class="line">//调用</div><div class="line">plainOldSum(1, 2)</div><div class="line"></div><div class="line"></div><div class="line">//被柯里化的函数,把这个函数应用于连个列表的各一个参数</div><div class="line">def curriedSum(x: Int)(y: Int) = x + y</div><div class="line">//调用</div><div class="line">curriedSum(1)(2)</div><div class="line"></div><div class="line">/*</div><div class="line">这里发生的事情是当你调用curriedSum时,实际上连接调用了两个传统函数,第一个函数调用带单个的名为x的Int参数,并返回第二个函数的函数值,第二个函数带Int参数y,下面的名为first的函数实质上执行了curriedSum的第一个传统函数调用会做的事情:</div><div class="line">*/</div><div class="line">def first(x: Int) = (y: Int)=&gt;x+y</div><div class="line">//在第一个函数上应用1,会产生第二个函数</div><div class="line">val second = first(1)</div><div class="line">//执行第二个函数</div><div class="line">second(2)</div><div class="line"></div><div class="line">/*</div><div class="line">first和second函数只是柯里化过程的一个演示,他们并不直接连接在curriedSum函数上,可以使用下面的函数来获取第二个参数的参考</div><div class="line">*/</div><div class="line">val onePlus = curriedSum(1) _</div><div class="line">//调用</div><div class="line">onePlus(2) //curriedSum(1)_里的下划线是第二个参数列表的占位符,结果及时指向一个函数的参考</div></pre></td></tr></table></figure>
<h1 id="4-编写新的控制结构"><a href="#4-编写新的控制结构" class="headerlink" title="4.编写新的控制结构"></a>4.编写新的控制结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">在拥有头等函数的语言中,即使语言的语法是固定的,你也可以有效的制作新的控制结构,所有你需要做的就是创建带函数做参数的方法</div><div class="line">*/</div><div class="line">//下面是&quot;双倍&quot;控制结构,能够重复一个操作两次并返回结果</div><div class="line">def twice(op: Double=&gt;Double, x:Double) = op(op(x))</div><div class="line">twice(_ + 1, 5) //7</div><div class="line">//在这个例子里op的类型是Double=&gt;Double,就是说他是带一个Double做参数并返回另一个Double的函数,而 _+1就是这个函数的实现,而下划线就是参数(用占位符表示)</div><div class="line"></div><div class="line"></div><div class="line">//需求:打开一个资源,对他进行操作,然后关闭资源,如下的代码:</div><div class="line">def withPrintWriter(file: java.io.File, op: PrintWriter =&gt;Unit): Unit =&#123;</div><div class="line">  val writer = new PrintWriter(file)</div><div class="line">  try &#123;</div><div class="line">    op(writer)</div><div class="line">  &#125; finally &#123;</div><div class="line">    writer.close()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//在客户端调用方法</div><div class="line">withPrintWriter(</div><div class="line">  new java.io.File(&quot;data.txt&quot;),</div><div class="line">  writer =&gt; writer.println(new java.util.Date)   //客户端只需要去提供方法,并不需要去关心文件流的关闭与否</div><div class="line">)</div><div class="line"></div><div class="line">/*</div><div class="line">这个方法的好处就是:由withPrintWriter而并非客户端代码,去确认文件在结尾被关闭,因此忘记关闭文件是不可能的,这个技巧被称为借贷模式,因为控制抽象函数,如:withPrintWriter,打开了资源并&quot;借贷&quot;出函数,例如,前面例子里的withPrintWriter把PrintWriter借给函数op,当函数完成的时候,他发送信号说明他不在需要&quot;借&quot;的资源,于是资源被关闭在finally块中,以确认其确实被关闭,而忽略函数是正常结束还是抛出了异常</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">让客户端看上去更像内建控制结构的另一种方式是:使用花括号代替小括号包围参数列表,scala的任何方法调用,如果你确实之传入一个参数,就能可选的使用花括号替代小括号包围参数</div><div class="line">*/</div><div class="line"></div><div class="line">println(&quot;hello, world!&quot;)</div><div class="line">//替换为</div><div class="line">println&#123;&quot;hello, world!&quot;&#125;    //仅在一个参数的时候有效</div><div class="line"></div><div class="line"></div><div class="line">//在多个参数时,可以使用柯里化的方式来使用花括号构建控制抽象</div><div class="line">val file = new File(&quot;data.txt&quot;)</div><div class="line">withPrintWriter(file)&#123;</div><div class="line">  writer =&gt; writer.println(new java.util.Date)</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">在上述代码中,第一个参数列表包含了一个File参数,被写成包围在小括号中,第二个参数列表包含了一个函数列表,被包围在花括号中</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="5-传名参数-by-name-parameter"><a href="#5-传名参数-by-name-parameter" class="headerlink" title="5.传名参数(by-name parameter)"></a>5.传名参数(by-name parameter)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">上面的描述中可以自花括号中使用参数,但是如果传入的函数的没有参数的情况下,该如何呢?</div><div class="line">*/</div><div class="line">var assertionsEnabled = true</div><div class="line">def myAssert(predicate: ()=&gt;Boolean) =</div><div class="line">  if (assertionsEnabled &amp;&amp; !predicate())</div><div class="line">    throw new AssertionError</div><div class="line"></div><div class="line">//使用</div><div class="line">myAssert(()=&gt; 5&gt;3)  //看上去有点难看,或许你想写成下面的样子</div><div class="line">myAssert(5&gt;3) //不会有效,因为缺少()=&gt;</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">传名函数恰好就是为了实现上述愿望而出现的,要实现一个传名函数,要定义参数的类型开始于 =&gt;,而不是()=&gt; ,例如:上述代码&quot; ()=&gt;Boolean &quot; 变为 &quot;=&gt;Boolean&quot; </div><div class="line">*/</div><div class="line">var assertionsEnabled = true</div><div class="line">def myAssert(predicate: =&gt;Boolean) =    //因为没有参数,所以就不写()</div><div class="line">  if (assertionsEnabled &amp;&amp; !predicate)</div><div class="line">    throw new AssertionError</div><div class="line"></div><div class="line">//使用</div><div class="line">myAssert(5&gt;3) </div><div class="line"></div><div class="line">//或许你想对上述的函数还进一步的简化,如下:</div><div class="line">def boolAssert(predicate: Boolean) =</div><div class="line">  if (assertionsEnabled &amp;&amp; !predicate)</div><div class="line">    throw new AssertionError</div><div class="line"></div><div class="line">//调用</div><div class="line">boolAssert(5&gt;3) </div><div class="line"></div><div class="line">/*</div><div class="line">虽然可以使用上述的方式,但是: &quot; predicate:=&gt;Boolean &quot; 和 &quot; predicate:Boolean &quot;是两种不同的方式</div><div class="line">因为boolAssert的参数类型是Boolean,在boolAssert(5&gt;3)里括号中的表达式先于boolAssert的调用被评估,表达式5&gt;3产生true,被传给boolAssert</div><div class="line">而在myAssert的predicate参数的类型是  =&gt;Boolean,  myAssert(5&gt;3) 里括号中的表达式不是先于myAssert的调用被评估的,而是代之以先创建一个函数值,其apply方法将被评估 5&gt;3 ,而这个函数值将被传递给myAssert</div><div class="line">*/</div><div class="line">//如果断言被禁用</div><div class="line">var assertionsEnabled = false</div><div class="line"></div><div class="line">myAssert(x/0 == 0)</div><div class="line">boolAssert(x/0 == 0)//抛出异常(被0除),因为其中的表达式是先于函数被评估的,所以会先抛出异常</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/scala编程/第七章 内建控制结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/scala编程/第七章 内建控制结构/" itemprop="url">
                  第七章 内建控制结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>&emsp;scala的几乎所有的控制结构都会产生某个值,这是函数式语言所采用的方式scala的if可以向Java的三元操作符一样产生值,同样for, try, match也产生值, 程序员能够用结果值来简化代码,就如同用函数的返回值那样,如果没有这种机制,程序员就必须创建零时变量来保存控制结构中的计算结果</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/16/scala编程/第七章 内建控制结构/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/scala编程/Scala简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/scala编程/Scala简介/" itemprop="url">
                  第一章 scala简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本书的所有例子能在scala 版本的2.7.2下面编译通过</p>
<h1 id="1-函数式编程"><a href="#1-函数式编程" class="headerlink" title="1.函数式编程"></a>1.函数式编程</h1><p>&emsp;Eric Raymond 把大教堂和集市作为软件开发的两个隐喻,大教堂是几乎近于完美的建筑物,要花很长的时间建设,而一旦建成了就长时间保持不变,相对来说,集市则天天在被工作在其中的人调整和扩展<br>Raymond 的文章中,集市是对于开源软件开发的隐喻, Scala更像是一个集市而不是大教堂,因为他被设计为可以让使用它的人扩展和修改,Scala并没有提供那种”完美齐全”语言中可能需要的所有的东西,而是把制作这些东西的工具放在了你的手中</p>
<p>&emsp;Scala是纯粹的面向对象语言,每个值都是对象,每个操作都是方法,例如:如果使用Scala描述:1+2 ,实际上等于条用定义在Int类里的+方法,方法名可以用像操作符一样的名字定义,以便于API的使用者像使用操作符那样使用方法</p>
<p>&emsp;Scala还是一种成熟的函数式语言,函数式编程有两种指导理念,第一种理念是函数是头等值,在函数式语言中,函数也是值,与整数或字符串处于同一个地位,函数可以被当做参数传递给其他函数,可以当做结果从函数中返回或保存在变量里,可以在函数里定义其他函数,就好像在函数里定义整数一样,还可以定义匿名函数,并随意的插入到代码的任何地方,就好像使用43这样的整数字面量一样<br>函数式编程的第二种理念是程序的操作应该把输入值映射为输出值而不是就地修改数据,在Java和scala里,字符串是一种数学意义上的额字符序列,使用s.replace(‘:’, ‘.’) 这样的表达式替换字符串里的字符会产生一个新的,不同于原字符串s的对象,换句话说就是Java里字符串是不可变的而在一些其他的语言中是可变的,因此单就字符串来说,Java是函数式的语言,不可变数据结构是函数式语言的一块基石,Scala库在Java API之上定义了更多的不可变数据类型,例如:Scala有不可变的列表 , 元组, 映射表, 和集</p>
<p>&emsp;函数式编程第二种理念的另一种解释是,方法不应该有任何的副作用,方法与其所在的环境交流的唯一方式应该是获得参数和返回结果,比如Java里String类的replace方法就是符合这种说法,他的参数包含一个字符串和两个字符串,返回的是一个新的字符串,其中的指定字符串都替换成了另一个,调用replace不会有其他的结果,类似于replace这样的方法被称为  指称透明 , 就是说对于任何输入来讲,都可以用方法的结果替代对他的调用,而不影响程序的语义</p>
<h1 id="2-Why-Scala"><a href="#2-Why-Scala" class="headerlink" title="2.Why Scala?"></a>2.Why Scala?</h1><ol>
<li><p>Scala是兼容的<br>&emsp;scala不需要你脱离Java平台重新学习开发,他可以让你保全现存的代码并添加新东西因为他被设计成可以与Java实施无缝的互操作,Scala程序会被编译成JVM的字节码,其运行时的性能通常与Java程序不分上下,scala代码可以调用Java方法,访问Java字段,继承Java类和实现Java接口,这些都不需要特别的语法,外部接口描述或胶水代码,实际上,程序员们根本都没有意识到,几乎所有Scala代码都大量使用了Java库代码与Java的全交互操作性的另一个方面是Scala大量重用了Java类型,Scala的Int类型代表了Java的原始整数类型Int,Float代表了float等等,Scala不仅重用了Java的类型,而且还把他们打扮得更好看,如Scala的字符串类似于toInt 和toFloat的方法,可以把字符串转换成整数或浮点数,因此可以用str.toInt 代替 Integer.parseInt(str) 方法,不过他在不打破互操作性的基础上是怎么做到这点的呢?Java的String类可没有toInt方法,实际上,Scala有一个通用方案可以解决这种高级库设计和互操作性相对立的问题,Scala允许定义类型失配或者选用不存在的方法时使用隐式转换,在上面的例子里,当在字符串中寻找toInt方法时,Scala编译器会发现String类里没有这种方法,但他会发现Java的String对象转换为Scala的RichString 类实例的隐式转换,而RichString类中定义了这么个方法,于是在执行toInt操作之前,转换被隐式应用了</p>
</li>
<li><p>Scala是简洁的<br>有一种极端的例子是,Scala的代码可以减少到Java的1/10,较为保守的估计大概标准的Scala程序代码行在Java里写的同样程序的一般左右,更少的行数不仅意味着打更少的字,同样意味着更少的对程序的阅读和理解,以及更少出错的机会,如:Java和scala的构造函数的对比就可以看出来了</p>
</li>
</ol>
<ol>
<li><p>scala是高级的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#java 写法</div><div class="line">boolean nameHasUpperCase = false;</div><div class="line">for (int i=0; i&lt;name.length(); i++)&#123;</div><div class="line">    if(Character.isUpperCase(name.charAt(i)))&#123;</div><div class="line">        nameHasUpperCase = true;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#scala写法</div><div class="line">val nameHasUpperCase = name.exists(_.isUpperCase)</div></pre></td></tr></table></figure>
</li>
<li><p>scala是静态类型的<br>&emsp;scala是以Java的内嵌类型系统为基础,允许使用泛型参数化类型,用交集组合类型及抽象类型影藏类型细节,这都为自建类型打下了坚实的基础,从而能够设计出既安全又灵活使用的接口,静态类型检查可以提供一些基础的编码上的检查,从而避免在程序运行时出错而重新排错的可能</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/scala编程/Scala入门初探/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/scala编程/Scala入门初探/" itemprop="url">
                  第二章 scala入门初探
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/scala/" itemprop="url" rel="index">
                    <span itemprop="name">scala</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="1-变量定义"><a href="#1-变量定义" class="headerlink" title="1.变量定义"></a>1.变量定义</h1><p>先写变量后写类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">scala&gt; val msg: java.lang.String = &quot;hello world!&quot;</div><div class="line">msg: String = hello world!</div><div class="line"></div><div class="line">//或者</div><div class="line">scala&gt; val msg: String = &quot;hello world!&quot;        #先写变量名称,再写变量类型</div><div class="line">msg: String = hello world!    #定义了一个名称为msg的变量,类型为String, 值为 &quot;hello world!&quot;</div><div class="line"></div><div class="line">scala&gt;</div></pre></td></tr></table></figure></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/04/16/scala编程/Scala入门初探/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/16/python/面向对象编程-属性和方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Mr. Chen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/16/python/面向对象编程-属性和方法/" itemprop="url">
                  面向对象编程-属性和方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T12:47:25+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实例化步骤"><a href="#实例化步骤" class="headerlink" title="实例化步骤"></a>实例化步骤</h1><ol>
<li>调用__new__()方法创建实例</li>
<li>__new__()方法自动从object继承</li>
<li>调用<strong>init</strong>()方法对其初始化</li>
<li>__init__()方法在类中定义</li>
</ol>
<h1 id="添加类说明"><a href="#添加类说明" class="headerlink" title="添加类说明"></a>添加类说明</h1><ul>
<li>紧跟类名之后,以三引号包围的字符串</li>
<li>查看类说明<ol>
<li>类名.__doc__</li>
<li>help(类名)</li>
</ol>
</li>
</ul>
<h1 id="新式类与经典类"><a href="#新式类与经典类" class="headerlink" title="新式类与经典类"></a>新式类与经典类</h1><ul>
<li>Python 3.x版本<br>统一为新式类,不用继承object</li>
<li>区别<ol>
<li>经典类继承为深度优先</li>
<li>新式类继承为广度优先</li>
</ol>
</li>
</ul>
<h1 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h1><ul>
<li>类被实例化以后才会具有的属性</li>
<li>一般在__init__方法中创建并初始化</li>
<li>直接使用即定义:self.&lt;属性名&gt;</li>
<li>引用方法:self.&lt;属性名&gt;</li>
<li>self用来代表类的实例的</li>
<li>类外用实例名.属性名方式定义和引用</li>
<li>相同类的不同实例其实例属性是不相关的</li>
<li>一般不建议在__init__()方法之外创建和初始化实例属性</li>
<li>一般不推荐类外定义和修改,修改可以单独定义方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class TestCss:</div><div class="line">	def __init__(self):</div><div class="line">		self.a = 0</div><div class="line">		self.b = 10</div><div class="line"></div><div class="line">	def info(self):</div><div class="line">		print(&quot;a:&quot;, self.a, &quot;  b:&quot;,self.b)</div><div class="line"></div><div class="line"></div><div class="line">if ___name__ == &apos;___name__&apos;:</div><div class="line">	tc = TestCss()</div><div class="line">	tc.info()</div><div class="line">	tc.color = &quot;red&quot;    //实例属性</div><div class="line">	print(tc.color)</div><div class="line"># 可以在类外动态的添加实例属性，如上面的color就是一个动态添加的实例属性</div></pre></td></tr></table></figure>
<h1 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h1><ul>
<li>类定义后就存在,且不需要实例化</li>
<li>类属性使得相同类的不同实例共同持有相同变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class TestCss:</div><div class="line">	cssa = &quot;class-attribute&quot;</div><div class="line">	def __init__(self):</div><div class="line">		self.a = 0</div><div class="line">		self.b = 10</div><div class="line"></div><div class="line">	def info(self):</div><div class="line">		print(&quot;a:&quot;, self.a, &quot;  b:&quot;,self.b, &quot;cssa:&quot;, TestCss.cssa)</div><div class="line"></div><div class="line">	def define_a(self):</div><div class="line">		self.c = 19</div><div class="line"></div><div class="line">if __name__ == &apos;___name__&apos;:</div><div class="line">	tc = TestCss()</div><div class="line">	tc.info()</div><div class="line">	tc.color = &quot;red&quot;</div><div class="line">	print(tc.color)</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h1><ul>
<li>不提供限制属性访问的关键字(无法限制类的各种属性在类外直接访问)</li>
<li>使用__开头的变量名加以标志,只有对象自己能访问</li>
<li>使用_开头的变量名加以标志,应该只有类对象及其子类能访问(非强制性)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">class A:</div><div class="line">	def __init__(self):</div><div class="line">		self.__ab = 0</div><div class="line"></div><div class="line">	def info(self):</div><div class="line">		print(self.__ab)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">	a = A()</div><div class="line">	a.info()</div><div class="line">	a.__ab = 3</div><div class="line">	a.info()</div><div class="line">	print(a.__ab)</div><div class="line"></div><div class="line">#执行结果</div><div class="line">0</div><div class="line">0</div><div class="line">3</div><div class="line">[Finished in 0.2s]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">class A:</div><div class="line">	def __init__(self):</div><div class="line">		self._ab = 0</div><div class="line"></div><div class="line">	def info(self):</div><div class="line">		print(self._ab)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">	a = A()</div><div class="line">	a.info()</div><div class="line">	a._ab = 3</div><div class="line">	a.info()</div><div class="line">	print(a._ab)</div><div class="line"></div><div class="line">#执行结果:</div><div class="line">0</div><div class="line">3</div><div class="line">3</div><div class="line">[Finished in 0.2s]</div><div class="line"></div><div class="line">#单下划线在外部仍然是可以访问的，所以上面说是非强制性的</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h1><ul>
<li>__doc__</li>
<li>__name__</li>
<li>__dict__</li>
<li>__module__</li>
<li><p>__base__</p>
<p>可以使用dir(Student)看student类有哪些特殊属性，注意这些特殊属性是使用两个下划线开头和结束的</p>
</li>
</ul>
<h1 id="同名的类属性与实例属性"><a href="#同名的类属性与实例属性" class="headerlink" title="同名的类属性与实例属性"></a>同名的类属性与实例属性</h1><ul>
<li>以实例名.属性名引用时,优先引用实例属性</li>
<li>以类名.属性名引用时,只能引用类属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class A:</div><div class="line">...     a=0</div><div class="line">...     def __init__(self):</div><div class="line">...             self.a=10</div><div class="line">...             self.b=100</div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">&gt;&gt;&gt; a = A()</div><div class="line">&gt;&gt;&gt; a.a</div><div class="line">10</div><div class="line">&gt;&gt;&gt; A.a</div><div class="line">0</div><div class="line">&gt;&gt;&gt; A.b</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">AttributeError: type object &apos;A&apos; has no attribute &apos;b&apos;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="属性访问的特殊方法-反射"><a href="#属性访问的特殊方法-反射" class="headerlink" title="属性访问的特殊方法(反射)"></a>属性访问的特殊方法(反射)</h1><ul>
<li>提供用字符串来操作类的属性/方法的方式</li>
<li>主要工具函数<ul>
<li>hasattr(obj_name, ‘属性名’)</li>
<li>setattr(obj_name, “属性名”, 值)</li>
<li>getattr(obj_name, “属性名”)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class A:</div><div class="line">...     a=0</div><div class="line">...     def __init__(self):</div><div class="line">...             self.a=10</div><div class="line">...             self.b=100</div><div class="line">...</div><div class="line"></div><div class="line">&gt;&gt;&gt; getattr(a,&quot;a&quot;)</div><div class="line">10</div><div class="line">&gt;&gt;&gt; setattr(a,&quot;a&quot;,30)</div><div class="line">&gt;&gt;&gt; hasattr(a, &quot;b&quot;)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; hasattr(a, &quot;cc&quot;)</div><div class="line">False</div></pre></td></tr></table></figure>
<h1 id="属性包装"><a href="#属性包装" class="headerlink" title="属性包装"></a>属性包装</h1><ul>
<li>将方法包装成属性,以隐藏相关实例<ul>
<li>控制属性的类型或范围</li>
<li>虚拟属性(由其他属性处理后得来)</li>
</ul>
</li>
<li>三种属性操作<ul>
<li>可读:@property</li>
<li>可写:@<property-name>.setter</property-name></li>
<li>可删: @<property-name>.deleter</property-name></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Watcher:</div><div class="line">	def __init__(self, water=10,scour=2):</div><div class="line">		self._water = water</div><div class="line">		self.scour = scour</div><div class="line"></div><div class="line">	@property</div><div class="line">	def water(self):</div><div class="line">		return self._water</div><div class="line"></div><div class="line">	def set_water(self, water):</div><div class="line">		self.water = water</div><div class="line"></div><div class="line">	@water.setter</div><div class="line">	def water(self, water):</div><div class="line">		if 0&lt;water&lt;=500:</div><div class="line">			self._water = water</div><div class="line">		else:</div><div class="line">			print(&quot;set failure&quot;)</div><div class="line">#将方法装饰成为属性，在外部看来是访问属性，其实就是访问类的中的方法</div></pre></td></tr></table></figure>
<h1 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h1><ul>
<li>将实现特殊协议方法的类作为另一个类的类属性</li>
<li>用来拦截和控制属性访问并可以重复使用</li>
<li>协议方法<ul>
<li>__get__()</li>
<li>__set__()</li>
<li>__delete__()</li>
</ul>
</li>
<li>分类<ul>
<li>数据描述符(实现全部协议方法)</li>
<li>非数据描述符(实现部分协议方法)</li>
<li>说明:所有类成员函数都是非数据描述符</li>
</ul>
</li>
<li>同名的实例属性和非数据描述符(以方法为例)访问优先级</li>
<li>注意:只能在新式类中使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class NonNeg:</div><div class="line">	def __init__(self, default=0):</div><div class="line">		self.default = default</div><div class="line"></div><div class="line">	def __get__(self, instance, owner):</div><div class="line">		return self.default</div><div class="line"></div><div class="line">	def __set__(self, instance, val):</div><div class="line">		if val &gt; 0:</div><div class="line">			self.default = val</div><div class="line">		else:</div><div class="line">			print(&quot;The value must be NonNegative&quot;)</div><div class="line"></div><div class="line">class Movie:</div><div class="line">	rating = NonNeg()</div><div class="line">	score = NonNeg()</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">	m = Movie()</div><div class="line">	print(&quot;rating: &quot;, m.rating)</div><div class="line">	print(&quot;score: &quot;, m.score)</div><div class="line"></div><div class="line">	m.rating = 80        //在set的时候会将self作为隐藏的参数,传给方法</div><div class="line">	print(&quot;rating:&quot;, m.rating)</div><div class="line"></div><div class="line">	m.score = -3</div><div class="line">	print(&quot;score:&quot;, m.score)</div><div class="line"></div><div class="line">#打印结果:</div><div class="line">rating:  0</div><div class="line">score:  0</div><div class="line">rating: 80</div><div class="line">The value must be NonNegative</div><div class="line">score: 0</div><div class="line">[Finished in 0.3s]</div></pre></td></tr></table></figure>
</li>
</ul>
<p>__call__()让类的实例如函数一样可调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; class Test:</div><div class="line">...     def __call__(self):</div><div class="line">...             print(&quot;call.....&quot;)</div><div class="line">...</div><div class="line">&gt;&gt;&gt; t = Test()  //相当于将__call__返回返回了</div><div class="line">&gt;&gt;&gt; t()        //调用方法</div><div class="line">call.....</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h1 id="类方法-静态方法"><a href="#类方法-静态方法" class="headerlink" title="类方法,静态方法"></a>类方法,静态方法</h1><ul>
<li>静态方法<ul>
<li>定义方法<ul>
<li>@staticmethod装饰,参数不用self</li>
</ul>
</li>
<li>访问特性<ul>
<li>不能引用或访问实例属性,可以通过了类,类变量访问属性</li>
</ul>
</li>
<li>调用方法<ul>
<li>可以用类,类实例调用</li>
</ul>
</li>
<li>本质<ul>
<li>在类中的一个普通函数而已,使面向对象程序中函数归属于类,易于代码管理</li>
</ul>
</li>
<li>用法<ul>
<li>与类相关,但不依赖或改变类与实例</li>
<li>创建不同的实例</li>
<li>把类相关工具方法放入类中</li>
</ul>
</li>
</ul>
</li>
<li>类方法<ul>
<li>定义方法<ul>
<li>@classmethod,必须提供参数cls<br>*访问特性</li>
<li>不能引用或访问实例属性</li>
</ul>
</li>
<li>调用方法<ul>
<li>可以用类,类实例调用</li>
</ul>
</li>
<li>继承特性<ul>
<li>继承时,传入的类变量cls是子类,而非父类</li>
</ul>
</li>
<li>用途<ul>
<li>与类相关,但不依赖或改变类的实例</li>
<li>工厂方法,创建类实例,完成有关预处理</li>
<li>在类内调用静态方法时不能硬编码类名</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Watcher(object):</div><div class="line">	&quot;&quot;&quot;docstring for Watcher&quot;&quot;&quot;</div><div class="line">	def __init__(self,water=10, scour=2):</div><div class="line">		super(Watcher, self).__init__()</div><div class="line">		self._water = water</div><div class="line">		self.scour = scour</div><div class="line">		self.year = 2010</div><div class="line"></div><div class="line"></div><div class="line">	@staticmethod</div><div class="line">	def spins_ml(spins):</div><div class="line">		print(&quot;company: &quot;, Watcher.company)</div><div class="line">		print(&quot;year: &quot;, self.year)</div><div class="line">		return spins * 0.4</div><div class="line"></div><div class="line">	@classmethod</div><div class="line">	def get_water(cls, watter, scour)://cls 是指代的实例对象</div><div class="line">		return cls(water,cls.spins_ml(scour))</div><div class="line"></div><div class="line">	@property </div><div class="line">	def water():</div><div class="line">		return self._water</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">	print(Watcher.spins_ml(8))</div><div class="line">	w = Watcher()</div><div class="line">	print(w.spins_ml(8))</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/header.jpg"
               alt="Mr. Chen" />
          <p class="site-author-name" itemprop="name">Mr. Chen</p>
           
              <p class="site-description motion-element" itemprop="description">一个技术渣的自说自话</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">555</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr. Chen</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
