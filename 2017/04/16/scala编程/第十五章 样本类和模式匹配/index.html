<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第十五章 样本类和模式匹配 | Chen&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.简单的例子12345678910111213141516171819202122232425abstract class Exprcase class Var(name: String) extends Exprcase class Number(num: Double) extends Exprcase class UnOP(operator: String, arg: Expr) exte">
<meta name="keywords" content="scala,scala编程">
<meta property="og:type" content="article">
<meta property="og:title" content="第十五章 样本类和模式匹配">
<meta property="og:url" content="http://yoursite.com/2017/04/16/scala编程/第十五章 样本类和模式匹配/index.html">
<meta property="og:site_name" content="Chen's Blog">
<meta property="og:description" content="1.简单的例子12345678910111213141516171819202122232425abstract class Exprcase class Var(name: String) extends Exprcase class Number(num: Double) extends Exprcase class UnOP(operator: String, arg: Expr) exte">
<meta property="og:image" content="http://ols7leonh.bkt.clouddn.com//assert/img/scala_programming/15/1.png">
<meta property="og:updated_time" content="2017-03-04T11:22:09.078Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第十五章 样本类和模式匹配">
<meta name="twitter:description" content="1.简单的例子12345678910111213141516171819202122232425abstract class Exprcase class Var(name: String) extends Exprcase class Number(num: Double) extends Exprcase class UnOP(operator: String, arg: Expr) exte">
<meta name="twitter:image" content="http://ols7leonh.bkt.clouddn.com//assert/img/scala_programming/15/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Chen&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Chen&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个技术渣的自说自话</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-scala编程/第十五章 样本类和模式匹配" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/scala编程/第十五章 样本类和模式匹配/" class="article-date">
  <time datetime="2017-04-16T04:47:25.911Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/scala/">scala</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      第十五章 样本类和模式匹配
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-简单的例子"><a href="#1-简单的例子" class="headerlink" title="1.简单的例子"></a>1.简单的例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">abstract class Expr</div><div class="line">case class Var(name: String) extends Expr</div><div class="line">case class Number(num: Double) extends Expr</div><div class="line">case class UnOP(operator: String, arg: Expr) extends Expr</div><div class="line">case class BinOp(operator: String, left: Expr, right: Expr) extends Expr</div><div class="line"></div><div class="line">/*</div><div class="line">上述每个class类都有一个case修饰符,带有这种修饰符的类被称为样本类(case class) ,这种修饰符可以让scala的编译器自动为你的类添加一些语句上的便捷设定</div><div class="line">1.他会添加与类名一致的工厂方法,比如:写成Var(&quot;x&quot;)来构造Var对象以替代稍长一些的new Var(&quot;x&quot;)</div><div class="line">  val v = Var(&quot;x&quot;)</div><div class="line"></div><div class="line">2.样本类参数列表中的所有参数隐式获得了val前缀,因此他被当做你字段维护</div><div class="line">v.name</div><div class="line">op.left</div><div class="line"></div><div class="line">3.编译器为你的类添加了方法toString,hashCode和equals的自然实现,他们能够打印,哈希和比较由类及其所有参数组成的整棵树,因为scala里的==始终直接转到equals,这也就特别意味着样本类的元素一直是在做结构化的比较</div><div class="line">val op = BinOp(&quot;+&quot;, Number(1), v)</div><div class="line">println(op)   //BinOp(+, Number(1.0), Var(x))</div><div class="line">op.right == Var(&quot;x&quot;)   //true</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">所有这些转换以极低的代价带来了大量的便利,代价就是必须写case修饰符并且你的类和对象都会变得稍微大一点,变大的原因是因为产生了附加的方法及对于每个构造器参数添加了隐含的字段,不过样本类最大的好处还在于它们能够支持模式匹配</div><div class="line">*/</div></pre></td></tr></table></figure>
<a id="more"></a>
<p> 模式匹配<br>&emsp;假如你想简化之前看到的数学表达式,可能有许多的简化规则,以下三条规则只是作为演示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Unop(&quot;-&quot;, Unop(&quot;-&quot;, e))    =&gt; e    //双重负号</div><div class="line">BinOp(&quot;+&quot;, e, Number(0))  =&gt; e    //加0</div><div class="line">BinOp(&quot;*&quot; , e, Number(1)) =&gt;e     //乘1</div><div class="line"></div><div class="line"></div><div class="line">//在函数方面的应用</div><div class="line">def simplifyTop(expr: Expr): Expr = expr match &#123;</div><div class="line">  case UnOp(&quot;-&quot;, UnOp(&quot;-&quot;, e)) =&gt; e //双重负号</div><div class="line">  case BinOp(&quot;+&quot;, e, Number(0)) =&gt; e  //加0</div><div class="line">  case BinOp(&quot;*&quot;, e, Number(1)) =&gt; e   //乘1</div><div class="line">  case _ =&gt; expr</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">simplifyTop右侧的部分组成了match表达式,match对应于Java里的switch,不过他写在选择器表达式之后,也就是说:</div><div class="line">//java</div><div class="line">选择器 match &#123;备选项&#125;</div><div class="line"></div><div class="line">//scala</div><div class="line">switch &#123;选择器&#125; &#123;备选项&#125;</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">一个模式匹配包含了一系列备选项,每个都开始于关键字case,每个备选项都包含了一个模式及一到多个表达式,他们将在模式匹配过程中被计算,箭头符号 =&gt; 隔开了模式和表达式</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p> match与switch的比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/*</div><div class="line">匹配表达式可以被看做java风格switch的泛化,当每个模式都是常量并且最后一个模式可以是通配(表示为switch的default情况)的时候,java风格的switch可以被自然的表达为match表达式,需要记住三点</div><div class="line">1.match是scala的表达式,也就是说,他始终以值作为结果</div><div class="line">2.scala的备选项表达式永远不会&quot;掉到&quot; 下一个case,这一点不同于java的switch</div><div class="line">3.如果没有模式匹配,MatchError异常会被抛出,所以对模式匹配至少添加一个默认情况</div><div class="line">*/</div><div class="line">expr match &#123;</div><div class="line">    case BinOp(op, left, right) =&gt; println(expr + &quot;is a binary operation&quot;)</div><div class="line">    case _ =&gt;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">上述代码中第二个情况是必须的,否则的话,match表达式将在每个expr参数不是BinOp的时候抛出MatchError,在这个例子里,对于第二种情况没有指定代码,因此如果跑到了这里就什么都不做,每个情况的结果都是unit值 () ,因此这也就是整个match表达式的结果</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h1 id="2-模式的种类"><a href="#2-模式的种类" class="headerlink" title="2.模式的种类"></a>2.模式的种类</h1><p> 通配模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//通配模式(_)匹配任意对象,他被用作默认的&quot;全匹配&quot;的备选项</div><div class="line">expr match &#123;</div><div class="line">  case BinOp(op, left, right) =&gt; println(expr + &quot;is a binary operatoin&quot;)</div><div class="line">  case _ =&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//通配模式还可以用来忽略对象中你不关心的部分,如,前一个例子实际上并不关心二元操作符的元素是什么,只是检查是否为二元操作符,因此使用了通配符指代如下:</div><div class="line">expr match &#123;</div><div class="line">  case BinOp(_, _, _) =&gt; println(expr + &quot;is a binary operatoin&quot;)//并没有使用匹配到的元素,所以使用了通配符去</div><div class="line">  case _ =&gt;println(&quot;it&apos;s something else &quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 常量模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">常量模式仅匹配自身,任何字面量都可以用作常量.例如:5, true 还有&quot;hello&quot; 都是常量模式,还有任何val或单例对象也可以被用作常量,例如单例对象Nil是只匹配空列表的模式</div><div class="line">*/</div><div class="line">def describe(x: Any) = x match &#123;</div><div class="line">  case 5 =&gt; &quot;five&quot;</div><div class="line">  case true =&gt; &quot;truth&quot;</div><div class="line">  case &quot;hello&quot; =&gt; &quot;hit&quot;</div><div class="line">  case Nil =&gt; &quot;the empty list&quot;</div><div class="line">  case _ =&gt; &quot;something else&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//打印结果</div><div class="line"></div><div class="line">scala&gt; describe(5)</div><div class="line">res0: String = five</div><div class="line"></div><div class="line">scala&gt; describe(true)</div><div class="line">res1: String = truth</div><div class="line"></div><div class="line">scala&gt; describe(&quot;hello&quot;)</div><div class="line">res2: String = hit</div><div class="line"></div><div class="line">scala&gt; describe(Nil)</div><div class="line">res3: String = the empty list</div><div class="line"></div><div class="line">scala&gt; describe(List(2,3))</div><div class="line">res4: String = something else</div></pre></td></tr></table></figure></p>
<p> 变量模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">变量模式类似于通配符,可以匹配任意对象,scala把变量绑定在匹配的对象上,因此可以使用这个变量操作对象</div><div class="line">*/</div><div class="line">expr match &#123;</div><div class="line">  case 0 =&gt; &quot;zero&quot;</div><div class="line">  case somethingElse =&gt; &quot;not zero&quot; + somethingElse</div><div class="line">&#125;</div><div class="line"></div><div class="line">//常量模式也可以有符号名,我们使用Nil表示空列表,以下是一个与之相关的例子,这里模式匹配采用了常量E(2.71828)和常量Pi(3.1415926)</div><div class="line">import Math.&#123;E,PI&#125;</div><div class="line">E match &#123;</div><div class="line">  case PI =&gt; &quot;strange math ? pi = &quot; + PI</div><div class="line">  case  _ =&gt; &quot;Ok&quot;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">scala用小写的字母开始的简单名被当做是模式变量,所有其他的引用被认为是常量</div><div class="line">*/</div><div class="line"></div><div class="line">val pi = Math.PI</div><div class="line">E match &#123;</div><div class="line">    case pi  =&gt; &quot;strange math? Pi=&quot; + pi</div><div class="line">    case _ =&gt; &quot;ok&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&lt;console&gt;:13:error: unreachable code due to variable pattern &apos;pi&apos; on line 12</div><div class="line">                  case _ =&gt; &quot;ok&quot;</div><div class="line">                            ^</div><div class="line">/*</div><div class="line">在这里编译器甚至都不会让你添加默认情况,因为pi是变量模式,他可以匹配任意输入,因为之后的_ 将永远不能访问到</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">解决的方式有两种:</div><div class="line">1.如果常量是某个对象的字段,可以在其之上用限定符前缀,例如:pi是变量模式,但是this.pi 或obj.pi虽然都开始于小写字母但都是常量,</div><div class="line">2.如果这不起作用(比如说,pi是本地变量) 还可以反引号包住变量名,例如: `pi`会再次被解释为常量,而不是变量</div><div class="line">*/</div><div class="line"></div><div class="line">E match &#123;</div><div class="line">  case `pi` =&gt; &quot;strange math ? pi = &quot; + PI</div><div class="line">  case  _ =&gt; &quot;Ok&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 构造器模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">这种模式意味着scala模式支持深度匹配,这种模式不只是检查顶层对象是否一致,还会检查对象的内容是否匹配内层的模式,由于额外的模式自身可以形成构造器模式,因此可以使用它们检查到对象内部的任意深度,例如:如下的代码,检查了对象的顶层是BinOp ,以及他的第三个构造器参数是Number ,以及他的值为数字0,这个模式仅有一行却能够检查三层深度</div><div class="line">*/</div><div class="line"></div><div class="line">expr match &#123;</div><div class="line">  case BinOp(&quot;+&quot;, e, Number(0)) =&gt; println(&quot;a deep match&quot;)</div><div class="line">  case _ =&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 序列模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//你也可以像匹配样本类那样匹配如List, 或 Array这样的序列类型,不过同样的语法现在可以指定模式内任意数量的元素,例如:下面的代码展示了检查开始于零的三元素列表的模式</div><div class="line"></div><div class="line">expr match &#123;</div><div class="line">  case List(0, _, _) =&gt; println(&quot;found list&quot;)</div><div class="line">  case _ =&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//如果你想匹配一个不指定长度的序列,可以指定_*作为模式的最后元素,这种古怪的模式能匹配序列中零到任意数量的元素,如下代码,展示了匹配由零开始,不计长度的任意序列的模式</div><div class="line"></div><div class="line">expr match &#123;</div><div class="line">  case List(0, _*) =&gt; println(&quot;found list&quot;)</div><div class="line">  case _ =&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 元组模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//如下,你可以匹配类似(a,b,c)这样的模式可以匹配任意的3-元组</div><div class="line"></div><div class="line">def tupleDemo(expr: Any) = expr match &#123;</div><div class="line">  case (a, b, c) =&gt; println(&quot;matched&quot; + a + b + c)</div><div class="line">  case _ =&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 类型模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//你可以把类型模式当做类型测试和类型转换的简易替代</div><div class="line"></div><div class="line">def generalSize(x: Any) = x match &#123;</div><div class="line">  case s: String =&gt; s.length</div><div class="line">  case m:Map[_, _] =&gt; m.size</div><div class="line">  case _ =&gt; 1</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用</div><div class="line">scala&gt; generalSize(&quot;abc&quot;)</div><div class="line">res8: Int = 3</div><div class="line"></div><div class="line">scala&gt; generalSize(Map(1-&gt;&apos;a&apos;, 2 -&gt;&apos;b&apos;))</div><div class="line">res9: Int = 2</div><div class="line">/*</div><div class="line">在上面的例子中,尽管x和s是指代了同样的值,不过x是Any而s是String,因此可以在模式对应的备选项表达式中写成s.length但是不能写成x.length,因为Any类型没有length成员</div><div class="line">*/</div><div class="line"></div><div class="line">//替代模式匹配的例子,类型转换</div><div class="line">if (x.isInstanceOf[String])&#123;    //isInstanceOf 类型测试</div><div class="line">  val s = x.asInstanceOf[String]    //asInstanceOf 类型转换</div><div class="line">  s.length</div><div class="line">&#125;else   //...</div><div class="line"></div><div class="line">/*</div><div class="line">上面的代码中,scala里类型测试和转换的代码真的很冗长,所以我们并不鼓励这样去做,使用带有类型模式的模式匹配通常就能够满足你的需求,尤其在需要同时做类型测试和转换的场景时,因为这两种操作都被融入一个模式匹配之中了</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p> 类型擦除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//特定元素类型的映射能匹配吗?比如说测试给定值是否是从Int到Int的映射,让我们试一下</div><div class="line">def isIntToIntMap(x: Any) = x match &#123;</div><div class="line">  case m: Map[Int, Int] =&gt; true</div><div class="line">  case - =&gt; false</div><div class="line">&#125;</div><div class="line"></div><div class="line">//在scala命令行测试结果如下:</div><div class="line">&lt;console&gt;:9: warning: non-variable type argument Int in type pattern Map[Int,Int</div><div class="line">] is unchecked since it is eliminated by erasure</div><div class="line">         case m: Map[Int, Int] =&gt; true</div><div class="line">                 ^</div><div class="line"></div><div class="line">/*</div><div class="line">scala使用了泛型的擦除模式,就如java那样,也就是说类型参数信息没有保留到运行期,因此运行期没有办法判断给定的Map对象创建时带了两个Int参数,还是带了两个其他类型的参数,系统所能做的只是判断这个值是某种任意类型参数的Map</div><div class="line"></div><div class="line">擦除规则的唯一例外就是数组,因为在scala里和java里,他们都被特殊处理了,数组的元素类型与数组值保存在一起,因此他可以做模式匹配</div><div class="line">*/</div><div class="line">def isStringArray(x: Any) = x match &#123;</div><div class="line">  case a: Array[String] =&gt; &quot;yes&quot;</div><div class="line">  case _ =&gt; &quot;no&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//测试结果</div><div class="line">scala&gt; val as = Array(&quot;abc&quot;)</div><div class="line">as: Array[String] = Array(abc)</div><div class="line">scala&gt; isStringArray(as)</div><div class="line">res11: String = yes</div><div class="line"></div><div class="line">scala&gt; val al = Array(1,3,5)</div><div class="line">al: Array[Int] = Array(1, 3, 5)</div><div class="line">scala&gt; isStringArray(al)</div><div class="line">res12: String = no</div></pre></td></tr></table></figure></p>
<p> 变量绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">除了独立的模式变量模式之外,你还可以对任何其他模式添加变量,只要简单的写上变量名,一个@符号,以及这个模式,这种写法创造了变量绑定模式,这种模式的意义在于他能够像通常的那样做模式匹配,并且如果匹配成功,则把变量设置成匹配的对象,就像使用简单的变量模式那样</div><div class="line">*/</div><div class="line">expr match &#123;</div><div class="line">  case UnOp(&quot;abc&quot;, e @ UnOp(&quot;abc&quot;, _)) =&gt; e</div><div class="line">  case _ =&gt;</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">上述代码中使用e作为变量及UnOp(&quot;abc&quot;, _) 作为模式的变量绑定模式,如果整个模式匹配成功,那么符合UNOp(&quot;abc&quot;,_) 的部分就可以使用e指代</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h1 id="3-模式守卫"><a href="#3-模式守卫" class="headerlink" title="3.模式守卫"></a>3.模式守卫</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">需求:如果你想要简化e+e的操作,写成 e*2 ,表示成Expr树的语言,就是表达式</div><div class="line">*/</div><div class="line">BinOp(&quot;+&quot;, Var(&quot;x&quot;), Var(&quot;x&quot;))</div><div class="line">//简化为</div><div class="line">BinOp(&quot;*&quot;, Var(&quot;x&quot;), Number(2))</div><div class="line"></div><div class="line">//获取你尝试如下的方式定义规则:</div><div class="line">def simplifyAdd(e: Expr) = e match &#123;</div><div class="line">  case BinOp(&quot;+&quot;, x, x) =&gt; BinOp(&quot;*&quot;, x, Number(2))</div><div class="line">&#125;</div><div class="line">//编译器会报如下的错误:</div><div class="line">&lt;console&gt;: 10: error: x is already defined as value x </div><div class="line">        case BinOp(&quot;+&quot;, x, x) =&gt; BinOp(&quot;*&quot;, x, Number(2))</div><div class="line">                     ^</div><div class="line">/*</div><div class="line">模式变量仅允许在模式中出现一次,也就是说 case BinOp(&quot;+&quot;, x, x) 中第二个x是重复出现的,不过你可以使用模式守卫重新定制这个匹配规则</div><div class="line">*/</div><div class="line">def simplifyAdd(e: Expr) = e match &#123;</div><div class="line">  case BinOp(&quot;+&quot;, x, y) if x==y =&gt; BinOp(&quot;*&quot;, x, Number(2))</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">模式守卫接在模式之后,开始于if,守卫可以是任意的引用模式中变量的布尔表达式,如果存在模式守卫,那么只有在守卫返回true的时候匹配才成功,</div><div class="line">*/</div><div class="line"></div><div class="line">//下面是模式匹配的其他例子</div><div class="line">case n: Int if 0&lt;n =&gt; ....    //仅仅匹配正整数</div><div class="line">case s: String if s(0) == &apos;a&apos; =&gt; ...    //仅仅匹配以字母&apos;a&apos;开始的字符串</div></pre></td></tr></table></figure>
<h1 id="4-模式重叠"><a href="#4-模式重叠" class="headerlink" title="4.模式重叠"></a>4.模式重叠</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def simplifyAll(expr: Expr): Expr = expr match &#123;</div><div class="line">  case UnOp(&quot;-&quot;, UnOp(&quot;-&quot;, e)) =&gt; simplifyAll(e)</div><div class="line">  case BinOp(&quot;+&quot;, e, Number(0)) =&gt; simplifyAll(e)</div><div class="line">  case BinOp(&quot;*&quot;, e, Number(1)) =&gt; simplifyAll(e)</div><div class="line">  case UnOp(op,e) =&gt; UnOp(op,simplifyAll(e))</div><div class="line">  case BinOp(op, left, right) =&gt; BinOp(op, simplifyAll(left), simplifyAll(right))</div><div class="line">  case _ =&gt; expr</div><div class="line">&#125;</div><div class="line"></div><div class="line">//全匹配的样本要跟在更具体的简化方法之后,例如下面的match表达式不会编译成功,因为一地个样本匹配任何能匹配第二个样本的东西</div><div class="line">def simplifyBad(expr: Expr): Expr = expr match &#123;</div><div class="line">  case UnOp(op, e) =&gt; UnOp(op,simplifyBad(e))</div><div class="line">  case UnOp(&quot;-&quot;, UnOp(&quot;-&quot;, e)) =&gt; e</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-封闭类"><a href="#5-封闭类" class="headerlink" title="5.封闭类"></a>5.封闭类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">一旦你写好了模式匹配,你就需要确信已经考虑了所有可能的情况,有些时候你可以通过在匹配的最后添加默认处理做到这点,不过这仅仅在的确有一个合理的默认行为的情况下有效,如果没有默认的情况该怎么办?你怎样才能保证包括了所有的情况呢?</div><div class="line"></div><div class="line">可选的方案就是让样本类的超类被封闭,封闭类除了类定义所在的文件之外不能再添加任何新的子类,这意味着你仅需要关心你已经知道的子类即可</div><div class="line">*/</div><div class="line"></div><div class="line">/*</div><div class="line">如果你打算做模式匹配的类层级,你应当考虑封闭他们,只要把关键字sealed放在最顶层类的前边即可,如下</div><div class="line">*/</div><div class="line">sealed abstract class Expr</div><div class="line">case class Var(name: String) extends Expr</div><div class="line">case class Number(num: Double) extends Expr</div><div class="line">case class UnOp(operator: String, arg: Expr) extends Expr</div><div class="line">case class BinOp(operator: String, left: Expr, right: Expr) extends Expr</div><div class="line"></div><div class="line">//使用实例</div><div class="line">def describe(e: Expr): String = e match &#123;</div><div class="line">  case Number(_) =&gt; &quot;is a number&quot;</div><div class="line">  case Var(_) =&gt; &quot;is a variable&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//执行结果</div><div class="line">warning: match may not be exhaustive.</div><div class="line">missing combination     UnOp</div><div class="line">missing combination     BinOp</div><div class="line"></div><div class="line">/*</div><div class="line">这样的警告向你表明你的代码会有产生MatchError异常的风险,因为某些可能的模式(UnOp, BinOp)没有被处理,警告指出了潜在的运行期故障的源头,因此他通常能够帮助你正确的编程</div><div class="line">*/</div><div class="line">                                       ^</div><div class="line">/*</div><div class="line">然而,有些时候你或许会碰到这样的情况,编译器弹出太过挑剔的警告,例如:或许可以通过上下文知道你只会把上面的describe方法应用在仅仅是Number或Var的表达式上,因此你知道实际上不会产生MatchError,要让这些警告不再发生,你可以为方法添加用作全匹配的第三个样本,如下:</div><div class="line">*/</div><div class="line">def describe(e: Expr): String = e match &#123;</div><div class="line">  case Number(_) =&gt; &quot;is a number&quot;</div><div class="line">  case Var(_) =&gt; &quot;is a variable&quot;</div><div class="line">  case _ =&gt; throw new RuntimeException  //不会发生</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">上面的做法的确有效,但是不理想,你或许对被迫添加不会被执行(至少你是这么认为的),而只是让编译器闭嘴的代码感到不爽,更轻量级的做法是给匹配的选择器表达式添加 @unchecked 注解,如下</div><div class="line">*/</div><div class="line">def describe(e: Expr): String = (e: @unchecked) match &#123;</div><div class="line">  case Number(_) =&gt; &quot;is a number&quot;</div><div class="line">  case Var(_) =&gt; &quot;is a variable&quot;</div><div class="line">&#125;</div><div class="line">//如果match的选择器表达式带有这个注解,那么对于随后的模式的穷举性检查将被抑制掉</div></pre></td></tr></table></figure>
<h1 id="6-option类型"><a href="#6-option类型" class="headerlink" title="6.option类型"></a>6.option类型</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">scala为可选值定义了一个名为Option的标准类型,这种值可以有两种形式,可以是Some(x) 的形式,其中x是实际值,或者也可以是None对象,代表缺失的值</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; val capitals = Map(&quot;France&quot;-&gt;&quot;Pairs&quot;, &quot;Japan&quot;-&gt;&quot;Tokyo&quot;)</div><div class="line">capitals: scala.collection.immutable.Map[String,String] = Map(France -&gt; Pairs, Japan -&gt; Tokyo)</div><div class="line"></div><div class="line">scala&gt; capitals get &quot;France&quot;</div><div class="line">res13: Option[String] = Some(Pairs)</div><div class="line"></div><div class="line">scala&gt; capitals get &quot;North Pole&quot;</div><div class="line">res14: Option[String] = None</div><div class="line"></div><div class="line"></div><div class="line">//分离可选值,可以通过模式匹配进行</div><div class="line">def show(x: Option[String]) = x match &#123;</div><div class="line">  case Some(s) =&gt; s</div><div class="line">  case None =&gt; &quot;?&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//在scala命令行的执行结果如下</div><div class="line">scala&gt; show(capitals get &quot;Japan&quot;)</div><div class="line">res15: String = Tokyo</div><div class="line"></div><div class="line">scala&gt; show(capitals get &quot;North Pole&quot;)</div><div class="line">res16: String = ?</div><div class="line"></div><div class="line">/*</div><div class="line">java里最常用的是代表没有值的null,例如,java.util.HashMap的get方法要么返回存储在HashMap里的值,要么每找到返回null,这种方式对java起效,不过可能会隐藏错误,因为很难实际记得程序中哪个变量可以允许是null,如果变量允许为null,那么你就必须记住每次使用它的时候检查是否为null,一旦你忘记了检查,就难以避免运行时发生NullPointerException异常,又因为这种异常可能不是经常发生,所以想要通过测试发现故障是非常困难的,</div><div class="line">对于scala来说,这种方式根本不起作用,因为可以在哈希映射中存储值类型,而null不是值类型的合法元素,举例来说,HashMap[Int,Int] 不能返回null以表明&quot;没有元素&quot;</div><div class="line">*/</div></pre></td></tr></table></figure>
<h1 id="7-模式无处不在"><a href="#7-模式无处不在" class="headerlink" title="7.模式无处不在"></a>7.模式无处不在</h1><p>&emsp;在scala中模式可以出现在很多的地方,而不单单在match表达式里<br> 模式在变量定义中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">你在定义val或var的任何时候,都可以使用模式替代简单的标识符,例如,你可以使用模式拆分元组并把其中的每个值分配给变量,如下:</div><div class="line">*/</div><div class="line"></div><div class="line">scala&gt; val myTuple = (123, &quot;abc&quot;)</div><div class="line">myTuple: (Int, String) = (123,abc)</div><div class="line"></div><div class="line">scala&gt; val (number, string) = myTuple</div><div class="line">number: Int = 123</div><div class="line">string: String = abc</div><div class="line"></div><div class="line">scala&gt; number</div><div class="line">res17: Int = 123</div><div class="line"></div><div class="line">scala&gt; string</div><div class="line">res18: String = abc</div><div class="line"></div><div class="line"></div><div class="line">//使用样本类时这种构造非常有用,如果你知道正在用的样本类的精确结构,那就可以使用模式解构他</div><div class="line"></div><div class="line">scala&gt; val exp = new BinOp(&quot;*&quot;, Number(5), Number(1))</div><div class="line">exp: BinOp = BinOp(*,Number(5.0),Number(1.0))</div><div class="line"></div><div class="line">scala&gt; val BinOp(op, left, right) = exp</div><div class="line">op: String = *</div><div class="line">left: Expr = Number(5.0)</div><div class="line">right: Expr = Number(1.0)</div></pre></td></tr></table></figure></p>
<p> 用作偏函数的样本序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">花括号的样本序列(就是备选项) 可以用在能够出现函数字面量的任何地方,实质上,样本序列就是函数字面两,而且只有更普遍,函数字面量只有一个入口点和参数列表,但样本序列可以有多个入口点,每个都有自己的参数列表,每个样本都是函数的一个入口点,参数也被模式化特化,每个入口点的函数体都在样本的右侧</div><div class="line">*/</div><div class="line">val withDefault: Option[Int] =&gt; Int = &#123;</div><div class="line">    case Some(x) =&gt; x</div><div class="line">    case None =&gt; 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用</div><div class="line">withDefault(Some(10))</div><div class="line">res25: Int = 10</div><div class="line">withDefault(None)</div><div class="line">res26: Int = 0</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">val second: List[Int] =&gt; Int = &#123;</div><div class="line">    case x::y::_ =&gt; y</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">如果你编译上述代码,编译器会正确的提示说匹配并不全面,</div><div class="line">如果你传给一个三元素的列表,他的执行没有问题,但是如果传给他一个空列表就不行了</div><div class="line">*/</div><div class="line">second(List(5, 6, 7))    //6</div><div class="line">second(List())      //MatchError: List() </div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">你必须首先告诉编译器你知道正在使用的是偏函数,类型: List[Int] =&gt; Int 包含了不管是否为偏函数的,从整数列表到整数的所有函数</div><div class="line">仅包含从整数列表到整数的偏函数,那么应该写成PartialFunction[List[Int], Int] ,下面还是second函数,这次写成了使用偏函数类型</div><div class="line">*/</div><div class="line">val second: PartialFunction[List[Int], Int] = &#123;</div><div class="line">    case x::y::_ =&gt; y</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">偏函数有一个isDefinedAt 方法,可以用来测试是否函数对某个特定值有定义,本例中,函数对任何至少两个元素的列表有定义</div><div class="line">*/</div><div class="line">seconde.isDefinedAt(List(1,3,4))    //true</div><div class="line">seconde.isDefinedAt(List())    //false</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">上面的偏函数会对模式执行两次翻译,其中一次时真实函数的实现,另一次时测试函数是否有定义的实现,例如:上面的函数字面量(case x::y::_ =&gt; x) 会被翻译成下列的偏函数值</div><div class="line">*/</div><div class="line">new PartialFunction[List[Int], Int] &#123;</div><div class="line">    def apply(xs: List[Int]) = xs match &#123;</div><div class="line">        case x::y::_ =&gt; y</div><div class="line">    &#125;</div><div class="line">    def isDefinedAt(xs: List[Int]) = xs match &#123;</div><div class="line">        case x::y::_ =&gt; true</div><div class="line">        case _ =&gt; false</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//上面的翻译只有在函数字面量的声明类型为PartialFunction的时候才有效,如果声明的类型只是Function,或者根本不存在,那么函数字面量就会带而转义为完整的函数</div></pre></td></tr></table></figure></p>
<p> for 表达式的模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">for表达式里也可以使用模式,这个for表达式从capitals映射中获得所有的键/值对,每一对都匹配模式(country,city) 并定义了两个变量country,和city</div><div class="line">*/</div><div class="line">for((country, city) &lt;- capitals)</div><div class="line">    println(&quot;The capitals of &quot; + country + &quot; is &quot; + city)</div><div class="line"></div><div class="line"></div><div class="line">//不过模式同样也可能无法匹配产生的值</div><div class="line">val results = List(Some(&quot;apple&quot;), None, Some(&quot;orange&quot;))</div><div class="line">for(Some( fruit) &lt;- results )</div><div class="line">    println(fruit)</div><div class="line"></div><div class="line">apple</div><div class="line">orange</div><div class="line"></div><div class="line">/*</div><div class="line">如你在这个例子中所见,产生出来的不能匹配于模式的值被丢弃,例如:results列表里第二个元素None不匹配模式Some(Fruits) ,因此就没有出现在输出中</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h1 id="8-一个更大的例子"><a href="#8-一个更大的例子" class="headerlink" title="8.一个更大的例子"></a>8.一个更大的例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">需求:写一个计算数学表达式的例子,如&quot; x/x + 1 &quot;这样的除法,应该能够通过把被除数放在除数的顶上这种方式,被垂直打印如下</div><div class="line">*/</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//另一个例子是:表达式  ( a/(b*c) + (1/n) ) /3的二维布局:</div></pre></td></tr></table></figure>
<p> 第一步:集中注意力在水平布局上,结构化的表达式如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">BinOp(&quot;+&quot;,</div><div class="line">  BinOp(&quot;*&quot;,</div><div class="line">    BinOp(&quot;+&quot;, Var(&quot;x&quot;), Var(&quot;y&quot;)),</div><div class="line">    Var(&quot;z&quot;)</div><div class="line">  ),</div><div class="line">  Number(1)</div><div class="line">)</div><div class="line">//(x+y)*z + 1</div><div class="line"> </div><div class="line">/*</div><div class="line">要想知道哪里应该加括号,代码必须知道每个操作符相对的优先级,所以首先处理他是个好主意,你可以用如下形式的映射字面量直接表达相对优先级</div><div class="line">*/</div><div class="line"></div><div class="line">Map(</div><div class="line">    &quot;|&quot; -&gt; 0, &quot;||&quot; -&gt; 0,</div><div class="line">    &quot;&amp;&quot; -&gt; 1, &quot;&amp;&amp;&quot; -&gt;1, ...</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p> 完整代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">package org.stairwaybook.expr</div><div class="line">import org.stairwaybook.expr</div><div class="line"></div><div class="line">sealed abstract class Expr</div><div class="line">case class Var(name: String) extends Expr</div><div class="line">case class Number(num: Double) extends Expr</div><div class="line">case class UnOp(operator: String, arg: Expr) extends Expr</div><div class="line">case class BinOp(operator: String, left: Expr, right: Expr) extends Expr</div><div class="line"></div><div class="line">class ExprFormatter &#123;</div><div class="line">  //包含了递增优先级的组中的操作符</div><div class="line">  private val opGroups =</div><div class="line">    Array(</div><div class="line">      Set(&quot;|&quot;,&quot;||&quot;),</div><div class="line">      Set(&quot;&amp;&quot;, &quot;&amp;&amp;&quot;),</div><div class="line">      Set(&quot;^&quot;),</div><div class="line">      Set(&quot;==&quot;, &quot;!=&quot;),</div><div class="line">      Set(&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;),</div><div class="line">      Set(&quot;+&quot;, &quot;-&quot;),</div><div class="line">      Set(&quot;*&quot;, &quot;%&quot;)</div><div class="line">    )</div><div class="line">  //操作符到优先级的映射</div><div class="line">  private val precedence = &#123;</div><div class="line">    val assocs =</div><div class="line">      for (</div><div class="line">        i &lt;- 0 until opGroups.length;</div><div class="line">        op &lt;- opGroups(i)</div><div class="line">      ) yield op -&gt; i</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private val unaryPrecedence = opGroups.length</div><div class="line">  private val fractionPrecedence = -1 // 表示 / 的优先级</div><div class="line"></div><div class="line">  private def format(e: Expr, enclPred: Int): Element = e match &#123;</div><div class="line">    case Var(name) =&gt; elem(name)</div><div class="line">    case Number(num) =&gt;</div><div class="line">      def stripDot(s: String) =</div><div class="line">        if (s endsWith &quot;.0&quot;) s.substring(0, s.length-2)</div><div class="line">    case UnOp(op, arg) =&gt;</div><div class="line">      elem(op) beside format(arg, unaryPrecedence)</div><div class="line">    case BinOp(&quot;/&quot;, left, right) =&gt;</div><div class="line">      val top = format(left, fractionPrecedence)</div><div class="line">      val bot = format(right, fractionPrecedence)</div><div class="line">      val line = elem(&quot;-&quot;, top.width max bot.wiedht, 1)</div><div class="line">      val frac = top above line above bot</div><div class="line">      if (enclPred != fractionPrecedence) frac</div><div class="line">      else elem(&quot; &quot;) beside frac beside elem(&quot; &quot;)</div><div class="line">    case BinOp(op, left, right) =&gt;</div><div class="line">      val opPrec = precedence(op)</div><div class="line">      val l = format(left, opPrec)</div><div class="line">      val r = format(right, opPrec+1)</div><div class="line">      val oper = 1 beside elem(&quot; &quot;+op+&quot; &quot;) beside r</div><div class="line">      if (enclPred &lt;= opPrec) oper</div><div class="line">      else elem(&quot;(&quot;) beside oper beside elem(&quot;)&quot;)</div><div class="line">  &#125;</div><div class="line">  def format(e: Expr): Element = format(e,0)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import org.stairwaybook.expr._</div><div class="line">object Express extends Application &#123;</div><div class="line">  val f = new ExprFormatter</div><div class="line">  val e1 =</div><div class="line">    BinOp(&quot;*&quot;,</div><div class="line">      BinOp(&quot;/&quot;, Number(1), Number(2)),</div><div class="line">      BinOp(&quot;+&quot;, Var(&quot;x&quot;),Number(1))</div><div class="line">    )</div><div class="line"></div><div class="line">  val e2 =</div><div class="line">    BinOp(&quot;+&quot;,</div><div class="line">      BinOp(&quot;/&quot;,Var(&quot;x&quot;),Number(2)),</div><div class="line">      BinOp(&quot;/&quot;, Number(1.5), Var(&quot;x&quot;))</div><div class="line">    )</div><div class="line"></div><div class="line">  val e3 = BinOp(&quot;/&quot;, e1, e2)</div><div class="line">  def show(e: Expr) = println(f.format(e)+&quot;\n\n&quot;)</div><div class="line">  for (e &lt;- Array(e1,e2,e3)) show(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 输出结果</p>
<p><img src="http://ols7leonh.bkt.clouddn.com//assert/img/scala_programming/15/1.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/16/scala编程/第十五章 样本类和模式匹配/" data-id="cj290sb9x0082ssqqhwu5lowd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala编程/">scala编程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/04/16/scala编程/第十二章 特质/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          第十二章 特质
        
      </div>
    </a>
  
  
    <a href="/2017/04/16/scala编程/第十六章 使用列表/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">第十六章 使用列表</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IDEA/">IDEA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/NFS/">NFS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tachyon/">Tachyon</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/azkaban/">azkaban</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/echarts/">echarts</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/flume/">flume</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hadoop/">hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hbase/">hbase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hive/">hive</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/inotify/">inotify</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kafka/">kafka</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/logstash/">logstash</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/markdown/">markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/memcached/">memcached</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mongodb/">mongodb</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/project/">project</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/rsync/">rsync</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/socket/">socket</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/sqoop/">sqoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/storm/">storm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDEA/">IDEA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux基础命令/">Linux基础命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux重要配置文件/">Linux重要配置文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NFS/">NFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/azkaban/">azkaban</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echarts/">echarts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flume/">flume</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hbase/">hbase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hive/">hive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inotify/">inotify</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logstash/">logstash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mapreduce/">mapreduce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memcached/">memcached</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongodb/">mongodb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/project/">project</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rpc/">rpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rsync/">rsync</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala/">scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala函数式编程/">scala函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala编程/">scala编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spark/">spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqoop/">sqoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/storm/">storm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据仓库/">数据仓库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDEA/" style="font-size: 10px;">IDEA</a> <a href="/tags/Linux基础命令/" style="font-size: 19.52px;">Linux基础命令</a> <a href="/tags/Linux重要配置文件/" style="font-size: 14.76px;">Linux重要配置文件</a> <a href="/tags/NFS/" style="font-size: 10px;">NFS</a> <a href="/tags/NIO/" style="font-size: 11.43px;">NIO</a> <a href="/tags/azkaban/" style="font-size: 10.48px;">azkaban</a> <a href="/tags/echarts/" style="font-size: 10.95px;">echarts</a> <a href="/tags/flume/" style="font-size: 10.95px;">flume</a> <a href="/tags/hadoop/" style="font-size: 18.57px;">hadoop</a> <a href="/tags/hbase/" style="font-size: 13.33px;">hbase</a> <a href="/tags/hive/" style="font-size: 18.1px;">hive</a> <a href="/tags/inotify/" style="font-size: 10px;">inotify</a> <a href="/tags/java/" style="font-size: 12.38px;">java</a> <a href="/tags/kafka/" style="font-size: 12.86px;">kafka</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/logstash/" style="font-size: 10.48px;">logstash</a> <a href="/tags/mapreduce/" style="font-size: 16.67px;">mapreduce</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/memcached/" style="font-size: 13.81px;">memcached</a> <a href="/tags/mongodb/" style="font-size: 14.76px;">mongodb</a> <a href="/tags/mysql/" style="font-size: 17.14px;">mysql</a> <a href="/tags/netty/" style="font-size: 10.95px;">netty</a> <a href="/tags/nginx/" style="font-size: 14.29px;">nginx</a> <a href="/tags/project/" style="font-size: 10.48px;">project</a> <a href="/tags/python/" style="font-size: 19.05px;">python</a> <a href="/tags/redis/" style="font-size: 17.14px;">redis</a> <a href="/tags/rpc/" style="font-size: 10.48px;">rpc</a> <a href="/tags/rsync/" style="font-size: 10px;">rsync</a> <a href="/tags/scala/" style="font-size: 17.62px;">scala</a> <a href="/tags/scala函数式编程/" style="font-size: 11.9px;">scala函数式编程</a> <a href="/tags/scala编程/" style="font-size: 15.71px;">scala编程</a> <a href="/tags/shell/" style="font-size: 17.62px;">shell</a> <a href="/tags/socket/" style="font-size: 11.9px;">socket</a> <a href="/tags/spark/" style="font-size: 20px;">spark</a> <a href="/tags/sqoop/" style="font-size: 10.95px;">sqoop</a> <a href="/tags/storm/" style="font-size: 15.24px;">storm</a> <a href="/tags/zookeeper/" style="font-size: 16.19px;">zookeeper</a> <a href="/tags/数据仓库/" style="font-size: 11.43px;">数据仓库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/02/bigdata/spark从入门到精通_笔记/Tachyon/">Tachyon</a>
          </li>
        
          <li>
            <a href="/2017/04/30/数据仓库/数据仓库2/">数据仓库</a>
          </li>
        
          <li>
            <a href="/2017/04/29/IDEA/IDEA/">IDEA</a>
          </li>
        
          <li>
            <a href="/2017/04/29/数据仓库/ETL/">ETL</a>
          </li>
        
          <li>
            <a href="/2017/04/28/数据仓库/PowderDesigner/">PowderDesigner的使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Mr. Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>